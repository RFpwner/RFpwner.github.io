[{"title":"Reverse-Engineering","url":"/2025/03/04/Reverse-Engineering/","content":"\n# 配置连接\n\n1.运行`ssh-keygen -f key -N ''`命令，这会在当前目录下生成key和key.pub文件，分别是公钥和私钥。\n\n2.`cat key.pub`打印key.pub文件内容。\n\n3.将打印出的内容复制粘贴到Settings->SSH Key中。\n\n4.`ssh -i key hacker@dojo.pwn.college`连接至靶机\n\nssh -i key hacker@dojo.pwn.college\n\n# 视频内容\n\n## intro\n\n![QQ_1731939439682](Reverse-Engineering/QQ_1731939439682.png)\n\n这个过程中，信息总会丢失一些，所以逆向就是挖掘这些\n\n![QQ_1731939622787](Reverse-Engineering/QQ_1731939622787.png)\n\n前向工程工具\n\n![QQ_1731940359988](Reverse-Engineering/QQ_1731940359988.png)\n\n编译过程中会删除掉所有的宏定义，注释，之后生成汇编代码，并且替换掉了变量，用地址和偏移进行替换，通过strip 命令，可以移除调试符号和其他不必要的信息，从而减少文件大小并且提高加载效率，\n\n![QQ_1731940160453](Reverse-Engineering/QQ_1731940160453.png)\n\ngcc -g可以包括所有的，包括像类型，变量名变量大小等调试信息\n\n## function and frames\n\n![QQ_1731940466390](Reverse-Engineering/QQ_1731940466390.png)\n\n![QQ_1731940589345](Reverse-Engineering/QQ_1731940589345.png)\n\n![QQ_1731940673003](Reverse-Engineering/QQ_1731940673003.png)\n\n函数其实可以被表示为一个图，每一个块都是将一条条执行的指令，然后块被边连接着，也就是各种条件或者无条件跳转，之后通过理解这些触发跳转的条件，来理解函数逻辑\n\n![QQ_1731940867906](Reverse-Engineering/QQ_1731940867906.png)\n\n蓝线代表着无条件跳转，绿线代表着条件跳转，\n\n### 栈\n\n![image-20241118224510754](Reverse-Engineering/image-20241118224510754.png)\n\n局部变量放在了栈上面，\n\n![QQ_1731941491422](Reverse-Engineering/QQ_1731941491422.png)\n\ncall之后先压栈下一条指令的地址，之后存储rbp，\n\n退栈不物理清除数据，因此可能导致数据泄漏，\n\n![QQ_1731941685339](Reverse-Engineering/QQ_1731941685339.png)\n\n## data access\n\n![QQ_1731941873567](Reverse-Engineering/QQ_1731941873567.png)\n\n**栈上的数据**\n\n![QQ_1731941936296](Reverse-Engineering/QQ_1731941936296.png)\n\nelf**节中的变量**\n\n![image-20241118230116314](Reverse-Engineering/image-20241118230116314.png)\n\n这些一般都和指令有固定的偏移，通常通过rip 相对寻址去进行访问\n\n![QQ_1731942152969](Reverse-Engineering/QQ_1731942152969.png)\n\n会发现，程序被映射到内存中两次，一次是代码，一次是用于数据段，因此，代码和数据是从两个不同的区域进行访问的，\n\n**堆中的数据**\n\n![QQ_1731942313133](Reverse-Engineering/QQ_1731942313133.png)\n\n访问堆的指针通常存放在栈上，第一个存放在栈上的是数据，直接取出来rsp，rsp相当于是他的地址，之后解引用就可以获得数据，而第二个相当于将访问数据的指针存放在了栈上，获取到指针之后还需要堆指针进行进一步的解引用才能获取到后续的数据\n\n**数据结构**\n\n![QQ_1731942546591](Reverse-Engineering/QQ_1731942546591.png)\n\n获得该类数据你需要知道他都有什么东西，然后怎么存储的，怎么访问的怎么使用的，然后才能逆向出正确的数据\n\n## 静态逆向工具\n\n指的是，不运行的时候就能分析的工具，\n\n![QQ_1731942696072](Reverse-Engineering/QQ_1731942696072.png)\n\n![image-20241118231523162](Reverse-Engineering/image-20241118231523162.png)\n\n比如checksec后发现了有12个符号，之后通过nm -a来列举所有的符号，\n\n![QQ_1731942981591](Reverse-Engineering/QQ_1731942981591.png)\n\n课程里用的binary ninja cloud，免费\n\n![QQ_1731943334981](Reverse-Engineering/QQ_1731943334981.png)\n\n左上角这里，这里可以显示更多的信息，包括指令详细的操作码字节等等，\n\n![QQ_1731943413054](Reverse-Engineering/QQ_1731943413054.png)\n\n这里可以显示更熟悉的线性的界面，右键指令可以进行注释\n\n![QQ_1731943510694](Reverse-Engineering/QQ_1731943510694.png)\n\n这里的高级分析，能够分析的更加详细，并且进行反编译，\n\n![QQ_1731943704073](Reverse-Engineering/QQ_1731943704073.png)\n\n![QQ_1731943737736](Reverse-Engineering/QQ_1731943737736.png)\n\n但是他有可能抽象错细节，所以在这个课程里最好还是只用汇编视图\n\n## Dynamic \n\n![QQ_1732157745858](Reverse-Engineering/QQ_1732157745858.png)\n\n一个是追踪库调用，一个是追踪系统调用\n\n![QQ_1732157926525](Reverse-Engineering/QQ_1732157926525.png)\n\n强烈建议加入init文件的\n\ninfo proc map，能够查看映射的地址\n\n![QQ_1732158363246](Reverse-Engineering/QQ_1732158363246.png)\n\n![QQ_1732158430150](Reverse-Engineering/QQ_1732158430150.png)\n\n位置相关代码始终加载在同一个内存位置，但是内存无关代码并不是，gdb尝试永远在这个范围加载，最简单的就是通过set $base\n\n![QQ_1732158581019](Reverse-Engineering/QQ_1732158581019.png)\n\n通过-M可以指定汇编类型\n\n![QQ_1732158757967](Reverse-Engineering/QQ_1732158757967.png)\n\ngdb自带的重放比较低效，因此，rr更高效，但pwncollege不能用rr，kira比较简洁，用于逆向工程，还有reverse step in，rsi，会反向进行移动，前提是前面进行了record，但是有时候不准，当再次进行录音的时候，不会再次系统调用，只是重播录音\n\n## real world app\n\n\n\n# challenge\n\n## Level1.0\n\n![QQ_1732081107293](Reverse-Engineering/QQ_1732081107293.png)\n\n看一下程序\n\n![QQ_1732081126665](Reverse-Engineering/QQ_1732081126665.png)\n\n看这个样子，read读入了输出，打印出来对应的ascii码，然后，跟他对应的去比，得到最后的结果，对就给flag，那输入他要的就行\n\n## level1.1\n\n没啥区别啊感觉，\n\n![QQ_1732161158309](Reverse-Engineering/QQ_1732161158309.png)\n\n然后那个地址点进去，是数据段的一个数据\n\n![QQ_1732161177340](Reverse-Engineering/QQ_1732161177340.png)\n\n## Level2.0\n\n![QQ_1732166871690](Reverse-Engineering/QQ_1732166871690.png)\n\n1和4倒换jvsyo\n\n那就是yvsjo，显示不对，那就是josyv\n\n## Level2.1\n\ngdkjs\n\n那就是gskjd\n\n![QQ_1732167278042](Reverse-Engineering/QQ_1732167278042.png)\n\nbuf是int，4个字节，hibyte很有可能就是第四个字节，因此对应的byte就是第三个，所以\n\n是1和3互换了，gjkds\n\n## Level3.0\n\n![QQ_1732167464896](Reverse-Engineering/QQ_1732167464896.png)\n\n看这个样子，换了两次，第一次0和4互换之后，1和3互换，\n\nhvfsy\n\nysfvh\n\n## level3.1\n\njcaup\n\npuacj\n\n## Level4.0\n\n![QQ_1732168685059](Reverse-Engineering/QQ_1732168685059.png)\n\n看起来是冒泡\n\njlvxy\n\n## level5.0\n\n![QQ_1732169761183](Reverse-Engineering/QQ_1732169761183.png)\n\n看这个样子是全都异或了0x50，那就他要的再xor一次0x50就抵消了\n\n```\nfrom pwn import *\ndef str_to_byte(input_string: str, key: int = 0x50) ->str:\n    input_bytes = input_string.encode('utf-8')  # 将字符串转换为字节\n\n    # 对每个字节异或指定值\n    xor_result = bytes([b ^ key for b in input_bytes])\n\n    # 将异或结果转换回字符串\n    return xor_result.decode('utf-8', errors='ignore')\nstr=\"6?5%(\"\nresult=str_to_byte(str,0x50)\nprint(result)\n\n```\n\n首先encode将其转换为字节，之后异或，然后转换回来\n\n## level5.1\n\n![QQ_1732171545231](Reverse-Engineering/QQ_1732171545231.png)\n\n变成了0x46\n\n4</',27h,'7\n\n那应该就是4</'7\n\n![QQ_1732171775083](Reverse-Engineering/QQ_1732171775083.png)\n\n直接在双引号里'，就已经是单引号了\n\n## Level6.0\n\n![QQ_1732171929291](Reverse-Engineering/QQ_1732171929291.png)\n\n其实就是每三个字节每三个字节的进行异或,并且还进行了逆转，还进行了排序，\n\n\n\n![QQ_1732174268726](Reverse-Engineering/QQ_1732174268726.png)\n\nreverse主要把整个字符串反过来，1然后sort进行了一次冒泡排序，所以，对应的expected应该和这个反过来，首先既然是冒泡排序过的，那这个expected本身就应该是一个已经排序过的，果然，![QQ_1732174477205](Reverse-Engineering/QQ_1732174477205.png)\n\n\n\n所以只要对应的字节没有错就行，接下来，那这个reverse也没有任何的用哇，但是他每三个字节每三个字节的进行一次对应，如何确保最开始的和最终的那个三字节的对应是一样的呢，所以干脆就不管这些，直接全都逆转一遍，一定是没有错的\n\n果然就是什么都不用管，只需要去对应字节就行，因为排序和那个都是失效的\n\n```\nfrom pwn import *\ndef process_hex_list(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 3 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0xDA)\n        elif i % 3 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x92)\n        elif i % 3 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xAD)\n    \n    # 转换为字符串\n    return ''.join(chr(b) for b in processed_bytes)\n\n# 示例十六进制列表\nhex_list = [0xA0, 0xAC, 0xB4, 0xB5, 0xB7, 0xB7, 0xC1, 0xC1,\n            0xC6, 0xCB, 0xD9, 0xDC, 0xE3, 0xE5, 0xE7, 0xE8,\n            0xEB, 0xFB]\n\n# 调用函数\nresult = process_hex_list(hex_list)\nprint(result)\np=process('/challenge/babyrev-level-6-0')\n#ques=p.recvuntil(b'Ready to receive your license key!')\n#print(ques.decode())\np.sendline(result.encode())\nsleep(5)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n最后一个sleep很关键，不然的话调用recv的时候还没有接受完整，同时上面这个对list进行处理之后转换为str的方式可以借鉴，感觉很妙，通过append进行一个个的附加\n\n## Level6.1\n\nxqivthjqkczwowzxtdi\n\n0x13个字节，也就是19，\n\n![QQ_1732176954926](Reverse-Engineering/QQ_1732176954926.png)\n\n这不就啥也没干没\n\n哦，坑在这里，buf是一个8字节的，而读取了19个字节，因此，后面的v9，v10，一共12个字节里有11个也属于这个范围里，注意中间夹杂里一次，v9的第三个字节，等于第12个字节和v10的最低位，也就是第17个字节进行了对换，所以，因为进行了一次反转，就是第三个和第八个进行了一次互换\n\n![QQ_1732189975804](Reverse-Engineering/QQ_1732189975804.png)\n\n![QQ_1732190017931](Reverse-Engineering/QQ_1732190017931.png)\n\n## Level7.0\n\n![QQ_1732190707860](Reverse-Engineering/QQ_1732190707860.png)\n\n异或变成了以组为单位，其次，输入了26个字符，经过了，异或，逆转，排序，逆转，逆转，那就是说最后实际还是逆转过一次的，把expected，进行一次逆转，之后直接进行异或就是最后的答案,不对，排序在逆转之后，并且之后有两次逆转，所以根本不需要逆转，\n\n![QQ_1732192115688](Reverse-Engineering/QQ_1732192115688.png)\n\n排序是排成一个前小后大的，'a'  \\x80\n\n**解决了**\n\n因为当join的时候，一些不能显示的字符打印成了\\x80，这个直接杯join进了字符串，字符串实际已经不能转变为原来的那些raw字节了，发生了变化，因此直接把原始字节传输过去就行了\n\n```\nfrom pwn import *\ndef process_hex_list(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 5 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x4d)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0xa5)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xa4)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x39)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 4:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x88)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n    \n    # 转换为字符串\n    #r1 = ''.join(chr(b) for b in processed_bytes)\n    #print(r1)\n    #print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\n# 示例十六进制列表\nhex_list = [0x21, 0x25, 0x27, 0x27, 0x2B, 0x39, 0x43, 0x49, 0x52, 0x5B, 0x5B, \n            0xC0, 0xC2, 0xC2, 0xC6, 0xCD, 0xCE, 0xD2, 0xD5, 0xD6, 0xD7, 0xE0, \n            0xE2, 0xEB, 0xF8, 0xFE]\n\n# 调用函数\nresult = process_hex_list(hex_list)\nprint(result)\np=process('/challenge/babyrev-level-7-0')\n#ques=p.recvuntil(b'Ready to receive your license key!')\n#print(ques.decode())\np.sendline(result)\nsleep(5)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n## Level7.1\n\n![QQ_1732607204789](Reverse-Engineering/QQ_1732607204789.png)\n\n![QQ_1732607216265](Reverse-Engineering/QQ_1732607216265.png)\n\n看这个样子，读了0x1c，28个字节，上面存储的时候buf只是一个int64，8个字节，所以，这里v13的第五个字节相当于是第13个字节，然后，v15相当于是第25个字节，这两个进行了互换，之后他们进行了逆序，然后进行了按字节与的操作，之后再次逆序，然后冒泡排序，那么顺序同样还是没有啥用，直接找对应的字节\n\n![QQ_1732607310786](Reverse-Engineering/QQ_1732607310786.png)\n\n```\nfrom pwn import *\ndef process_hex_list(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 5 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x2c)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x1)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xf3)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x40)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n        elif i % 5 == 4:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xee)\n            print('processed_bytes[%d]: ',i)\n            print(hex(processed_bytes[i]))\n            print('\\n')\n    \n    # 转换为字符串\n    r1 = ''.join(chr(b) for b in processed_bytes)\n    print(r1)\n    print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\n# 示例十六进制列表\n\norign_hex_list = [0x29, 0x2B, 0x2C, 0x30, 0x36, 0x43, 0x48, 0x49, 0x4B, 0x59,\n    0x5D, 0x60, 0x68, 0x71, 0x72, 0x75, 0x75, 0x81, 0x81, 0x82,\n    0x83, 0x83, 0x84, 0x87, 0x87, 0x91, 0x97, 0x9B]\n\norign_hex_list.reverse()\n\nresult = process_hex_list(orign_hex_list)\n\nend_hex_list = list(result)\n\nend_hex_list.reverse()\n\nend_hex_list[13], end_hex_list[24] = end_hex_list[24], end_hex_list[13]\n\nend_result = bytes(end_hex_list)\n\nprint(result)\np=process('/challenge/babyrev-level-7-1')\n#ques=p.recvuntil(b'Ready to receive your license key!')\n#print(ques.decode())\np.sendline(end_result)\nsleep(5)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n为了避免老眼昏花，直接把他的所有东西都逆转进行了一遍得到结果\n\n## Level8.0\n\n读取0x25个字节，也就是37个字节，交换索引为2和30的两个字节，之后进行了排序，之后全都异或0x98，之后进行了倒序，之后，按照三个字节为一组进行异或，然后再逆序，之后6个字节为一组进行异或，当我全都翻过来，到了排序后，那就是一个已经排序完毕的![QQ_1732620949503](Reverse-Engineering/QQ_1732620949503.png)\n\n\n\n\n\n\n\n这里的buf是一个24字节的数组\n\n![QQ_1732621517119](Reverse-Engineering/QQ_1732621517119.png)\n\n![QQ_1732621670667](Reverse-Engineering/QQ_1732621670667.png)\n\n![QQ_1732626247023](Reverse-Engineering/QQ_1732626247023.png)\n\n![QQ_1732626339895](Reverse-Engineering/QQ_1732626339895.png)\n\n问题出在了\n\n![QQ_1732627430323](Reverse-Engineering/QQ_1732627430323.png)\n\n这里没有修改原本的元素,没有解决\n\n```\nfrom pwn import *\ndef process_list_6(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 6 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x65)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 6 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x5)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 6 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xdf)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 6 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x36)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 6 == 4:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x10)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 6 == 5:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xdf)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n    \n    # 转换为字符串\n    #r1 = ''.join(chr(b) for b in processed_bytes)\n    #print(r1)\n    #print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\n\ndef process_list_3(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 3 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x86)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 3 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x90)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 3 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x6f)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n    \n    # 转换为字符串\n    #r1 = ''.join(chr(b) for b in processed_bytes)\n    #print(r1)\n    #print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\n# 示例十六进制列表\n\nhex_list = [0xF3, 0x79, 0xB5, 0xA2, 0x6A, 0xB3, 0xF7, 0x7D, 0xB0, 0xA6, \n    0x69, 0xBC, 0xFE, 0x77, 0xBA, 0xAE, 0x7E, 0xA7, 0xE0, 0x68,\n    0xA4, 0xB2, 0x7A, 0xA2, 0xE7, 0x6E, 0xA1, 0xB7, 0x79, 0xAF,\n    0xEA, 0x63, 0xAE, 0xB8, 0x74, 0xAD, 0xE8]\n\n#every 6 bytes xor\nbytes_6=process_list_6(hex_list)\n\n#transfer to lsit\nlist_6 = list(bytes_6)\n\nprint('-----------this is after xor 6bytes---------------')\nprint([hex(x) for x in list_6])\n\n#reverse\nlist_6.reverse()\n\nprint('-----------this is after xor reverse---------------')\nprint([hex(x) for x in list_6])\n\n#every 3 bytes xor\nbyte_3 = process_list_3(list_6)\n\n#transfer to list\nlist_3 = list(byte_3)\n\nprint('-----------this is after xor 3bytes---------------')\nprint([hex(x) for x in list_3])\n\n#reverse\nlist_3.reverse()\n\nprint('-----------this is after  reverse---------------')\nprint([hex(x) for x in list_3])\n\n#xor 0x98\nxor_value = 0x98\nlist_xor = [x ^ xor_value for x in list_3]\n\nprint('-----------this is after xor 0x98---------------')\nprint([hex(x) for x in list_xor])\n\n\nlist_xor[2] , list_xor[30] = list_xor[30] , list_xor[2]\n\n\nend_result = bytes(list_xor)\n\np=process('/challenge/babyrev-level-8-0')\n#ques=p.recvuntil(b'Ready to receive your license key!')\n#print(ques.decode())\np.sendline(end_result)\nsleep(5)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n问题出在这个反了吗的\n\n![QQ_1732628281590](Reverse-Engineering/QQ_1732628281590.png)\n\n源程序反着来的吗的，解决\n\n## Level8.1\n\n观察源程序，read0x25，之后进行逆序，7字节异或，之后第6个字节和第31个字节互换，然后，5字节异或，排序，4字节异或，4字节异或，\n\n```\nfrom pwn import *\ndef process_list_7(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 7 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x8f)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 7 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x7)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 7 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x6e)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 7 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0xa2)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 7 == 4:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xf8)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 7 == 5:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xb6)\n        elif i % 7 == 6:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xbc)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n    \n    # 转换为字符串\n    #r1 = ''.join(chr(b) for b in processed_bytes)\n    #print(r1)\n    #print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\ndef process_list_5(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 5 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x3d)\n        elif i % 5 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x77)\n        elif i % 5 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xc1)\n        elif i % 5 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x64)\n        elif i % 5 == 4:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x66)\n    return bytes(processed_bytes)\n\ndef process_list_4_1(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 4 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x49)\n        elif i % 4 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x4e)\n        elif i % 4 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x47)\n        elif i % 4 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x78)\n    return bytes(processed_bytes)\n\ndef process_list_4_2(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 4 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x93)\n        elif i % 4 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0xcd)\n        elif i % 4 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0xcd)\n        elif i % 4 == 3:      # 第二个节\n            processed_bytes.append(hex_list[i] ^ 0x39)\n    return bytes(processed_bytes)\n\ndef process_list_3(hex_list):\n    # 用于存储处理后的字节\n    processed_bytes = []\n    \n    # 遍历列表，按每三个字节处理\n    for i in range(len(hex_list)):\n        if i % 3 == 0:        # 第一个字节\n            processed_bytes.append(hex_list[i] ^ 0x6f)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 3 == 1:      # 第二个字节\n            processed_bytes.append(hex_list[i] ^ 0x90)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n        elif i % 3 == 2:      # 第三个字节\n            processed_bytes.append(hex_list[i] ^ 0x86)\n            # print('processed_bytes[%d]: ',i)\n            # print(hex(processed_bytes[i]))\n            # print('\\n')\n    \n    # 转换为字符串\n    #r1 = ''.join(chr(b) for b in processed_bytes)\n    #print(r1)\n    #print(r1.encode('latin1'))\n    return bytes(processed_bytes)\n\n# 示例十六进制列表\n\nhex_list = [0xDA, 0x80, 0x8E, 0x45, 0xCB, 0x97, 0x93, 0x65, 0xF3, 0xD0,\n    0xDC, 0x21, 0xB8, 0xED, 0x1B, 0xD9, 0x44, 0x21, 0x22, 0xE9,\n    0x70, 0x2F, 0x38, 0xF3, 0x68, 0x36, 0x3D, 0xF8, 0x19, 0x5B,\n    0x56, 0xA5, 0x36, 0x70, 0x7C, 0xBA, 0x21]\n\n#every 4_2 bytes xor\nbytes_4_2=process_list_4_2(hex_list)\n\n#transfer to lsit\nlist_4_2 = list(bytes_4_2)\n\n#every 4_1 bytes xor\nbytes_4_1=process_list_4_1(list_4_2)\n\n#transfer to lsit\nlist_4_1 = list(bytes_4_1)\n\n#every 5 bytes xor\nbytes_5=process_list_5(list_4_1)\n\n#transfer to lsit\nlist_5 = list(bytes_5)\n\n#swap\nlist_5[5] , list_5[30] = list_5[30] , list_5[5]\n\n#every 5 bytes xor\nbytes_7=process_list_7(list_5)\n\n#transfer to lsit\nlist_7 = list(bytes_7)\n\nlist_7.reverse()\n\nend_result = bytes(list_7)\n\np=process('/challenge/babyrev-level-8-1')\n#ques=p.recvuntil(b'Ready to receive your license key!')\n#print(ques.decode())\np.sendline(end_result)\nsleep(2)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n## Level9.0\n\n这题没太看懂，先看看让干啥吧\n\n![QQ_1732630490453](Reverse-Engineering/QQ_1732630490453.png)\n\n首先看这个，他read0x1a，也就是26个字节，但是buf只有8字节，buf，v16，v17和v18的低2字节都在read里，\n\n![QQ_1732630593382](Reverse-Engineering/QQ_1732630593382.png)\n\n看挑战程序的话，就是\n\n![QQ_1732630685400](Reverse-Engineering/QQ_1732630685400.png)\n\n更改了这几个位置的字节，那就是v5是填写的偏移，v4是填写的目标字节的值，v5是16位的数，之后，读取了之后，他通过md5进行了哈希，因此不可逆，之后，帖子说这个v12是程序加载基址，那么，原来如此，这里可以任意patch，所以说，可以直接将最后win的那个判断改成不相等才跳过，那这样的话就直接win了\n\n![QQ_1732631837626](Reverse-Engineering/QQ_1732631837626.png)\n\njnz是0x75，而jz是0x74，他是\n\n![QQ_1732631891483](Reverse-Engineering/QQ_1732631891483.png)\n\n在不等于这里，他是不等于才跳走，所以改成等于条件不成立就不跳走了\n\n## Level9.1\n\n![QQ_1732632303479](Reverse-Engineering/QQ_1732632303479.png)\n\n226b处\n\n## Level10.0\n\n只允许一个字节了，\n\n![QQ_1732632591400](Reverse-Engineering/QQ_1732632591400.png)\n\n## level10.1\n\n0x23c1\n\n## level11.0\n\n![QQ_1732632841665](Reverse-Engineering/QQ_1732632841665.png)\n\n说是之后会检查，然后让修改两次，所以我才回头还要修改回来\n\n是对s1和s2的内容进行了一个相同性检查，所以，正常的修改，触发了完整性检查，为什么呢，\t懂了，还需要把那个检查完整性的改了，\n\n![QQ_1732633555585](Reverse-Engineering/QQ_1732633555585.png)\n\n222b \n\n拿下\n\n## Level11.1\n\n2559,247b，这里有一个坑，就是他是一个拓展过的jnz，是0f 85，后面跟着32位的偏移量，而之前的是跟着8位的，所以这里应该是247c,变成0x84\n\n## Level12.0\n\n\n\n![image-20241202191234867](Reverse-Engineering/image-20241202191234867.png)\n\n主程序没有看到什么特殊的，之后运转了下面那个函数，传入了v3，也就是256个字节的0，\n\n![image-20241202191402026](Reverse-Engineering/image-20241202191402026.png)\n\n在这个函数里面，首先读入了8个字节，放在了a1[60]的位置，然后，赋值了一系列的，从a1[92]到a1[99]的8个字节，之后v1被赋值为memcmp的返回值，比较的就是这两个8字节，如果v1是非0，那不对，如果说v1为0才会打印，那就是要这两个位置都相同呗，\n\n![image-20241202195333308](Reverse-Engineering/image-20241202195333308.png)\n\n要发的字节就是这些了，那么发送的方式有很多种，第一种是通过struct中的pack函数将数字转换为二进制数据并且按照指定格式打包\n\n```\na1 = [47, 66, 117, -18, -4, 89, -54, 53]\n\n# 使用 struct.pack 将每个整数打包为字节\n# 'b' 格式符表示 signed char（-128 到 127），这样负数会被转换为 2 的补码\ndata = struct.pack('8b', *a1)\n```\n\n第二种是通过array模块的array创建一个字节数组\n\n```\n# 要发送的数值\na1 = [47, 66, 117, -18, -4, 89, -54, 53]\n\n# 使用 array 模块创建一个包含字节的数组\n# 'b' 表示有符号字节（signed char）\nbyte_array = array.array('b', a1)\n\n# 发送字节数据\np.send(byte_array.tobytes())\n```\n\n第三个是通过手动转换，因为一个字节的话，负数用的是他的补码形式\n\n```\na1 = [47, 66, 117, -18, -4, 89, -54, 53]\n\n# 手动将每个整数转换为字节（负数转补码）\ndata = bytearray(((x + 256) % 256) for x in a1)\n\n```\n\n注意，bytes和b''不一样，bytes是一个内建类型，表示不可变的字节序列，而b‘’是通过在字符串前面添加b表示这是一个字节序列\n\n\n\n```\nfrom pwn import *\np=process('/challenge/babyrev-level-12-0')\na1 = [47, 66, 117, -18, -4, 89, -54, 53]\n\n# 将每个数值转换为字节，并打包成二进制数据\n# 使用 'b' 格式符，表示一个字节（signed char），范围是 -128 到 127\n# 如果需要处理负数，struct 会将其转换为 2 的补码表示\ndata = bytes([((x + 256) % 256) for x in a1])\n\n或者\ndata = bytes([0x2f,0x42,0x75,0xee,0xfc,0x59,0xca,0x35])\np.send(data)\nsleep(2)  # 等待程序输出完整\n\nout=p.recv(4096)\nprint(out.decode())\n```\n\n## Level12.1\n\n![image-20241202201331027](Reverse-Engineering/image-20241202201331027.png)\n\n## Level13.0\n\n让我们深入研究逆向工程混淆代码！此挑战使用基于 VM 的混淆：逆向工程自定义模拟器和架构以了解如何获取标志！如果你很聪明的话，你就不需要逆向太多的 VM 代码。\n\n![image-20241202201840855](Reverse-Engineering/image-20241202201840855.png)\n\n这里来看，他读取了8个字节到a1+55这个位置，之后\n\n![image-20241202202057907](Reverse-Engineering/image-20241202202057907.png)\n\n目的仍然是a1+87的8个字节和a1+55的8个字节相同，这个函数传进来了一个256字节的起始位置，\n\n三个参数，第二个参数来看，1是b，64是c，2是a，\n\n首先看看这个样子，stm *0x87就是0xcb，stm *0x88为0x21，也就是说以b为基底，然后c为一个1，每次加一下他，那8个字节就是，0xcb，0x21，0xb3,0xb0,0xd4,0xae,0x9c,0x1\n\n## Level13.1\n\n\n\n![image-20241202205036562](Reverse-Engineering/image-20241202205036562.png)\n\n这8个字节应该说，\n\n![image-20241202205331646](Reverse-Engineering/image-20241202205331646.png)\n\n传入的仍然是256个字节的0，之后，\n\n![image-20241202205405061](Reverse-Engineering/image-20241202205405061.png)\n\n![image-20241202205613645](Reverse-Engineering/image-20241202205613645.png)\n\nsub1533又跳到了sub1415，然后这里是，a3为位置，a2是对应的变量代表的值\n\n那也就是说16这等于88，然后4等于1，这一个应该是那个索引，之后2等于222，\n\n![image-20241202205910190](Reverse-Engineering/image-20241202205910190.png)\n\n0x1687这个函数，首先，传入了a1，16，2，这个16应该就是下标索引，2的话就是2里面的值，也就是说a1[88]=222，以此类推8个字节分别是222，86，175，83，92，217，104，188\n\n## Level14.0\n\n![image-20241202210541161](Reverse-Engineering/image-20241202210541161.png)\n\nimm的作用已经知道了，现在看一下sys的作用，第一个sys传进去了a1，32，8，能看出来32就是最开始的b，而8是a，那就是说传入了b和a，\n\n![image-20241202210713305](Reverse-Engineering/image-20241202210713305.png)\n\n![image-20241202211326046](Reverse-Engineering/image-20241202211326046.png)\n\n在sys里面，有一个选择结构，是根据a2进行选择的，32是0x20，所以是一个读取操作，a1[258]就到了main函数的v4的第三个字节，但是整个v4都是0啊，没太看懂，\n\n![image-20241202215534330](Reverse-Engineering/image-20241202215534330.png)\n\nWrite_register(a1,8,v9)\n\n但是通过return![image-20241202215055964](Reverse-Engineering/image-20241202215055964.png)\n\n能看到，如果a3不为0的话，这里a3就是8，那么就会执行这个，![image-20241202215212631](Reverse-Engineering/image-20241202215212631.png)\n\nreturn了a1[256]给v11，v12是\n\n![image-20241202215400452](Reverse-Engineering/image-20241202215400452.png)\n\n应该就是一个字符，这里也就是a，最后打印出来的就是![image-20241202215439457](Reverse-Engineering/image-20241202215439457.png)\n\n对应的0x4的值是a1[256]\n\n回到比较结果\n\n![image-20241202221430148](Reverse-Engineering/image-20241202221430148.png)\n\n比较了四个字节，比较的是137和105开始的四个字节\n\n137开始的四个字节是0x67,0x30,0x9d,0xba\n\n看了半天，结果直接输入就行了，我服了，那我在分析nm呢,那从结论返回推过程，看一下怎么输入到a1+105的，首先a=0，b=105，c=4，\n\n之后sys （0x20，a）\n\n\n\n\n\n原来如此，我明白了，前面imm赋值过程中其实就改变了那几个数，这下就明了了，\n\n![image-20241202224449181](Reverse-Engineering/image-20241202224449181.png)\n\n首先第一个imm，\n\n![image-20241202224504315](Reverse-Engineering/image-20241202224504315.png)\n\n![image-20241202224516811](Reverse-Engineering/image-20241202224516811.png)\n\n32 ，105，那就是将a1[257]变成了105\n\n1 ，4 就是将a1[258]变成了4\n\n8,0 就是把a1[256]变成了0，接下来再进入到之前的流程\n\n![image-20241202224638561](Reverse-Engineering/image-20241202224638561.png)\n\nsys的read过程中，v5=4，然后256-105>4，所以if并不触发，之后就是v6=sys_read,相当于read(0,&a[105],4)读取了4个字节，他妈的，分析完毕！结束！win！\n\n## level14.1\n\n\n\n![image-20241202225936574](Reverse-Engineering/image-20241202225936574.png)\n\n![image-20241202230240268](Reverse-Engineering/image-20241202230240268.png)\n\n![image-20241202230428697](../../image/image-20241202230428697.png)\n","tags":["pwn college"],"categories":["pwn college"]},{"title":"解决mac上的pwntools问题","url":"/2025/03/04/解决mac上的pwntools问题/","content":"\n# 解决mac上的pwntools问题\n\n首先是pwntools的环境配置，brew下载完毕之后，\n\n进入python3的交互界面\n\n```python\nimport site\nsite.getsitepackages()\n回显\n/opt/homebrew/Cellar/python@3.13/3.13.0_1/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages\n```\n\n之后，进入到该目录，然后创建一个mypath.pth\n\n里面加入`/opt/homebrew/Cellar/pwntools/4.13.1/libexec/lib/python3.13/site-packages`\n\n之后，就可以全局用了\n\n之后，下载bintils，\n\n`brew install https://raw.githubusercontent.com/Gallopsled/pwntools-binutils/master/macos/binutils-amd64.rb`\n\n这样不行，打开这个页面\n\n![image.png](%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E7%9A%84pwntools%E9%97%AE%E9%A2%98/image.png)\n\n```python\nclass BinutilsAmd64 < Formula\n  homepage \"https://www.gnu.org/software/binutils/binutils.html\"\n  url \"https://ftpmirror.gnu.org/binutils/binutils-2.38.tar.gz\"\n  mirror \"https://ftp.gnu.org/gnu/binutils/binutils-2.38.tar.gz\"\n  sha256 \"b3f1dc5b17e75328f19bd88250bee2ef9f91fc8cbb7bd48bdb31390338636052\"\n\n  # No --default-names option as it interferes with Homebrew builds.\n\n  def install\n    system \"./configure\", \"--disable-debug\",\n                          \"--disable-dependency-tracking\",\n                          \"--prefix=#{prefix}\",\n                          \"--target=amd64-unknown-linux-gnu\",\n                          \"--disable-static\",\n                          \"--disable-multilib\",\n                          \"--disable-nls\",\n                          \"--disable-werror\"\n    system \"make\", \"MAKEINFO=true\", \"-j\"\n    system \"make\", \"MAKEINFO=true\", \"install\"\n    system \"rm\", \"-rf\", \"#{prefix}/share/info\"\n  end\n\n  test do\n    assert .include? 'main'\n    assert_equal 0, 0.exitstatus\n  end\nend\n```\n\n之后在github创建一个仓库，然后里面\n\n![image.png](%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E7%9A%84pwntools%E9%97%AE%E9%A2%98/image%201.png)\n\n之后，通过`brew tap lhy/my-tap [https://gitee.com/liu-sad/binutils.gi](https://gitee.com/liu-sad/binutils.git)t`\n\n创建一个tap仓库好像是，然后就可以本地下载了，\n\nbrew install binutils-amd64\n\n然后，运行成功！\n\n![image.png](image%202.png)\n","tags":["mac","pwntools"]},{"title":"categories","url":"/categories/index.html"},{"title":"tags","url":"/tags/index.html"},{"title":"about","url":"/about/index.html"}]